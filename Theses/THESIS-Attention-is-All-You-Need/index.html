<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="我读书少，你莫骗我。"><title>必读论文 · Attention Is All You Need (2017) | 愚苏记</title><link rel="stylesheet" type="text/css" href="https://cdn.staticfile.org/lxgw-wenkai-webfont/1.6.0/style.css"><link rel="stylesheet" type="text/css" href="../../css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="../../lib/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="../../lib/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="../../lib/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="../../lib/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="../../lib/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="../../favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="../../favicon.ico"><link rel="apple-touch-icon" href="../../apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="../../apple-touch-icon.png"><script><!-- hexo-inject:begin --><!-- hexo-inject:end -->var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = 'https://hm.baidu.com/hm.js?' + '96c862f2728296588ae9849f3bcb95db';
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();</script><link rel="alternate" type="application/atom+xml" href="../../atom.xml"><meta name="generator" content="Hexo 7.1.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">必读论文 · Attention Is All You Need (2017)</h1><a id="logo" href="../../.">愚苏记</a><p class="description">To no avail but try.</p></div><div id="nav-menu"><a class="current" href="../../."><i class="fa fa-home"> Home</i></a><a href="../../archives/"><i class="fa fa-archive"> Archive</i></a><a href="../../about/"><i class="fa fa-user"> About</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container no-padding-right"><div class="post"><h1 class="post-title">必读论文 · Attention Is All You Need (2017)</h1><div class="post-meta">Feb 26, 2024<span> | </span><span class="category"><a href="../../categories/Theses/">Theses</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 7.5k</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 26</span><span class="post-meta-item-text"> Minutes</span></span></span></div><a class="disqus-comment-count" data-disqus-identifier="Theses/THESIS-Attention-is-All-You-Need/" href="#disqus_thread"></a><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">Contents</div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Abstract"><span class="toc-number">1.</span> <span class="toc-text">Abstract</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Introduction"><span class="toc-number">2.</span> <span class="toc-text">Introduction</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Background"><span class="toc-number">3.</span> <span class="toc-text">Background</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Model-Architecture"><span class="toc-number">4.</span> <span class="toc-text">Model Architecture</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Encoder-and-Decoder-Stacks"><span class="toc-number">4.1.</span> <span class="toc-text">Encoder and Decoder Stacks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Attention"><span class="toc-number">4.2.</span> <span class="toc-text">Attention</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Scaled-Dot-Product-Attention"><span class="toc-number">4.2.1.</span> <span class="toc-text">Scaled Dot-Product Attention</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Multi-Head-Attention"><span class="toc-number">4.2.2.</span> <span class="toc-text">Multi-Head Attention</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Applications-of-Attention-in-our-Model"><span class="toc-number">4.2.3.</span> <span class="toc-text">Applications of Attention in our Model</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Position-wise-Feed-Forward-Networks"><span class="toc-number">4.3.</span> <span class="toc-text">Position-wise Feed-Forward Networks</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Embeddings-and-Softmax"><span class="toc-number">4.4.</span> <span class="toc-text">Embeddings and Softmax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Positional-Encoding"><span class="toc-number">4.5.</span> <span class="toc-text">Positional Encoding</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Why-Self-Attention"><span class="toc-number">5.</span> <span class="toc-text">Why Self-Attention</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Training"><span class="toc-number">6.</span> <span class="toc-text">Training</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Training-Data-and-Batching"><span class="toc-number">6.1.</span> <span class="toc-text">Training Data and Batching</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hardware-and-Schedule"><span class="toc-number">6.2.</span> <span class="toc-text">Hardware and Schedule</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Optimizer"><span class="toc-number">6.3.</span> <span class="toc-text">Optimizer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Regularization"><span class="toc-number">6.4.</span> <span class="toc-text">Regularization</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Result"><span class="toc-number">7.</span> <span class="toc-text">Result</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Machine-Translation"><span class="toc-number">7.1.</span> <span class="toc-text">Machine Translation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Model-Variations"><span class="toc-number">7.2.</span> <span class="toc-text">Model Variations</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#English-Constituency-Parsing"><span class="toc-number">7.3.</span> <span class="toc-text">English Constituency Parsing</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Conclusion"><span class="toc-number">8.</span> <span class="toc-text">Conclusion</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Source"><span class="toc-number">9.</span> <span class="toc-text">Source</span></a></li></ol></div></div><div class="post-content"><h2 id="Abstract">Abstract</h2>
<!-- hexo-inject:begin --><!-- hexo-inject:end --><p>主流的序列转换模型都建立在复杂的循环神经网络或卷积神经网络之上，它们都包含编码器和解码器。而且，最优秀的模型还会通过注意力机制（attention mechanism）将编码器和解码器连接起来。我们提出了一种新的网络架构——Transformer，它完全依赖于注意力机制，而不再需要复杂的循环和卷积过程。在两项机器翻译任务的实验中，这种模型在质量上表现出色，同时具有更高的并行性，训练时间也大大缩短。在WMT 2014年的英德翻译任务中，我们的模型达到了28.4的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/BLEU">BLEU</a>分数，比现有的最好成绩（包括集成模型）提高了2个以上的BLEU分数。在WMT 2014年的英法翻译任务中，我们的模型在八个GPU上训练3.5天后，创造了41.8的SOTA BLEU新纪录，这只是最好模型训练成本的一小部分。我们还证明，无论是在大规模训练数据还是有限训练数据的情况下，Transformer都能成功应用于英语句法解析任务，从而证明了其良好的泛化性能。</p>
<h2 id="Introduction">Introduction</h2>
<p>循环神经网络，尤其是长短期记忆（Long Short-Term Memory）和门控循环神经网络（Gated Recurrent Neural Networks），在序列建模和转换问题上已经成为SOTA方法，这些问题包括语言建模和机器翻译。自那时起，大量的研究工作不断尝试突破循环语言模型和编码-解码架构的技术限制。</p>
<p>循环模型通常会根据输入和输出序列中的符号位置进行计算。它们会生成一系列的隐藏状态 $h_t$ ，这个状态是由前一状态 $h_{t-1}$ 和当前位置 $t$ 的输入共同决定的。这种固有的顺序性使得在单个训练样例中进行并行化变得不可能，这在处理长序列时尤其关键，因为内存限制使得无法在多个样例间进行批处理。最近的研究通过使用分解技巧和条件计算，不仅大大提升了计算效率，而且在后者的情况下，模型的性能也得到了提升。然而，顺序计算的基本限制仍然无法被克服。</p>
<p>注意力机制已经成为各种任务中序列建模和转导模型的关键部分，它可以在不考虑输入或输出序列中的距离的情况下，模拟出数据间的依赖关系。然而，除少数情况外，这种注意力机制通常都是与循环网络一起使用的。</p>
<p>在这项工作中，我们提出了 Transformer，这是一种新的模型架构，它不再依赖循环网络，而是完全依赖于注意力机制来处理输入和输出之间的全局依赖关系。Transformer 允许更高效的并行处理，只需在八个 P100 GPU 上训练短短十二小时，就能达到前所未有的翻译质量。</p>
<h2 id="Background">Background</h2>
<p>‘Extended Neural GPU’，‘ByteNet’ 和 ‘ConvS2S’ 都秉承了减少顺序计算的设计理念，它们都采用卷积神经网络作为基础模块，能够并行处理所有输入和输出的隐藏表示。然而，在这些模型中，如果想要建立两个任意输入或输出位置之间的关系，所需的计算步骤会随着位置间距离的增加而增加，‘ConvS2S’ 是线性增长，而 ‘ByteNet’ 则是对数增长。这使得模型在学习远距离位置间的关系时面临更大的困难。相比之下，Transformer 将这个问题简化为固定数量的操作，尽管这样做会因为平均注意力加权位置而降低有效的分辨率，但我们在第3.2节中介绍的多头注意力机制可以有效地解决这个问题。</p>
<p>自注意力，有时也被称为内部注意力，是一种将单一序列中不同位置的信息进行关联，以此来计算出序列的表征的注意力机制。自注意力已经在许多任务中取得了成功，这些任务包括理解阅读内容、进行抽象的总结、理解文本的内在含义，以及学习与具体任务无关的句子表征。</p>
<p>端到端记忆网络是基于循环注意力机制构建的，而不是依赖于序列对齐的循环机制。这种网络已经在简洁语言的问题回答和语言模型构建任务上展现出了优秀的性能。</p>
<p>据我们所知，Transformer 是首个完全依赖自注意力来计算其输入和输出表示的转换模型，它并未使用任何序列对齐的 RNN 或卷积。在接下来的部分，我们将详细介绍 Transformer，阐述自注意力的重要性，并探讨它相较于 ‘ICLR (2016)’，‘Neural machine translation in linear time (2017)’ 和 ‘Convolutional seq2seq learning (2017)’ 等模型的优势。</p>
<h2 id="Model-Architecture">Model Architecture</h2>
<p>大部分具有竞争力的神经序列转换模型都采用了编码器-解码器的结构。在此结构中，编码器将一个符号表示的输入序列 $(x_1, …, x_n)$ 映射到一个连续表示的序列 $z = (z_1, …, z_n)$。给定 $z$，解码器便逐个生成输出序列 $y = (y_1, …, y_n)$ 的符号。在每一步中，模型都是自回归的，即在生成下一个符号时，会利用之前生成的符号作为额外的输入。</p>
<p>Transformer 模型采用了如 图1 所示的结构，其中编码器和解码器部分都采用了堆叠的自注意力机制和逐点的全连接层。</p>
<p><img src="//s3.mindex.xyz/blog/Theses/d64b985edbb3a6d5a521cda18f3ab35f.png" alt="图1：Transformer - 模型架构。"></p>
<h3 id="Encoder-and-Decoder-Stacks">Encoder and Decoder Stacks</h3>
<p><strong>Encoder</strong>: 编码器由 $N = 6$ 个完全相同的层组成。每一层都由两个子层构成：第一个子层是多头自注意力机制，第二个子层是简单的位置相关的全连接前馈网络。我们采用了一种设计，即每个子层的输出都会与其输入进行残差连接，然后进行层归一化处理，即 $LayerNorm(x + Sublayer(x))$，其中 $Sublayer(x)$ 是子层自身的功能。为了实现这种残差连接，模型中所有的子层以及嵌入层都会输出维度为 $d_{model} = 512$ 的结果。</p>
<p><strong>Decoder</strong>: 解码器的构造与编码器类似，也是由 6 个完全相同的层组成。但在每一层中，解码器除了拥有编码器的两个子层外，还增加了第三个子层，这个子层的作用是对编码器所有层的输出进行多头自注意力处理。就像编码器一样，我们在每个子层的输入和输出之间添加了残差连接，并进行层归一化处理。为了防止解码器的自注意力子层处理时，后面的位置能看到前面的信息，我们对其进行了修改。通过这种方式，加上输出嵌入向后偏移一个位置，我们可以确保在预测第 $i$ 个位置的输出时，只能使用位置 $i$ 之前的已知输出。</p>
<h3 id="Attention">Attention</h3>
<p>注意力函数可以理解为，它接收一个查询和一组键值对，然后生成一个输出结果。这个查询、键、值以及输出结果都可以被视为向量。输出结果实际上是值向量的加权和，而每个值的权重则是由查询和相应键的匹配程度决定的。</p>
<p><img src="//s3.mindex.xyz/blog/Theses/77f1cfcd5ed58276e8d605972e6ce520.png" alt="图2：（左图）缩放的点积注意力；（右图）多头注意力，有多个并行运行的注意力层构成"></p>
<h4 id="Scaled-Dot-Product-Attention">Scaled Dot-Product Attention</h4>
<p>我们将这种特定的注意力机制称为“缩放点积注意力”（见 图2）。输入由维度为 $d_k$ 的查询项（queries）和键（keys），以及维度为 $d_v$ 的数值（values）组成。我们首先计算各query与所有keys的点积，然后各自除以 $\sqrt{d_k}$，最后通过 softmax 函数得出各个数值的权重。</p>
<p>在实际应用中，我们会同时对一组查询进行注意力函数的计算，这些查询被整合成一个矩阵 Q。同样，键和值也被整合成矩阵 K 和 V。我们按照以下方式计算得出输出矩阵：<br>
$$<br>
Atteention(Q, K, V) = softmax(\frac{QK^T}{\sqrt{d_k}}) V<br>
$$</p>
<p>最常用的两种注意力机制是加性注意力和点积（乘性）注意力。点积注意力与我们所使用的算法几乎一样，只不过有一个 $\frac{1}{\sqrt{d_k}}$ 的缩放因子。加性注意力则是通过一个单隐藏层的前馈网络来计算相似度函数。虽然这两种方法在理论上的复杂度差不多，但在实际应用中，<strong>点积注意力因为能够利用高度优化的矩阵乘法代码，所以运行速度更快，也更节省存储空间</strong>。</p>
<p>对于较小的 $d_k$ 值，这两种注意力机制的表现类似，但是当 $d_k$ 值增大时，如果不进行缩放处理，加性注意力的表现会优于点积注意力。我们推测，<strong>对于较大的 $d_k$ 值，点积的结果可能会变得非常大，这会使 $softmax$ 函数进入到梯度极小的区域。为了抵消这种影响，我们将点积的结果乘以 $\frac{1}{\sqrt{d_k}}$ 进行缩放</strong>。</p>
<h4 id="Multi-Head-Attention">Multi-Head Attention</h4>
<p>我们发现，直接对 $d_m$ 维的键（keys）、值（values）和查询（queries）进行单一的自注意力（attention）处理不如将它们线性地投影到 $d_k$、$d_k$ 和 $d_v$ 维度更有利。这种线性投影我们会进行 $h$ 次，每次都使用不同的学习到的线性投影。然后，我们在每个投影后的键、值和查询上并行地执行自注意力函数，得到 $d_v$  维的输出值。这些输出值会被连接起来，然后再次投影，得到最终的结果，这个过程在 图2 中有详细的展示。</p>
<p>多头注意力（Multi-head attention）的设计使模型能够在不同的位置，同时关注不同的信息表示子空间。而如果只使用单一的注意力机制，这种能力就会被平均化操作所抑制。</p>
<p>$$<br>
MultiHead(Q, K, V) = Concat(head_1, …, head_h) W^O \\<br>
where \enspace head_i = Attention(QW_{i}^Q, KW_{i}^K, VW_{i}^V)<br>
$$</p>
<p>在这里，所说的投影其实就是参数矩阵。其中 $W_{i}^Q \in \mathbb{R}^{d_{model} \times d_k}$，$W_{i}^K \in \mathbb{R}^{d_{model} \times d_k}$，$W_{i}^V \in \mathbb{R}^{d_{model} \times d_v}$，$W_{i}^O \in \mathbb{R}^{d_{model} \times hd_v}$。</p>
<p>在我们的研究中，我们采用了 $h = 8$ 个并行的注意力层，也就是我们所说的8个&quot;头&quot;。对于这8个&quot;头&quot;，我们都设定了 $d_k = d_v = \frac{d_{model}}{h} = 64$。由于每个&quot;头&quot;的数据规模缩小了，所以总的计算成本与使用全数据规模的单一注意力层差不多。</p>
<h4 id="Applications-of-Attention-in-our-Model">Applications of Attention in our Model</h4>
<p>Transformer 在三种不同的方式中使用了多头注意力：</p>
<ul>
<li>
<p>在“编码器-解码器注意力”层中，查询来自前一个解码器层，而记忆键和值来自编码器的输出。这使得解码器中的每个位置都能关注输入序列中的所有位置。这模仿了序列到序列模型中典型的编码器-解码器注意力机制，如 ‘Google’s neural machine translation system, (2016)’, ‘Neural machine translation by jointly learning to align and translate (2014)’, ‘Convolutional seq2seq learning (2017)’</p>
</li>
<li>
<p>编码器由多个自注意力层组成。在每一个自注意力层里，用于生成注意力分数的键（keys）、值（values）和查询（queries）都源自同一处，即编码器前一层的输出。这样的设计使得编码器当前层的每一个元素都能够接收并处理前一层所有元素的信息。</p>
</li>
<li>
<p>解码器内部的自注意力层同样使得每个位置能够接收到该位置之前所有位置的信息。为了维持解码器的自回归特性，我们必须防止信息从右向左流动。这一目标是通过在缩放点积注意力机制中进行操作实现的：我们会对softmax函数的输入进行遮蔽处理，即将那些不应该被当前位置所接收的信息的权重设置成极小值（负无穷），从而有效地切断了这些不合规则的信息连接。</p>
</li>
</ul>
<h3 id="Position-wise-Feed-Forward-Networks">Position-wise Feed-Forward Networks</h3>
<p>除了自注意力（Self-attention）子层之外，我们的编码器和解码器的每一层还包括一个独立且对每个位置都相同处理的全连接前馈神经网络。这个网络由两个全连接层（linear transformations）构成，在两层之间使用了ReLU激活函数。</p>
<p>$$<br>
FFN(x) = max(0, xW_1 + b_1)W_2 + b_2<br>
$$</p>
<p>尽管不同位置上的线性变换是一致的，但从一层到另一层，它们会使用不同的参数集。换一种方式来说，就像是使用了卷积核尺寸为 $1$ 的两个卷积操作。模型的输入和输出维度 $d_{model} = 512$，而内部层的维度 $d_{ff} = 2048$。</p>
<h3 id="Embeddings-and-Softmax">Embeddings and Softmax</h3>
<p>就像其他的序列转换模型一样，我们利用学习得到的嵌入技术（embeddings）将输入的Token和输出的Token转化为维度为 $d_{model}$ 的向量。我们也采用常规的线性变换学习方法和softmax函数，来把解码器的输出转换成预测下一个Token可能性的概率值。在我们的模型中，我们采用了一个与’Using the output embedding to improve language models (2016)'相似的方法，即在两个嵌入层和softmax之前的线性变换中共享相同的权重矩阵。在嵌入层，我们还会将这些权重与 $\sqrt{d_{model}}$ 相乘。</p>
<h3 id="Positional-Encoding">Positional Encoding</h3>
<p>因为我们的模型既不使用递归结构也不使用卷积操作，为了使模型能够理解序列中Token的顺序信息，我们必须提供关于Token在序列中的相对或绝对位置的信息。为了做到这一点，在编码器和解码器的最底层，我们向输入的嵌入数据中添加了“位置编码”。这些位置编码的维度（$d_{model}$）与嵌入数据的维度相同，使得它们可以直接相加。至于位置编码的选择，既有通过学习得到的，也有固定不变的多种方案。</p>
<p>在这项研究中，我们采用了频率各异的正弦与余弦函数：</p>
<p>$$<br>
PE_{(pos, 2i)} = sin(\frac{pos}{1000^{2i/d_{model}}}) \\<br>
PE_{(pos, 2i+1)} = cos(\frac{pos}{1000^{2i/d_{model}}})<br>
$$</p>
<p>在这个公式中，$pos$ 表示序列中的位置，$i$ 代表维度。 换句话说，位置编码的每个维度都对应域一个正弦波形。这些波形的波长按几何数级递增，范围 从 $2\pi$ 到 $10000 \cdot 2\pi$。我们选择这种函数是基于一个假设：它能够让模型轻松地根据 Token 之间的相对位置进行自注意力学习。因为无论偏移量 k 如何变化，位置编码 $PE_{pos+k}$ 都能够用位置编码 $PE_{pos}$ 的线性组合来表示。这样一来，模型就能够通过简单的数学变换来识别和处理序列中 Token 的位置关系。</p>
<p>我们还试验了采用学习型的位置嵌入（learned positional embeddings）方法，结果显示两种方法得出的成果相差无几（参见 表3 第（E）行）。我们选择了基于正弦波的方法，因为这可能使模型能够处理超出训练时序列长度的数据。</p>
<h2 id="Why-Self-Attention">Why Self-Attention</h2>
<p>在这一部分，我们将自注意力层与循环层和卷积层进行了比较。这些层通常用于处理符号表示的变长序列（$x_1$, …, $x_n$）到另一个等长序列（$z_1$, …, $z_n$）的映射问题，其中 $x_i, z_i \in \mathbb{R}^d$ 空间中的向量，比如这样的映射在典型的序列转换编码器或解码器的隐藏层中非常常见。我们选择使用自注意力的动机是基于三个我们所期望的特性。</p>
<p>在考量每一层的运算效率时，我们首先要评估的是该层的总体计算复杂度。 其次，我们会考察计算任务中可以并行处理的部分，这部分的大小可以通过必须顺序执行的操作次数来衡量。</p>
<p>第三个考量因素是网络内部处理长程数据依赖时信号传递的路径长度。在众多序列转换任务中，学习这种长程依赖关系是一个核心挑战。能否有效学习这种依赖关系，关键在于信号在网络中传递的路径有多长，无论是前向传递还是后向传递。简而言之，输入与输出序列之间任意两点的路径越短，网络学习长程依赖就越容易。因此，我们也对比了由不同类型的层构成的网络中，任意两个输入和输出位置之间的最大路径长度。</p>
<p><img src="//s3.mindex.xyz/blog/Theses/84163f518d756c1a1ca877da25396d5b.png" alt="表1：对于不同类型的层，其最大路径长度、每个层的复杂度以及最小序列操作数量各不相同。这里，n 代表序列的长度，d 代表特征维度，k 是卷积核的大小，而 r 则是自注意力限制区域的大小。"></p>
<p>如 表1 所展示的，自注意力层能够通过一系列固定数量的操作，将所有位置相互连接起来，相比之下，递归层（recurrent layer）则需要 $O(n)$ 次操作。在计算复杂度上，自注意力层在序列长度 $n$ 小于其表示空间的维度 $d$ 的情况下，比递归层更为高效，而这种情况在当前机器翻译中的 SOTA 模型所使用的句子表示，如 <strong>word-piece</strong> 和 <strong>byte-pair</strong> 表示法中非常普遍。为了在处理极长序列的任务时提高计算效率，自注意力可以被限制在仅考虑输入序列中，围绕各自输出位置的大小为 $r$ 的局部邻域内。这种做法会导致最大路径长度变为 $O(n/r)$ 。我们计划在未来的研究中进一步探索这一方法。</p>
<p>在我们的模型中，单层卷积网络由于核宽度 $k$ 小于序列长度 $n$，不能直接将每个输入位置与输出位置完全连接起来。如果使用连续的核，要实现完全连接需要叠加大约 $n/k$ 层卷积网络；而采用膨胀卷积的话，大约需要 $log_k(n)$ 层。这样会使得网络内任意两点间的最长路径长度增加。一般来说，卷积层的计算成本比循环层要高，大概高出 $k$ 倍。不过，采用可分离卷积可以大幅降低计算复杂度，降至 $O(k · n · d + n · d^2)$。即便核宽度 $k$ 等于 n，可分离卷积的计算复杂度也仅相当于自注意力层和点对点前馈网络层相结合的复杂度，这正是我们模型所采用的策略。</p>
<p>另外，自注意力还有一个额外好处，那就是能够促成模型的可解释性更强。我们对模型中的注意力分布进行了详细检查，并在附录中展示并讨论了若干例子。我们发现，不仅单独的注意力头确实学会了执行不同的任务，而且许多注意力头的行为似乎还与句子的句法和语义结构密切相关。</p>
<h2 id="Training">Training</h2>
<p>本节将详细介绍我们的模型训练方案。</p>
<h3 id="Training-Data-and-Batching">Training Data and Batching</h3>
<p>我们使用了包含约450万个句子对的标准 ‘WMT 2014 English-German’ 数据集进行模型训练。这些句子通过字节对编码（byte-pair encoding）方法进行处理，形成了一个大约含有37000个 Token 的共用词汇表，用于源语言和目标语言。在英语-法语的训练中，我们采用了规模更大的 ‘WMT 2014 English-French’ 数据集，它包含了3600万句子，并且使用了包含32000个词片（word-piece）的词汇表来分割 Token。为了提高训练效率，我们按照句子的大致长度将它们分组打包，每个训练批次都包含了一组句子对，这些句子对总共大约包含25000个源语言 Token 和25000个目标语言 Token。</p>
<h3 id="Hardware-and-Schedule">Hardware and Schedule</h3>
<p>我们在一台搭载了8块 NVIDIA P100 GPUs 的计算机上对模型进行了训练。基础模型采用论文中详述的超参数，每个训练步骤耗时约0.4秒。基础模型总共训练了100,000步，持续了12小时。至于我们的大型模型（详见 表3 最后一行），每步训练时间为1.0秒。这些大型模型训练了300,000步，用时3.5天。</p>
<h3 id="Optimizer">Optimizer</h3>
<p>我们选用了 Adam 优化器，并设置参数 $β_1 = 0.9, β_2 = 0.98$ 以及 $ε = 10^{-9}$。在整个训练过程中，我们按照特定的公式调整了学习率</p>
<p>$$<br>
l_{rate} =  d_{model}^{-0.5} \cdot min(step\_num^{-0.5}, step\_num \cdot warmup\_steps^{-1.5})<br>
$$</p>
<p>这意味着在训练的最初阶段（前 4000 步），我们会逐步增加学习速率，之后则根据训练步数增长的平方根逐渐减慢增速。这里的“逐步增加”是指学习速率会按照一个固定的规律线性上升，而“逐渐减慢增速”则是随着步数的增加，增加的幅度会越来越小。</p>
<h3 id="Regularization">Regularization</h3>
<p>在训练过程中，我们使用了三种不同的正则化手段来防止模型过拟合：</p>
<p><strong>Residual Dropout</strong>  在将每个子层的输出与其输入相加并进行规范化处理之前，我们会使用 Dropout 技术。此外，在编解码器的嵌入向量和位置编码相加的部分，我们也采用了 Dropout。对于基础模型，我们设置的 $P_{dropout} = 0.1$。</p>
<p><strong>Label Smoothing</strong> 在训练过程中，我们使用了$ε_{ls} = 0.1$的标签平滑技术。尽管这样做会增加模型的预测困难度（即提高了困惑度），使得模型的预测更加保守，但它实际上提升了模型的准确率和BLEU评分。</p>
<h2 id="Result">Result</h2>
<h3 id="Machine-Translation">Machine Translation</h3>
<p><img src="//s3.mindex.xyz/blog/Theses/3d4e0e9e97745a2a482c9d4068d2cc63.png" alt="表2：在将英语翻译成德语和法语的 newstest2014 测试中，Transformer 模型的表现超越了以往最先进的模型，取得了更高的 BLEU 评分，而且所需的训练成本仅为过去模型的一小部分。"></p>
<p>在WMT 2014的英德翻译任务上，我们的大型Transformer模型（在表2中标记为Transformer (big)）的性能超越了此前所有公布过的最好模型（包括那些集成模型），其BLEU评分高达28.4，刷新了此前的最佳成绩。该模型的具体配置详见 表3 的最后一栏。该模型的训练仅用了8个P100 GPU花费了3.5天。甚至我们的基础版模型也超越了所有先前公布的模型，而且训练成本远低于其他任何有竞争力的模型。</p>
<p><img src="//s3.mindex.xyz/blog/Theses/8cdbbb740de70e749ed7562ec46484d6.png" alt="表3：Transformer 模型的不同版本在英德翻译的开发测试集 newstest2013 上的表现各有差异。未列出的值与基础模型相同。所有的性能指标都是针对这个特定的测试集。我们根据字节对编码（Byte-Pair Encoding, BPE）计算的困惑度是基于pre_wordpiece，因此与通常基于单词计算的困惑度不同，不应直接比较二者。"></p>
<p>在 WMT 2014 的英法翻译任务中，我们的大型 Transformer 模型取得了 41.0 的 BLEU 分数，不仅超过了此前所有公开的单模型记录，而且其训练成本还不足先进模型的四分之一。这个专为英法翻译训练的 Transformer（大型）模型，采用了 $P_{dropout} = 0.1$，相较于常规的 0.3 有所降低。</p>
<p>在基础模型的训练中，我们采用了一个特殊的方法：将最后 5 次保存的模型参数（每 10 分钟保存一次）进行平均，以此得到最终的单一模型。而对于大型模型，我们则平均了最后 20 次的保存点。在模型推理时，我们使用了大小为 4 的 beam search 技术，并设置了序列长度惩罚因子（$α = 0.6$），这些超参数都是在开发数据集上通过多次试验确定的。此外，我们把模型生成文本的最大长度限制在 $输入文本长度 + 50 个词$ 以内，不过如果能够提前得出结论，我们也会尽早结束生成过程。</p>
<p>表2 汇总了我们的研究成果，并把我们的翻译质量和训练成本与文献中报道的其他模型架构做了对比。我们估计了训练一个模型所需要的浮点运算量，这是通过计算训练时间、使用的 GPU 数目以及每个 GPU 的单精度浮点运算能力的平均值来得出的。</p>
<h3 id="Model-Variations">Model Variations</h3>
<p>为了评判 Transformer 各部分的重要性，我们对基础模型进行了多种修改，并在开发集 newstest2013 上测试了这些改动对英译德翻译性能的影响。我们采用了之前章节描述的 Beam Search 策略，但没有进行 checkpoint 的平均处理。相关的结果展示在 表3 中。</p>
<p>在 表3 的行 (A) 中，我们调整了 Transformer 中的注意力机制的头数 (attention heads) 和对应键 (key) 与值 (value) 的维数，正如<a href="#Multi-Head-Attention">Multi-Head Attention</a> 节所详述，同时确保整体的计算量保持不变。虽然仅使用一个头的注意力机制的翻译质量比最优参数配置低了 0.9 BLEU 分，但过多的头数也会导致翻译质量的降低。</p>
<p>在表 3 的行（B）中，我们发现当减少了用于计算注意力的关键参数大小 $d_k$  后，模型的性能有所下降。这暗示了评估模型各部分之间的相互关系并非易事，可能需要一个比简单的点乘运算更为复杂的计算方式来提升效果。进一步地，从行（C）和（D）的数据可以看出，一如所料，模型规模越大，其表现通常越好；而且，使用dropout技术能有效防止模型过度学习特定数据的问题。在行（E）中，我们尝试将模型中用于捕捉不同位置信息的正弦波形位置编码替换成了通过学习得到的位置嵌入，结果显示，新模型的表现与原始模型相差无几。</p>
<h3 id="English-Constituency-Parsing">English Constituency Parsing</h3>
<p>为了探究 Transformer 是否能够适应其他种类的任务，我们对其在英文成分句法分析（一种分析句子结构的任务）上的表现进行了实验。这项任务具有其独特的挑战性：它要求输出结果具有严格的结构性，并且输出的长度通常会显著超过输入的长度。而且，传统的循环神经网络（RNN）基于序列的模型在数据量不大的情况下，还未能达到最先进（SOTA）的水平。</p>
<p>我们在Penn Treebank的大约有4万条WSJ数据集上训练了一个有4层且模型维度 $d_{model} = 1024$ 的 Transformer。同时，我们还尝试了半监督学习的方式，利用了大约 1700 万句的高质量语料库，包括 BerkleyParser 语料库。在 ‘WSJ only’ 训练中，我们使用了 16000 个Token的词汇表；而在半监督学习中我们使用了32000个Token的词汇表。</p>
<p>在开发数据集上，我们只进行了有限的实验来确定 dropout 设置（这包括自注意力和残差连接的设置，详见第 5.4 节）、学习速率和 beam 宽度，所有其他的参数设置都遵循了原先用于英语到德语翻译的基本模型。在模型进行推断时，我们把最大输出长度设定为输入长度加上 300。无论是在只使用WSJ数据集的实验还是在半监督学习的设定中，我们都采用了 21 的 beam 宽度和 0.3 的长度惩罚系数（α）。</p>
<p>如 表4 所示，尽管我们的模型没有进行特定任务的细致调优，但它的表现出乎意料地出色，其结果超过了除了递归神经网络语法（Recurrent Neural Network Grammar，RNN Grammar）以外的所有以往公布过的模型。</p>
<p><img src="//s3.mindex.xyz/blog/Theses/84f649a70e83efb38b0934d80efc1adb.png" alt="表4：Transformer 模型在英文成分句法分析方面表现出了良好的适应性和准确度。"></p>
<p>与基于循环神经网络（RNN）的序列对序列模型不同，Transformer 在只使用包含 4 万句子的华尔街日报（WSJ）训练集进行训练时，其性能甚至超过了 Berkeley-Parser。</p>
<h2 id="Conclusion">Conclusion</h2>
<p>在这篇文章中，我们首次介绍了 Transformer 模型，这是一个创新的序列转录模型，它完全依赖于注意力机制（attention mechanisms），用多头自注意力（multi-headed self-attention）技术替代了传统编解码器结构中常用的循环网络层。</p>
<p>在翻译任务中，Transformer 的训练速度显著快于那些基于循环或卷积层的结构。在 WMT 2014 的英德和英法翻译挑战中，我们的模型都达到了新的行业最高水平（SOTA）。特别是在英德翻译任务中，我们的最佳模型的表现甚至超越了此前所有公开的模型集合。</p>
<p>我们对注意力机制模型的未来发展前景感到非常期待，并打算将其应用于更多领域。我们的计划是将 Transformer 应用到文本以外的其他类型的数据输入和输出，例如图像、音频和视频，并且研究能够有效处理这些大型数据的局部和有限制的注意力机制。此外，我们还致力于研究如何让内容生成变得更加非线性，这也是我们的研究目标之一。</p>
<p>我们用来训练和评估模型的代码可以在 <a target="_blank" rel="noopener" href="https://github.com/tensorflow/tensor2tensor">github</a> 找到。</p>
<h2 id="Source">Source</h2>
<p><a target="_blank" rel="noopener" href="https://arxiv.org/abs/1706.03762">Attention Is All You Need</a></p>
</div><iframe src="/donate/?AliPayQR=null&amp;WeChatQR=http://s3.mindex.xyz/mp/qrcode-s.jpg&amp;GitHub=http://github.com/neo1989&amp;BTCQR=null&amp;BTCKEY=null&amp;PayPal=null" style="overflow-x:hidden; overflow-y:hidden; border:0xp none #fff; min-height:240px; width:100%;" frameborder="0" scrolling="no"></iframe><div><ul class="post-copyright"><li class="post-copyright-author"><strong>Author: </strong>尼欧</li><li class="post-copyright-link"><strong>Blog Link: </strong><a href="/Theses/THESIS-Attention-is-All-You-Need/">https://neo1989.net/Theses/THESIS-Attention-is-All-You-Need/</a></li><li class="post-copyright-license"><strong>Copyright Declaration: </strong>转载请声明出处。</li></ul></div><br><div class="tags"><a href="../../tags/Coder/">Coder</a><a href="../../tags/AI/">AI</a><a href="../../tags/NLP/">NLP</a></div><div class="post-nav"><a class="pre" href="../THESIS-Seven-Failure-Points-When-Engineering-a-RAG-System/">必读论文 · 7 FPs When Engineering a RAG System (2024)</a><a class="next" href="../THESIS-bert/">必读论文 · BERT (2019)</a></div><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://neo1989.net/Theses/THESIS-Attention-is-All-You-Need/';
    this.page.identifier = 'Theses/THESIS-Attention-is-All-You-Need/';
    this.page.title = '必读论文 · Attention Is All You Need (2017)';
  };</script><!-- script(type='text/javascript' id='disqus-lazy-load-script').--><!--   $.ajax({--><!--   url: 'https://disqus.com/next/config.json',--><!--   timeout: 2500,--><!--   type: 'GET',--><!--   success: function(){--><!--     var d = document;--><!--     var s = d.createElement('script');--><!--     s.src = '//#{theme.disqus}.disqus.com/embed.js';--><!--     s.setAttribute('data-timestamp', + new Date());--><!--     (d.head || d.body).appendChild(s);--><!--     $('.disqus_click_btn').css('display', 'none');--><!--   },--><!--   error: function() {--><!--     $('.disqus_click_btn').css('display', 'block');--><!--   }--><!--   });--><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//neo1989.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://neo1989.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });
</script></div></div></div></div></div><div class="pure-u-1 pure-u-md-4-6"><div id="footer">Copyright © 2024 <a href="../../." rel="nofollow">愚苏记.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/i-yard/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho/maupassant"> Cho.</a></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="../../js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="../../lib/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="../../js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="../../lib/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
  displayAlign: "left"
  });
</script><script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="../../js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="../../js/smartresize.js?v=1.0.0"></script><script type="text/javascript" id="maid-script" mermaidoptioins="{&quot;startOnload&quot;:true,&quot;theme&quot;:&quot;forest&quot;}" src="../../js/mermaid.min.js?v=1.0.0"></script><script>if (window.mermaid) {
  var options = JSON.parse(document.getElementById('maid-script').getAttribute('mermaidoptioins'));
  mermaid.initialize(options);
}</script></div><!-- hexo-inject:begin --><!-- hexo-inject:end --></body></html>