<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>愚苏记</title>
  
  <subtitle>To no avail but try.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://neo1989.net/"/>
  <updated>2023-05-17T05:47:29.778Z</updated>
  <id>https://neo1989.net/</id>
  
  <author>
    <name>Neo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Way2AI · NumPy</title>
    <link href="https://neo1989.net/Courses/COURSE-NumPy/"/>
    <id>https://neo1989.net/Courses/COURSE-NumPy/</id>
    <published>2023-05-17T01:47:59.000Z</published>
    <updated>2023-05-17T05:47:29.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TL-DR">TL;DR</h2><p>Way2AI系列，确保出发去&quot;改变世界&quot;之前，我们已经打下了一个坚实的基础。</p><p>本文简单介绍了NumPy这个科学计算扩展包的的必备知识。</p><h2 id="Set-up">Set up</h2><p>首先我们需要导入NumPy包，做实验的时候可以设置随机种子以实现可重复性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set seed for reproducibility</span></span><br><span class="line">np.random.seed(seed=<span class="number">1024</span>)</span><br></pre></td></tr></table></figure><p>接下来分别示例 0D（标量）、1D（向量）、2D（矩阵）、3D（3维张量）。</p><p><img src="//s3.mindex.xyz/blog/Courses/49497eb3ffb5cdd0dc88c6e8e2d08270.png" alt="tensors"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Scalar</span></span><br><span class="line">x = np.array(<span class="number">6</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x: "</span>, x)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x ndim: "</span>, x.ndim) <span class="comment"># number of dimensions</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x shape:"</span>, x.shape) <span class="comment"># dimensions</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x size: "</span>, x.size) <span class="comment"># size of elements</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x dtype: "</span>, x.dtype) <span class="comment"># data type</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># x:  6</span></span><br><span class="line"><span class="comment"># x ndim:  0</span></span><br><span class="line"><span class="comment"># x shape: ()</span></span><br><span class="line"><span class="comment"># x size:  1</span></span><br><span class="line"><span class="comment"># x dtype:  int64 </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Vector</span></span><br><span class="line">x = np.array([<span class="number">1.3</span> , <span class="number">2.2</span> , <span class="number">1.7</span>])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x: "</span>, x)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x ndim: "</span>, x.ndim)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x shape:"</span>, x.shape)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x size: "</span>, x.size)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x dtype: "</span>, x.dtype) <span class="comment"># notice the float datatype</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># x:  [1.3 2.2 1.7]</span></span><br><span class="line"><span class="comment"># x ndim:  1</span></span><br><span class="line"><span class="comment"># x shape: (3,)</span></span><br><span class="line"><span class="comment"># x size:  3</span></span><br><span class="line"><span class="comment"># x dtype:  float64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix</span></span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x:\n"</span>, x)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x ndim: "</span>, x.ndim)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x shape:"</span>, x.shape)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x size: "</span>, x.size)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x dtype: "</span>, x.dtype)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># x:</span></span><br><span class="line"><span class="comment">#  [[1 2]</span></span><br><span class="line"><span class="comment">#  [3 4]]</span></span><br><span class="line"><span class="comment"># x ndim:  2</span></span><br><span class="line"><span class="comment"># x shape: (2, 2)</span></span><br><span class="line"><span class="comment"># x size:  4</span></span><br><span class="line"><span class="comment"># x dtype:  int64</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3D Tensor</span></span><br><span class="line">x = np.array([[[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], [[<span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>]]])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x:\n"</span>, x)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x ndim: "</span>, x.ndim)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x shape:"</span>, x.shape)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x size: "</span>, x.size)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x dtype: "</span>, x.dtype)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># x:</span></span><br><span class="line"><span class="comment">#  [[[1 2]</span></span><br><span class="line"><span class="comment">#   [3 4]]</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#  [[5 6]</span></span><br><span class="line"><span class="comment">#   [7 8]]]</span></span><br><span class="line"><span class="comment"># x ndim:  3</span></span><br><span class="line"><span class="comment"># x shape: (2, 2, 2)</span></span><br><span class="line"><span class="comment"># x size:  8</span></span><br><span class="line"><span class="comment"># x dtype:  int64</span></span><br></pre></td></tr></table></figure><p>NumPy当然也提供了几个函数，可以快速创建张量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Functions</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"np.zeros((2, 2)):\n"</span>, np.zeros((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"np.ones((2, 2)):\n"</span>, np.ones((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"np.eye((2)):\n"</span>, np.eye((<span class="number">2</span>))) <span class="comment"># identity matrix</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"np.random.random((2, 2)):\n"</span>, np.random.random((<span class="number">2</span>, <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># np.zeros((2, 2)):</span></span><br><span class="line"><span class="comment">#  [[0. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 0.]]</span></span><br><span class="line"><span class="comment"># np.ones((2, 2)):</span></span><br><span class="line"><span class="comment">#  [[1. 1.]</span></span><br><span class="line"><span class="comment">#  [1. 1.]]</span></span><br><span class="line"><span class="comment"># np.eye((2)):</span></span><br><span class="line"><span class="comment">#  [[1. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 1.]]</span></span><br><span class="line"><span class="comment"># np.random.random((2, 2)):</span></span><br><span class="line"><span class="comment">#  [[0.64769123 0.99691358]</span></span><br><span class="line"><span class="comment">#  [0.51880326 0.65811273]]</span></span><br></pre></td></tr></table></figure><h2 id="Indexing">Indexing</h2><p>我们可以使用索引从张量中提取指定的值。<br>请记住，索引从0开始。与使用列表进行索引一样，我们也可以使用负数索引（其中-1是最后一个项目）。</p><p><img src="//s3.mindex.xyz/blog/Courses/f6ba5bef483ad3756ddb81f1d9a05576.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Indexing</span></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x: "</span>, x)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x[0]: "</span>, x[<span class="number">0</span>])</span><br><span class="line">x[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x: "</span>, x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># x:  [1 2 3]</span></span><br><span class="line"><span class="comment"># x[0]:  1</span></span><br><span class="line"><span class="comment"># x:  [0 2 3]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Slicing</span></span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="keyword">print</span> (x)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x column 1: "</span>, x[:, <span class="number">1</span>])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x row 0: "</span>, x[<span class="number">0</span>, :])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x rows 0,1 &amp; cols 1,2: \n"</span>, x[<span class="number">0</span>:<span class="number">2</span>, <span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line"><span class="comment"># x column 1:  [ 2  6 10]</span></span><br><span class="line"><span class="comment"># x row 0:  [1 2 3 4]</span></span><br><span class="line"><span class="comment"># x rows 0,1 &amp; cols 1,2: </span></span><br><span class="line"><span class="comment">#  [[2 3]</span></span><br><span class="line"><span class="comment">#  [6 7]]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Integer array indexing</span></span><br><span class="line"><span class="keyword">print</span> (x)</span><br><span class="line">rows_to_get = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"rows_to_get: "</span>, rows_to_get)</span><br><span class="line">cols_to_get = np.array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"cols_to_get: "</span>, cols_to_get)</span><br><span class="line"><span class="comment"># Combine sequences above to get values to get</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"indexed values: "</span>, x[rows_to_get, cols_to_get]) <span class="comment"># (0, 0), (1, 2), (2, 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [[ 1  2  3  4]</span></span><br><span class="line"><span class="comment">#  [ 5  6  7  8]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11 12]]</span></span><br><span class="line"><span class="comment"># rows_to_get:  [0 1 2]</span></span><br><span class="line"><span class="comment"># cols_to_get:  [0 2 1]</span></span><br><span class="line"><span class="comment"># indexed values:  [ 1  7 10]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Boolean array indexing</span></span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x:\n"</span>, x)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x &gt; 2:\n"</span>, x &gt; <span class="number">2</span>)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x[x &gt; 2]:\n"</span>, x[x &gt; <span class="number">2</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># x:</span></span><br><span class="line"><span class="comment">#  [[1 2]</span></span><br><span class="line"><span class="comment">#  [3 4]</span></span><br><span class="line"><span class="comment">#  [5 6]]</span></span><br><span class="line"><span class="comment"># x &gt; 2:</span></span><br><span class="line"><span class="comment">#  [[False False]</span></span><br><span class="line"><span class="comment">#  [ True  True]</span></span><br><span class="line"><span class="comment">#  [ True  True]]</span></span><br><span class="line"><span class="comment"># x[x &gt; 2]:</span></span><br><span class="line"><span class="comment">#  [3 4 5 6]</span></span><br></pre></td></tr></table></figure><h2 id="Arithmetic-运算">Arithmetic 运算</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Basic math</span></span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]], dtype=np.float64)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x + y:\n"</span>, np.add(x, y)) <span class="comment"># or x + y</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x - y:\n"</span>, np.subtract(x, y)) <span class="comment"># or x - y</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x * y:\n"</span>, np.multiply(x, y)) <span class="comment"># or x * y</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># x + y:</span></span><br><span class="line"><span class="comment">#  [[2. 4.]</span></span><br><span class="line"><span class="comment">#  [6. 8.]]</span></span><br><span class="line"><span class="comment"># x - y:</span></span><br><span class="line"><span class="comment">#  [[0. 0.]</span></span><br><span class="line"><span class="comment">#  [0. 0.]]</span></span><br><span class="line"><span class="comment"># x * y:</span></span><br><span class="line"><span class="comment">#  [[ 1.  4.]</span></span><br><span class="line"><span class="comment">#  [ 9. 16.]]</span></span><br></pre></td></tr></table></figure><h2 id="Dot-product-点积">Dot product 点积</h2><p>在机器学习中，我们最常使用的NumPy操作之一是使用点积进行矩阵乘法。<br>假设我们需要取一个2x3的矩阵a和一个3x2的矩阵b的点积，我们将得到矩阵a的和行数及矩阵b的列数作为点积的输出，也就是得到一个2x2的矩阵。点积能够正确运行需要满足的条件便是内部维度匹配，即示例中，矩阵a有3列，矩阵b有3行。</p><p><img src="//s3.mindex.xyz/blog/Courses/e11a898f34e386460b7dbb42d1cff842.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dot product</span></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], dtype=np.float64) <span class="comment"># we can specify dtype</span></span><br><span class="line">b = np.array([[<span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>,<span class="number">10</span>], [<span class="number">11</span>, <span class="number">12</span>]], dtype=np.float64)</span><br><span class="line">c = a.dot(b)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">f"<span class="subst">&#123;a.shape&#125;</span> · <span class="subst">&#123;b.shape&#125;</span> = <span class="subst">&#123;c.shape&#125;</span>"</span>)</span><br><span class="line"><span class="keyword">print</span> (c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># (2, 3) · (3, 2) = (2, 2)</span></span><br><span class="line"><span class="comment"># [[ 58.  64.]</span></span><br><span class="line"><span class="comment">#  [139. 154.]]</span></span><br></pre></td></tr></table></figure><h1>Axis operations</h1><p>我们还可以沿着特定的轴进行操作。</p><p><img src="//s3.mindex.xyz/blog/Courses/a80be7714f670936b98bb5769037e313.gif" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sum across a dimension</span></span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>]])</span><br><span class="line"><span class="keyword">print</span> (x)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"sum all: "</span>, np.sum(x)) <span class="comment"># adds all elements</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"sum axis=0: "</span>, np.sum(x, axis=<span class="number">0</span>)) <span class="comment"># sum across rows</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"sum axis=1: "</span>, np.sum(x, axis=<span class="number">1</span>)) <span class="comment"># sum across columns</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [[1 2]</span></span><br><span class="line"><span class="comment">#  [3 4]]</span></span><br><span class="line"><span class="comment"># sum all:  10</span></span><br><span class="line"><span class="comment"># sum axis=0:  [4 6]</span></span><br><span class="line"><span class="comment"># sum axis=1:  [3 7]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Min/max</span></span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"min: "</span>, x.min())</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"max: "</span>, x.max())</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"min axis=0: "</span>, x.min(axis=<span class="number">0</span>))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"min axis=1: "</span>, x.min(axis=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># min:  1</span></span><br><span class="line"><span class="comment"># max:  6</span></span><br><span class="line"><span class="comment"># min axis=0:  [1 2 3]</span></span><br><span class="line"><span class="comment"># min axis=1:  [1 4]</span></span><br></pre></td></tr></table></figure><h2 id="Broadcast">Broadcast</h2><p>当我们尝试使用看似不兼容的张量形状进行操作时会发生什么？<br>它们的维度不兼容，但是NumPy为何仍然给出了结果？这就是广播的作用。</p><p><img src="//s3.mindex.xyz/blog/Courses/db0288a489a3c03ebdea1be427f1d963.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Broadcasting</span></span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>]) <span class="comment"># vector</span></span><br><span class="line">y = np.array(<span class="number">3</span>) <span class="comment"># scalar</span></span><br><span class="line">z = x + y</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"z:\n"</span>, z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># z:</span></span><br><span class="line"><span class="comment">#  [4 5]</span></span><br></pre></td></tr></table></figure><h2 id="Gotchas">Gotchas</h2><p>在下面的情况中，c的值是多少，它的形状是什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = np.array((<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>))</span><br><span class="line">b = np.expand_dims(a, axis=<span class="number">1</span>)</span><br><span class="line">c = a + b</span><br><span class="line"></span><br><span class="line">a.shape <span class="comment"># (3,)</span></span><br><span class="line">b.shape <span class="comment"># (3, 1)</span></span><br><span class="line">c.shape <span class="comment"># (3, 3)</span></span><br><span class="line"><span class="keyword">print</span> (c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># array([[ 6,  7,  8],</span></span><br><span class="line"><span class="comment">#         [ 7,  8,  9],</span></span><br><span class="line"><span class="comment">#         [ 8,  9, 10]])</span></span><br></pre></td></tr></table></figure><p>如果我们不想出现意外的广播行为，就需要小心确保 矩阵a 和 矩阵b 的形状相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = a.reshape(<span class="number">-1</span>, <span class="number">1</span>)</span><br><span class="line">a.shape <span class="comment"># (3, 1)</span></span><br><span class="line">c = a + b</span><br><span class="line">c.shape <span class="comment"># (3, 1)</span></span><br><span class="line"><span class="keyword">print</span> (c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [[ 6]</span></span><br><span class="line"><span class="comment">#  [ 8]</span></span><br><span class="line"><span class="comment">#  [10]]</span></span><br></pre></td></tr></table></figure><h2 id="Transpose-转置">Transpose 转置</h2><p>我们经常需要改变张量的维度，以进行诸如点积之类的操作。如果我们需要交换两个维度，可以对张量进行转置。</p><p><img src="//s3.mindex.xyz/blog/Courses/9fe94457fbf3d53aca519eb20ebf487f.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Transposing</span></span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x:\n"</span>, x)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x.shape: "</span>, x.shape)</span><br><span class="line">y = np.transpose(x, (<span class="number">1</span>, <span class="number">0</span>)) <span class="comment"># flip dimensions at index 0 and 1</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"y:\n"</span>, y)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"y.shape: "</span>, y.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># x:</span></span><br><span class="line"><span class="comment">#  [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br><span class="line"><span class="comment"># x.shape:  (2, 3)</span></span><br><span class="line"><span class="comment"># y:</span></span><br><span class="line"><span class="comment">#  [[1 4]</span></span><br><span class="line"><span class="comment">#  [2 5]</span></span><br><span class="line"><span class="comment">#  [3 6]]</span></span><br><span class="line"><span class="comment"># y.shape:  (3, 2)</span></span><br></pre></td></tr></table></figure><h2 id="Reshape">Reshape</h2><p>reshape是另一种改变张量形状的办法。<br>如下面所示，我们reshape后的张量与原始张量具有相同数量的值。我们还可以在一个维度上使用<code>-1</code>，NumPy会根据输入张量自动推断该维度的大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Reshaping</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="keyword">print</span> (x)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x.shape: "</span>, x.shape)</span><br><span class="line">y = np.reshape(x, (<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"y: \n"</span>, y)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"y.shape: "</span>, y.shape)</span><br><span class="line">z = np.reshape(x, (<span class="number">2</span>, <span class="number">-1</span>))</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"z: \n"</span>, z)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"z.shape: "</span>, z.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [[1 2 3 4 5 6]]</span></span><br><span class="line"><span class="comment"># x.shape:  (1, 6)</span></span><br><span class="line"><span class="comment"># y:</span></span><br><span class="line"><span class="comment">#  [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br><span class="line"><span class="comment"># y.shape:  (2, 3)</span></span><br><span class="line"><span class="comment"># z:</span></span><br><span class="line"><span class="comment">#  [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br><span class="line"><span class="comment"># z.shape:  (2, 3)</span></span><br></pre></td></tr></table></figure><p>reshape函数的工作原理是查看新张量的每个维度，并将原始张量分成相应数量的单元。因此，在这里，新张量<code>index 0</code>处的维度为2，因此我们将原始张量分成2个单元，每个单元都有3个值。</p><p><img src="//s3.mindex.xyz/blog/Courses/1aaa08d5c71d13009b4e969815e1e8a8.png" alt=""></p><h2 id="Joining">Joining</h2><p>我们还可以使用concatenate和stack来合并张量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">x = np.random.random((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="keyword">print</span> (x)</span><br><span class="line"><span class="keyword">print</span> (x.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [[0.14950888 0.698439   0.59335256]</span></span><br><span class="line"><span class="comment">#  [0.89991535 0.44445739 0.316785  ]]</span></span><br><span class="line"><span class="comment"># (2, 3)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Concatenation</span></span><br><span class="line">y = np.concatenate([x, x], axis=<span class="number">0</span>) <span class="comment"># concat on a specified axis</span></span><br><span class="line"><span class="keyword">print</span> (y)</span><br><span class="line"><span class="keyword">print</span> (y.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [[0.14950888 0.698439   0.59335256]</span></span><br><span class="line"><span class="comment">#  [0.89991535 0.44445739 0.316785  ]</span></span><br><span class="line"><span class="comment">#  [0.14950888 0.698439   0.59335256]</span></span><br><span class="line"><span class="comment">#  [0.89991535 0.44445739 0.316785  ]]</span></span><br><span class="line"><span class="comment"># (4, 3)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Stacking</span></span><br><span class="line">z = np.stack([x, x], axis=<span class="number">0</span>) <span class="comment"># stack on new axis</span></span><br><span class="line"><span class="keyword">print</span> (z)</span><br><span class="line"><span class="keyword">print</span> (z.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [[[0.14950888 0.698439   0.59335256]</span></span><br><span class="line"><span class="comment">#   [0.89991535 0.44445739 0.316785  ]]</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#  [[0.14950888 0.698439   0.59335256]</span></span><br><span class="line"><span class="comment">#   [0.89991535 0.44445739 0.316785  ]]]</span></span><br><span class="line"><span class="comment"># (2, 2, 3)</span></span><br></pre></td></tr></table></figure><h2 id="Expanding-reducing">Expanding / reducing</h2><p>我们还可以轻松地向张量中添加和删除维度，这样做是为了使张量能够兼容某些操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Adding dimensions</span></span><br><span class="line">x = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x:\n"</span>, x)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x.shape: "</span>, x.shape)</span><br><span class="line">y = np.expand_dims(x, <span class="number">1</span>) <span class="comment"># expand dim 1</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"y: \n"</span>, y)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"y.shape: "</span>, y.shape)   <span class="comment"># notice extra set of brackets are added</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># x:</span></span><br><span class="line"><span class="comment">#  [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br><span class="line"><span class="comment"># x.shape:  (2, 3)</span></span><br><span class="line"><span class="comment"># y:</span></span><br><span class="line"><span class="comment">#  [[[1 2 3]]</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#  [[4 5 6]]]</span></span><br><span class="line"><span class="comment"># y.shape:  (2, 1, 3)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Removing dimensions</span></span><br><span class="line">x = np.array([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]], [[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x:\n"</span>, x)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x.shape: "</span>, x.shape)</span><br><span class="line">y = np.squeeze(x, <span class="number">1</span>) <span class="comment"># squeeze dim 1</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"y: \n"</span>, y)</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"y.shape: "</span>, y.shape)  <span class="comment"># notice extra set of brackets are gone</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># x:</span></span><br><span class="line"><span class="comment">#  [[[1 2 3]]</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#  [[4 5 6]]]</span></span><br><span class="line"><span class="comment"># x.shape:  (2, 1, 3)</span></span><br><span class="line"><span class="comment"># y:</span></span><br><span class="line"><span class="comment">#  [[1 2 3]</span></span><br><span class="line"><span class="comment">#  [4 5 6]]</span></span><br><span class="line"><span class="comment"># y.shape:  (2, 3)</span></span><br></pre></td></tr></table></figure><h2 id="Citation">Citation</h2><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">@article</span><span class="template-variable">&#123;madewithml,</span></span><br><span class="line"><span class="template-variable">    author       = &#123;Goku Mohandas&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">    title        = </span><span class="template-variable">&#123; NumPy - Made With ML &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">    howpublished = </span><span class="template-variable">&#123;\url&#123;https://madewithml.com/&#125;</span><span class="xml">&#125;,</span></span><br><span class="line"><span class="xml">    year         = </span><span class="template-variable">&#123;2022&#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Ending">Ending</h2><p>到这里，便拥有了Way2AI路上需要的NumPy的必备知识。</p><p>但我们不应该止步于此。<a href="https://numpy.org/" target="_blank" rel="noopener" title="NumPy">NumPy官网</a> 上有关于NumPy的全部知识。</p>]]></content>
    
    <summary type="html">
    
      Numerical analysis with the NumPy computing package.
    
    </summary>
    
    
      <category term="Courses" scheme="https://neo1989.net/categories/Courses/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
      <category term="AI" scheme="https://neo1989.net/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>Way2AI · Python</title>
    <link href="https://neo1989.net/Courses/COURSE-python/"/>
    <id>https://neo1989.net/Courses/COURSE-python/</id>
    <published>2023-05-16T10:36:00.000Z</published>
    <updated>2023-05-17T05:39:21.920Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TL-DR">TL;DR</h2><p>Way2AI系列，确保出发去&quot;改变世界&quot;之前，我们已经打下了一个坚实的基础。</p><p>本文简单介绍了Python这门语言的必备知识。</p><h2 id="Variables">Variables</h2><p>变量是用于存储数据的容器，它们由名称和值定义。<br>在我们的示例中，我们使用变量名x，但是当您处理特定任务时，请确保在创建变量（函数、类等）时指定<strong>明确含义的名称</strong>（例如first_name），以确保程序的可读性。</p><p><img src="//s3.mindex.xyz/blog/Courses/c249bf303d806ffea1f144af762cd99c.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># integer variable</span></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line"><span class="keyword">print</span> (x)</span><br><span class="line"><span class="keyword">print</span> (type(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 5 </span></span><br><span class="line"><span class="comment"># &lt;class 'int'&gt;</span></span><br></pre></td></tr></table></figure><p>我们可以通过将新值赋给变量来改变它的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sring variable</span></span><br><span class="line">x = <span class="string">"hello"</span></span><br><span class="line"><span class="keyword">print</span> (x, type(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># hello &lt;class 'str'&gt;</span></span><br></pre></td></tr></table></figure><p>python有许多不同类型的变量：integers, floats, strings, boolean 等等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># int variable</span></span><br><span class="line">x = <span class="number">5</span></span><br><span class="line"><span class="keyword">print</span> (x, type(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 5 &lt;class 'int'&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># float variable</span></span><br><span class="line">x = <span class="number">5.0</span></span><br><span class="line"><span class="keyword">print</span> (x, type(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 5.0 &lt;class 'float'&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># string variable</span></span><br><span class="line">x = <span class="string">"5"</span></span><br><span class="line"><span class="keyword">print</span> (x, type(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 5 &lt;class 'str'&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># boolean variable</span></span><br><span class="line">x = <span class="literal">True</span></span><br><span class="line"><span class="keyword">print</span> (x, type(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># True &lt;class 'bool'&gt;</span></span><br></pre></td></tr></table></figure><p>我们也可以使用变量进行运算操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Variables can be used with each other</span></span><br><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = a + b</span><br><span class="line"><span class="keyword">print</span> (c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>我们应该始终知道我们正在处理哪种类型的变量，以便可以正确地对它们进行操作。</p><h2 id="Lists">Lists</h2><p>列表是一个有序的、可变的值集合，由方括号包围并用逗号分隔。一个列表可以包含许多不同类型的变量。下面是一个包含整数、字符串和浮点数的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Creating a list</span></span><br><span class="line">x = [<span class="number">3</span>, <span class="string">"hello"</span>, <span class="number">1.2</span>]</span><br><span class="line"><span class="keyword">print</span> (x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [3, 'hello', 1.2]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Length of a list</span></span><br><span class="line">len(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>使用append方法向列表里添加元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Adding to a list</span></span><br><span class="line">x.append(<span class="number">7</span>)</span><br><span class="line"><span class="keyword">print</span> (x, len(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [3, 'hello', 1.2, 7] 4</span></span><br></pre></td></tr></table></figure><p>通过indexing修改已存在的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Replacing items in a list</span></span><br><span class="line">x[<span class="number">1</span>] = <span class="string">"bye"</span></span><br><span class="line"><span class="keyword">print</span> (x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [3, 'bye', 1.2, 7]</span></span><br></pre></td></tr></table></figure><p>列表也可以进行操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Operations</span></span><br><span class="line">y = [<span class="number">2.4</span>, <span class="string">"world"</span>]</span><br><span class="line">z = x + y</span><br><span class="line"><span class="keyword">print</span> (z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [3, 'bye', 1.2, 7, 2.4, 'world']</span></span><br></pre></td></tr></table></figure><h2 id="Tuples">Tuples</h2><p>元组是有序且不可变（无法更改）的集合。我们将使用元组来存储永远不会更改的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Creating a tuple</span></span><br><span class="line">x = (<span class="number">3.0</span>, <span class="string">"hello"</span>) <span class="comment"># tuples start and end with ()</span></span><br><span class="line"><span class="keyword">print</span> (x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># (3.0, 'hello')</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Adding values to a tuple</span></span><br><span class="line">x = x + (<span class="number">5.6</span>, <span class="number">4</span>)</span><br><span class="line"><span class="keyword">print</span> (x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># (3.0, 'hello', 5.6, 4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Try to change (it won't work and we get an error)</span></span><br><span class="line">x[<span class="number">0</span>] = <span class="number">1.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># TypeError: 'tuple' object does not support item assignment</span></span><br></pre></td></tr></table></figure><h2 id="Sets">Sets</h2><p>集合是无序且可变的。而且，集合中的每个元素必须是唯一的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sets</span></span><br><span class="line">text = <span class="string">"Learn ML with Made With ML"</span></span><br><span class="line"><span class="keyword">print</span> (set(text))</span><br><span class="line"><span class="keyword">print</span> (set(text.split(<span class="string">" "</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># &#123;'e', 'M', ' ', "r", "w", 'd', 'a', 'h', 't', 'i', 'L', 'n', "w"&#125;</span></span><br><span class="line"><span class="comment"># &#123;'with', 'Learn', 'ML', 'Made', 'With'&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Indexing">Indexing</h2><p>从列表中进行索引和切片可以让我们检索到特定的值。请注意，索引可以是正数（从0开始）或负数（-1及以下，其中-1是列表中的最后一项）。</p><p><img src="//s3.mindex.xyz/blog/Courses/72e91f603cb74286d4147011b61e07f4.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Indexing</span></span><br><span class="line">x = [<span class="number">3</span>, <span class="string">"hello"</span>, <span class="number">1.2</span>]</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x[0]: "</span>, x[<span class="number">0</span>])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x[1]: "</span>, x[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x[-1]: "</span>, x[<span class="number">-1</span>]) <span class="comment"># the last item</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x[-2]: "</span>, x[<span class="number">-2</span>]) <span class="comment"># the second to last item</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># x[0]:  3</span></span><br><span class="line"><span class="comment"># x[1]:  hello</span></span><br><span class="line"><span class="comment"># x[-1]:  1.2</span></span><br><span class="line"><span class="comment"># x[-2]:  hello</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Slicing</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x[:]: "</span>, x[:]) <span class="comment"># all indices</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x[1:]: "</span>, x[<span class="number">1</span>:]) <span class="comment"># index 1 to the end of the list</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x[1:2]: "</span>, x[<span class="number">1</span>:<span class="number">2</span>]) <span class="comment"># index 1 to index 2 (not including index 2)</span></span><br><span class="line"><span class="keyword">print</span> (<span class="string">"x[:-1]: "</span>, x[:<span class="number">-1</span>]) <span class="comment"># index 0 to last index (not including last index)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># x[:]:  [3, 'hello', 1.2</span></span><br><span class="line"><span class="comment"># x[1:]:  ['hello', 1.2]</span></span><br><span class="line"><span class="comment"># x[1:2]:  ['hello']</span></span><br><span class="line"><span class="comment"># x[:-1]:  [3, 'hello']</span></span><br></pre></td></tr></table></figure><h2 id="Dictionaries">Dictionaries</h2><p>字典是一种无序的可变键值对集合。您可以根据键检索值，而且一个字典不能有两个相同的键。</p><p><img src="//s3.mindex.xyz/blog/Courses/fb3ab2534970cdff498d3914ed172716.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Creating a dictionary</span></span><br><span class="line">person = &#123;<span class="string">"name"</span>: <span class="string">"Goku"</span>,</span><br><span class="line">          <span class="string">"eye_color"</span>: <span class="string">"brown"</span>&#125;</span><br><span class="line"><span class="keyword">print</span> (person)</span><br><span class="line"><span class="keyword">print</span> (person[<span class="string">"name"</span>])</span><br><span class="line"><span class="keyword">print</span> (person[<span class="string">"eye_color"</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># &#123;"name": "Goku", "eye_color": "brown"&#125;</span></span><br><span class="line"><span class="comment"># Goku</span></span><br><span class="line"><span class="comment"># brown</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Adding new key-value pairs</span></span><br><span class="line">person[<span class="string">"age"</span>] = <span class="number">24</span></span><br><span class="line"><span class="keyword">print</span> (person)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># &#123;"name": "Goku", "eye_color": "green", "age": 24&#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Length of a dictionary</span></span><br><span class="line"><span class="keyword">print</span> (len(person))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure><p>当然，使用Python几乎可以实现任何事情。例如，尽管原生字典是无序的，但我们可以利用OrderedDict数据结构来改变它（如果我们想按特定顺序迭代键等，则非常有用）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"><span class="comment"># Native dict</span></span><br><span class="line">d = &#123;&#125;</span><br><span class="line">d[<span class="string">"a"</span>] = <span class="number">2</span></span><br><span class="line">d[<span class="string">"c"</span>] = <span class="number">3</span></span><br><span class="line">d[<span class="string">"b"</span>] = <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> (d)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># &#123;'a': 2, 'c': 3, 'b': 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Python3.7以后，原生的字典是是按插入的顺序排序的。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Dictionary items</span></span><br><span class="line"><span class="keyword">print</span> (d.items())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># dict_items([('a', 2), ('c', 3), ('b', 1)])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Order by keys</span></span><br><span class="line"><span class="keyword">print</span> (OrderedDict(sorted(d.items())))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># OrderedDict([('a', 2), ('b', 1), ('c', 3)])</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Order by values</span></span><br><span class="line"><span class="keyword">print</span> (OrderedDict(sorted(d.items(), key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># OrderedDict([('b', 1), ('a', 2), ('c', 3)])</span></span><br></pre></td></tr></table></figure><h2 id="If-statements">If statements</h2><p>我们可以使用if语句来有条件地执行某些操作。条件由if、elif（代表else if）和else这几个关键字定义。我们可以拥有任意多个elif语句。每个条件下面缩进的代码是在该条件为True时将要执行的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># If statement</span></span><br><span class="line">x = <span class="number">4</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">1</span>:</span><br><span class="line">    score = <span class="string">"low"</span></span><br><span class="line"><span class="keyword">elif</span> x &lt;= <span class="number">4</span>: <span class="comment"># elif = else if</span></span><br><span class="line">    score = <span class="string">"medium"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    score = <span class="string">"high"</span></span><br><span class="line"><span class="keyword">print</span> (score)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># medium</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># If statement with a boolean</span></span><br><span class="line">x = <span class="literal">True</span></span><br><span class="line"><span class="keyword">if</span> x:</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">"it worked"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># it worked</span></span><br></pre></td></tr></table></figure><h2 id="Loops">Loops</h2><h3 id="For-loops">For loops</h3><p>for循环可以迭代值的集合（列表、元组、字典等）。缩进的代码对于集合中的每个项目都会执行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For loop</span></span><br><span class="line">veggies = [<span class="string">"carrots"</span>, <span class="string">"broccoli"</span>, <span class="string">"beans"</span>]</span><br><span class="line"><span class="keyword">for</span> veggie <span class="keyword">in</span> veggies:</span><br><span class="line">    <span class="keyword">print</span> (veggie)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># carrots</span></span><br><span class="line"><span class="comment"># broccoli</span></span><br><span class="line"><span class="comment"># beans</span></span><br></pre></td></tr></table></figure><p>当循环遇到break命令时，循环将立即终止。如果列表中还有更多的项，则它们不会被处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `break` from a for loop</span></span><br><span class="line">veggies = [<span class="string">"carrots"</span>, <span class="string">"broccoli"</span>, <span class="string">"beans"</span>]</span><br><span class="line"><span class="keyword">for</span> veggie <span class="keyword">in</span> veggies:</span><br><span class="line">    <span class="keyword">if</span> veggie == <span class="string">"broccoli"</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">print</span> (veggie)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># carrots</span></span><br></pre></td></tr></table></figure><p>当循环遇到 continue 命令时，该循环将仅跳过列表中当前项的所有其他操作。如果列表中还有更多项，则循环将正常继续。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># `continue` to the next iteration</span></span><br><span class="line">veggies = [<span class="string">"carrots"</span>, <span class="string">"broccoli"</span>, <span class="string">"beans"</span>]</span><br><span class="line"><span class="keyword">for</span> veggie <span class="keyword">in</span> veggies:</span><br><span class="line">    <span class="keyword">if</span> veggie == <span class="string">"broccoli"</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">print</span> (veggie)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># carrots</span></span><br><span class="line"><span class="comment"># beans</span></span><br></pre></td></tr></table></figure><h3 id="While-Loops">While Loops</h3><p>当条件为真时，while循环可以重复执行。我们也可以在while循环中使用continue和break命令。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># While loop</span></span><br><span class="line">x = <span class="number">3</span></span><br><span class="line"><span class="keyword">while</span> x &gt; <span class="number">0</span>:</span><br><span class="line">    x -= <span class="number">1</span> <span class="comment"># same as x = x - 1</span></span><br><span class="line">    <span class="keyword">print</span> (x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 0</span></span><br></pre></td></tr></table></figure><h2 id="List-comprehension">List comprehension</h2><p>我们可以结合列表和for循环的知识，利用<code>列表推导式</code>来创建简洁的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># For loop</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">y = []</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> x:</span><br><span class="line">    <span class="keyword">if</span> item &gt; <span class="number">2</span>:</span><br><span class="line">        y.append(item)</span><br><span class="line"><span class="keyword">print</span> (y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [3, 4, 5]</span></span><br></pre></td></tr></table></figure><p><img src="//s3.mindex.xyz/blog/Courses/b4995feadf0e5ccf8642f301ede28c44.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># List comprehension</span></span><br><span class="line">y = [item <span class="keyword">for</span> item <span class="keyword">in</span> x <span class="keyword">if</span> item &gt; <span class="number">2</span>]</span><br><span class="line"><span class="keyword">print</span> (y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [3, 4, 5]</span></span><br></pre></td></tr></table></figure><p>下面示例一个复杂的列表推导式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Nested for loops</span></span><br><span class="line">words = [[<span class="string">"Am"</span>, <span class="string">"ate"</span>, <span class="string">"ATOM"</span>, <span class="string">"apple"</span>], [<span class="string">"bE"</span>, <span class="string">"boy"</span>, <span class="string">"ball"</span>, <span class="string">"bloom"</span>]]</span><br><span class="line">small_words = []</span><br><span class="line"><span class="keyword">for</span> letter_list <span class="keyword">in</span> words:</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> letter_list:</span><br><span class="line">        <span class="keyword">if</span> len(word) &lt; <span class="number">3</span>:</span><br><span class="line">            small_words.append(word.lower())</span><br><span class="line"><span class="keyword">print</span> (small_words)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># ['am', 'be']</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Nested list comprehension</span></span><br><span class="line">small_words = [word.lower() <span class="keyword">for</span> letter_list <span class="keyword">in</span> words <span class="keyword">for</span> word <span class="keyword">in</span> letter_list <span class="keyword">if</span> len(word) &lt; <span class="number">3</span>]</span><br><span class="line"><span class="keyword">print</span> (small_words)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># ['am', 'be']</span></span><br></pre></td></tr></table></figure><h2 id="Functions">Functions</h2><p>函数是一种将可重用代码模块化的方式。它们由关键字def定义，代表definition，可以包含以下组件。<br><img src="//s3.mindex.xyz/blog/Courses/3898be6c32f04d864a2586e873e4926c.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define the function</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_two</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""Increase x by 2."""</span></span><br><span class="line">    x += <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>以下是使用该函数时可能需要的组件。我们需要确保函数名称和输入参数与上面定义的函数匹配。<br><img src="//s3.mindex.xyz/blog/Courses/9ca41d3f8448ba4c422a4ae26b76deee.png" alt=""></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Use the function</span></span><br><span class="line">score = <span class="number">0</span></span><br><span class="line">new_score = add_two(x=score)</span><br><span class="line"><span class="keyword">print</span> (new_score)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 2</span></span><br></pre></td></tr></table></figure><p>一个函数可以有任意多个输入参数和输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Function with multiple inputs</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join_name</span><span class="params">(first_name, last_name)</span>:</span></span><br><span class="line">    <span class="string">"""Combine first name and last name."""</span></span><br><span class="line">    joined_name = first_name + <span class="string">" "</span> + last_name</span><br><span class="line">    <span class="keyword">return</span> joined_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use the function</span></span><br><span class="line">first_name = <span class="string">"Goku"</span></span><br><span class="line">last_name = <span class="string">"Mohandas"</span></span><br><span class="line">joined_name = join_name(</span><br><span class="line">    first_name=first_name, last_name=last_name)</span><br><span class="line"><span class="keyword">print</span> (joined_name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Goku Mohandas</span></span><br></pre></td></tr></table></figure><p>在使用函数时，始终使用关键字参数是一个好习惯，这样非常清楚每个输入变量属于哪个函数输入参数。相关的是，您经常会看到术语*args和**kwargs，它们代表位置参数和关键字参数。当它们传递到函数中时，可以提取它们。星号的重要性在于任何数量的位置参数和关键字参数都可以传递到函数中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">    x = args[<span class="number">0</span>]</span><br><span class="line">    y = kwargs.get(<span class="string">"y"</span>)</span><br><span class="line">    <span class="keyword">print</span> (<span class="string">f"x: <span class="subst">&#123;x&#125;</span>, y: <span class="subst">&#123;y&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f(<span class="number">5</span>, y=<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># x: 5, y: 2</span></span><br></pre></td></tr></table></figure><h2 id="Classes">Classes</h2><p>类是对象构造函数，也是Python面向对象编程的基本组成部分。它们由一组定义类及其操作的函数组成。</p><h3 id="Magic-methods">Magic methods</h3><p>可以使用像<code>__init__</code>和<code>__str__</code>这样的魔术方法来自定义类，以实现强大的操作。这些也被称为dunder方法，表示有两个前置和后置下划线。</p><p><code>__init__</code>方法用于初始化类的实例。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Creating the class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Class object for a pet."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, species, name)</span>:</span></span><br><span class="line">        <span class="string">"""Initialize a Pet."""</span></span><br><span class="line">        self.species = species</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating an instance of a class</span></span><br><span class="line">my_dog = Pet(species=<span class="string">"dog"</span>,</span><br><span class="line">             name=<span class="string">"Scooby"</span>)</span><br><span class="line"><span class="keyword">print</span> (my_dog)</span><br><span class="line"><span class="keyword">print</span> (my_dog.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># &lt;__main__.Pet object at 0x7fe487e9c358&gt;</span></span><br><span class="line"><span class="comment"># Scooby</span></span><br></pre></td></tr></table></figure><p><code>print(my_dog)</code>命令打印了一些与我们不太相关的内容。让我们使用__str__函数来修复它。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Creating the class</span></span><br><span class="line"><span class="comment"># Creating the class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Class object for a pet."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, species, name)</span>:</span></span><br><span class="line">        <span class="string">"""Initialize a Pet."""</span></span><br><span class="line">        self.species = species</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Output when printing an instance of a Pet."""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"<span class="subst">&#123;self.species&#125;</span> named <span class="subst">&#123;self.name&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating an instance of a class</span></span><br><span class="line">my_dog = Pet(species=<span class="string">"dog"</span>,</span><br><span class="line">             name=<span class="string">"Scooby"</span>)</span><br><span class="line"><span class="keyword">print</span> (my_dog)</span><br><span class="line"><span class="keyword">print</span> (my_dog.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># dog named Scooby</span></span><br><span class="line"><span class="comment"># Scooby</span></span><br></pre></td></tr></table></figure><h3 id="Object-functions">Object functions</h3><p>除了这些魔术方法，类还可以拥有对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Creating the class</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""Class object for a pet."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, species, name)</span>:</span></span><br><span class="line">        <span class="string">"""Initialize a Pet."""</span></span><br><span class="line">        self.species = species</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Output when printing an instance of a Pet."""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"<span class="subst">&#123;self.species&#125;</span> named <span class="subst">&#123;self.name&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">change_name</span><span class="params">(self, new_name)</span>:</span></span><br><span class="line">        <span class="string">"""Change the name of your Pet."""</span></span><br><span class="line">        self.name = new_name</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creating an instance of a class</span></span><br><span class="line">my_dog = Pet(species=<span class="string">"dog"</span>, name=<span class="string">"Scooby"</span>)</span><br><span class="line"><span class="keyword">print</span> (my_dog)</span><br><span class="line"><span class="keyword">print</span> (my_dog.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># dog named Scooby</span></span><br><span class="line"><span class="comment"># Scooby</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using a class's function</span></span><br><span class="line">my_dog.change_name(new_name=<span class="string">"Scrappy"</span>)</span><br><span class="line"><span class="keyword">print</span> (my_dog)</span><br><span class="line"><span class="keyword">print</span> (my_dog.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># dog named Scrappy</span></span><br><span class="line"><span class="comment"># Scrappy</span></span><br></pre></td></tr></table></figure><h3 id="Inheritance">Inheritance</h3><p>我们还可以使用继承来构建类的层次结构，这样我们就能够从另一个类（父类）中继承所有属性和方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Pet)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, breed)</span>:</span></span><br><span class="line">        super().__init__(species=<span class="string">"dog"</span>, name=name)</span><br><span class="line">        self.breed = breed</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"A <span class="subst">&#123;self.breed&#125;</span> doggo named <span class="subst">&#123;self.name&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">scooby = Dog(species=<span class="string">"dog"</span>, breed=<span class="string">"Great Dane"</span>, name=<span class="string">"Scooby"</span>)</span><br><span class="line"><span class="keyword">print</span> (scooby)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># A Great Dane doggo named Scooby</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">scooby.change_name(<span class="string">"Scooby Doo"</span>)</span><br><span class="line"><span class="keyword">print</span> (scooby)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># A Great Dane doggo named Scooby Doo</span></span><br></pre></td></tr></table></figure><p>注意我们从父类Pet继承了初始化变量，如species和name。我们还继承了像change_name()这样的函数。</p><h3 id="Methods">Methods</h3><p>在类方面，有两个重要的装饰器方法需要了解：@classmethod 和 @staticmethod。我们将在下一节中学习装饰器，但这些特定的方法与类相关，因此我们将在此处介绍它们。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Pet)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, breed)</span>:</span></span><br><span class="line">        super().__init__(species=<span class="string">"dog"</span>, name=name)</span><br><span class="line">        self.breed = breed</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"<span class="subst">&#123;self.breed&#125;</span> named <span class="subst">&#123;self.name&#125;</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_dict</span><span class="params">(cls, d)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> cls(name=d[<span class="string">"name"</span>], breed=d[<span class="string">"breed"</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_cute</span><span class="params">(breed)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># all animals are cute!</span></span><br></pre></td></tr></table></figure><p><code>@classmethod</code>允许我们通过传递未实例化的类本身（cls）来创建类实例。这是从对象（例如字典）创建（或加载）类的好方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create instance</span></span><br><span class="line">d = &#123;<span class="string">"name"</span>: <span class="string">"Cassie"</span>, <span class="string">"breed"</span>: <span class="string">"Border Collie"</span>&#125;</span><br><span class="line">cassie = Dog.from_dict(d=d)</span><br><span class="line">print(cassie)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># Border Collie named Cassie</span></span><br></pre></td></tr></table></figure><p>一个 <code>@staticmethod</code> 可以从未实例化的类对象中调用，因此我们可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Static method</span></span><br><span class="line">res = Dog.is_cute(breed=<span class="string">"Border Collie"</span>)</span><br><span class="line"><span class="keyword">print</span> (res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure><h2 id="Decorators">Decorators</h2><p>回想一下，函数允许我们将代码模块化并重复使用。然而，我们经常希望在主要函数执行之前或之后添加一些功能，并且可能希望对许多不同的函数进行此操作。我们可以使用装饰器来实现这个目的，而不是向原始函数添加更多代码！</p><p>装饰器：在函数之前/之后增加处理以增强该函数。装饰器包裹在主函数周围，允许我们对输入和/输出进行操作。</p><p>假设我们有一个名为operations的函数，它将输入值x增加1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">operations</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""Basic operations."""</span></span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">operations(x=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 2</span></span><br></pre></td></tr></table></figure><p>现在假设我们想要在操作函数执行前后将输入 x 增加 1，为了说明这个例子，让我们假设增量必须是单独的步骤。</p><p>下面是我们通过更改原始代码来完成的方案：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">operations</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""Basic operations."""</span></span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">operations(x=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>我们已经实现了想要的功能，但是我们现在增加了操作函数的规模，如果我们想对任何其他函数进行相同的递增操作，那么我们也必须将相同的代码添加到所有这些函数中… 这不太高效。为了解决这个问题，让我们创建一个名为<code>add</code>的装饰器，在主函数f执行之前和之后将x增加1。</p><h3 id="Creating-a-decorator">Creating a decorator</h3><p>装饰器函数接受一个函数f作为参数，这个函数是我们想要包装的函数，在本例中，它是operations()。装饰器的输出是其包装器函数，该函数接收传递给函数f的参数和关键字参数。</p><p>在包装函数中，我们可以：</p><ul><li><ol><li>提取传递给函数f的输入参数</li></ol></li><li><ol start="2"><li>对函数输入进行任何更改</li></ol></li><li><ol start="3"><li>执行函数f</li></ol></li><li><ol start="4"><li>对函数输出进行任何更改</li></ol></li><li><ol start="5"><li>wrapper函数返回一些值，这就是装饰器返回的值，因为它也返回wrapper。</li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(f)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""Wrapper function for @add."""</span></span><br><span class="line">        x = kwargs.pop(<span class="string">"x"</span>) <span class="comment"># .get() if not altering x</span></span><br><span class="line">        x += <span class="number">1</span> <span class="comment"># executes before function f</span></span><br><span class="line">        x = f(*args, **kwargs, x=x)</span><br><span class="line">        x += <span class="number">1</span> <span class="comment"># executes after function f</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><p>我们可以通过在主函数顶部添加 <code>@</code> 符号来简单地使用这个装饰器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@add</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">operations</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""Basic operations."""</span></span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">operations(x=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 4</span></span><br></pre></td></tr></table></figure><p>假设我们想要调试并查看实际执行operations()函数的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">operations.__name__, operations.__doc__</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># ('wrapper', 'Wrapper function for @add.')</span></span><br></pre></td></tr></table></figure><p>函数名和文档字符串并不是我们要寻找的内容，但它们出现在这里是因为执行的是包装器函数。为了解决这个问题，Python 提供了 functools.wraps 函数来保留主函数的元数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""Wrapper function for @add."""</span></span><br><span class="line">        x = kwargs.pop(<span class="string">"x"</span>)</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        x = f(*args, **kwargs, x=x)</span><br><span class="line">        x += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@add</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">operations</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="string">"""Basic operations."""</span></span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">operations.__name__, operations.__doc__</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># ('operations', 'Basic operations.')</span></span><br></pre></td></tr></table></figure><p>太棒了！我们成功地使用装饰器来实现自定义，而不必修改函数本身。我们可以将这个装饰器用于其他需要相同自定义的函数中！</p><h3 id="Callbacks">Callbacks</h3><p>装饰器允许在主函数执行前后进行自定义操作，但是中间呢？假设我们想有条件地/有场景地执行一些操作。我们可以使用回调函数，而不是编写大量的if语句并使我们的函数臃肿。</p><p>回调：在函数内的有条件/有场景地执行任务。</p><p>我们定义一个有特殊函数的类，这些函数将在主函数执行期间的各个时期执行。 函数名称由我们决定，但我们需要在主要功能中调用相同的回调函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Callback</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XTracker</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.history = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">at_start</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.history.append(x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">at_end</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.history.append(x)</span><br></pre></td></tr></table></figure><p>我们可以传入任意数量的回调函数，因为它们具有特定命名的函数，所以它们将在适当的时间被调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">operations</span><span class="params">(x, callbacks=[])</span>:</span></span><br><span class="line">    <span class="string">"""Basic operations."""</span></span><br><span class="line">    <span class="keyword">for</span> callback <span class="keyword">in</span> callbacks:</span><br><span class="line">        callback.at_start(x)</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> callback <span class="keyword">in</span> callbacks:</span><br><span class="line">        callback.at_end(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">tracker = XTracker(x=x)</span><br><span class="line">operations(x=x, callbacks=[tracker])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tracker.history</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [1, 2]</span></span><br></pre></td></tr></table></figure><h3 id="Putting-it-all-together">Putting it all together</h3><p>decorators + callbacks = 不增加复杂度的情况下在函数执行的前、中或后执行超强的自定义任务。 我们将在未来的中使用这个组合来创建强大的机器学习/深度学习训练脚本，这些脚本具有高度可定制性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrap</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="string">"""Wrapper function for @add."""</span></span><br><span class="line">        x = kwargs.pop(<span class="string">"x"</span>) <span class="comment"># .get() if not altering x</span></span><br><span class="line">        x += <span class="number">1</span> <span class="comment"># executes before function f</span></span><br><span class="line">        x = f(*args, **kwargs, x=x)</span><br><span class="line">        <span class="comment"># can do things post function f as well</span></span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">return</span> wrap</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Callback</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XTracker</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.history = [x]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">at_start</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.history.append(x)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">at_end</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.history.append(x)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Main function</span></span><br><span class="line"><span class="meta">@add</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">operations</span><span class="params">(x, callbacks=[])</span>:</span></span><br><span class="line">    <span class="string">"""Basic operations."""</span></span><br><span class="line">    <span class="keyword">for</span> callback <span class="keyword">in</span> callbacks:</span><br><span class="line">        callback.at_start(x)</span><br><span class="line">    x += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> callback <span class="keyword">in</span> callbacks:</span><br><span class="line">        callback.at_end(x)</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">tracker = XTracker(x=x)</span><br><span class="line">operations(x=x, callbacks=[tracker])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tracker.history</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h2 id="Citation">Citation</h2><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">@article</span><span class="template-variable">&#123;madewithml,</span></span><br><span class="line"><span class="template-variable">    author       = &#123;Goku Mohandas&#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">    title        = </span><span class="template-variable">&#123; Python - Made With ML &#125;</span><span class="xml">,</span></span><br><span class="line"><span class="xml">    howpublished = </span><span class="template-variable">&#123;\url&#123;https://madewithml.com/&#125;</span><span class="xml">&#125;,</span></span><br><span class="line"><span class="xml">    year         = </span><span class="template-variable">&#123;2022&#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="Ending">Ending</h2><p>到这里，便拥有了Way2AI路上需要的Python的必备知识。</p><p>但我们不应该止步于此，应该学习更多的Python知识以面对更大的挑战。<br><a href="https://www.python.org/" target="_blank" rel="noopener" title="python">Python官网</a> 上有关于Python这门语言全部知识。</p>]]></content>
    
    <summary type="html">
    
      The fundamentals of Python programming for AI.
    
    </summary>
    
    
      <category term="Courses" scheme="https://neo1989.net/categories/Courses/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
      <category term="AI" scheme="https://neo1989.net/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>NLP的神经网络简史</title>
    <link href="https://neo1989.net/Notes/NOTE-neural-history-of-nlp/"/>
    <id>https://neo1989.net/Notes/NOTE-neural-history-of-nlp/</id>
    <published>2023-05-13T15:08:58.000Z</published>
    <updated>2023-05-15T15:22:42.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TL-DR">TL;DR</h2><p>本文主要内容源于NLP神经网络发展史及<a href="https://aylien.com/blog/a-review-of-the-recent-history-of-natural-language-processing#2001neurallanguagemodels" target="_blank" rel="noopener" title="A Review of the Neural History of NLP">《A Review of the Neural History of Natural Language Processing》</a>，仅供学习探讨，如有错误均是本人的，与他人无关。</p><h2 id="2000-Neural-Language-Models">2000 - Neural Language Models</h2><p>语言建模的任务是在给定前面的词的情况下预测文本中的下一个词。这可能是最简单的语言处理任务，并且有具体的实际应用，比如智能输入法和电子邮件回复建议。语言建模有着丰富的历史，经典的方法是基于n-gram的，并采用平滑处理来解决未见n-grams的问题。</p><p>第一个神经网络语言模型 <strong>前馈神经网络</strong> 首次于2000年在文章《A Neural Probabilistic Language Model》中被提出，并收录于<a href="https://proceedings.neurips.cc/paper_files/paper/2000" target="_blank" rel="noopener" title="NIPS 2000">NIPS 2000</a>。</p><p><img src="//s3.mindex.xyz/blog/Notes/7bf9f44058ca39125ca0926b43dc0bb8.png" alt="前馈神经网络"></p><p>该神经网络语言模型的主要构成如下：</p><ul><li>输入层：输入通过查询表C得到的前n个词的向量表示。也就是如今大家熟知的词嵌入。</li><li>隐藏层：将n个词嵌入连接起来，作为隐藏层的输入。以进一步学习词之间的表示。</li><li>输出层：隐藏层的输出被提供给softmax以输出概率。</li></ul><p>该模型的主要novelty在于引入了词嵌入，这比简单的one-hot编码能提供更丰富的词义信息。这些词嵌入可以体现出词与词之间的关系，从而捕捉到更复杂的上下文关系。<br>模型通过最大似然估计来训练整个网络，找到最优的词嵌入和网络参数，使得模型可以更好地预测下一个词。<br>关于该模型的更多内容，参考<a href="https://www.ruder.io/word-embeddings-1/" target="_blank" rel="noopener" title="Word Embeddings">这篇博文</a>。</p><h2 id="2008-Multi-task-learning">2008 - Multi-task learning</h2><p>多任务学习，是一种通过在多个任务上训练模型来共享参数的一般方法。在神经网络中，多任务学习可以通过共享不同层的权重来简单实现。<br>多任务学习鼓励模型学习对许多任务都有用的表征。这对于学习通用的底层表征，聚焦模型的注意力或在训练数据有限的设置中特别有用。<br>多任务学习于2008年在文章<a href="http://machinelearning.org/archive/icml2008/papers/391.pdf" target="_blank" rel="noopener" title="A Unifield Architecture for NLP">《A Unified Architecture for Natural Language Processing》</a>中首次被应用于NLP神经网络。在他们的模型中，使用共享的lookup tables（词嵌入矩阵）实现多任务学习。如下图所示</p><p><img src="//s3.mindex.xyz/blog/Notes/b9dfb3dddfad8124c4c5314841284859.png" alt="共享词嵌入矩阵"></p><p>共享词嵌入使得模型能够协作并分享词嵌入矩阵中的底层信息，这通常构成了模型中最大数量的参数。该论文不仅使用了多任务学习，而且还推动了预训练词嵌入和使用卷积神经网络（CNNs）处理文本等思想，这些思想后来来才被广泛采用。而且这篇论文获得了<a href="https://research.facebook.com/blog/2018/07/facebook-researchers-win-test-of-time-award-at-icml-2018/" target="_blank" rel="noopener" title="the test-of-time award at ICML 2018">the test-of-time award at ICML 2018</a>。</p><h2 id="2013-Word-embeddings">2013 - Word embeddings</h2><p>文本的向量表示，在自然语言处理中有着悠久的历史。早在2001年，我们就已经看到了单词的密集向量表示或词嵌入。Mikolov等人于2013年提出的主要创新是通过去除隐藏层并近似目标来使这些单词嵌入的训练更加高效。虽然这些变化在性质上很简单，但它们与高效的word2vec实现一起，使得大规模训练单词嵌入成为可能。</p><p>Word2vec有两种不同的模型，如下图所示：连续词袋模型（CBOW）和Skip-gram模型。它们的目标不同：一个是基于周围单词预测中心单词，而另一个则相反。</p><p><img src="//s3.mindex.xyz/blog/Notes/52a8eded3320bc69bed21ce7393b708a.png" alt="Continuous bag-of-words and skip-gram architectures (Mikolov et al., 2013a; 2013b)"></p><p>虽然这些嵌入在概念上与使用前馈神经网络学习的嵌入没有区别，但是在大型语料库上进行训练使它们能够捕捉到单词之间的某些关系，例如性别、动词时态和国家-首都关系，如下图所示。</p><p><img src="//s3.mindex.xyz/blog/Notes/f091661e00c40308e7af75b2b0c81fcc.png" alt="Relations captured by word2vec (Mikolov et al., 2013a; 2013b)"></p><p>这些关系及其背后的含义引发了对词嵌入的初步兴趣，许多研究探讨了这些线性关系的起源。虽然word2vec捕获的关系具有直观和近乎神奇的特质，但后来的研究表明，word2vec本身并没有什么特别之处：词嵌入也可以通过矩阵分解进行学习，并且经过适当调整，像SVD和LSA这样的经典矩阵分解方法可以实现类似的结果。</p><h2 id="2013-Neural-networks-for-NLP">2013 - Neural networks for NLP</h2><p>2013年和2014年是神经网络模型开始在自然语言处理中得到应用的时间。三种主要类型的神经网络变得最为广泛使用：循环神经网络、卷积神经网络和递归神经网络。</p><p>循环神经网络（RNNs）是处理自然语言处理中普遍存在的动态输入序列的明显选择。但传统的<a href="https://www.dlsi.ua.es/~mlf/nnafmc/papers/elman90finding.pdf" target="_blank" rel="noopener" title="Finding Structure in Time">Vanilla RNNs（Elman, 1990）</a> 很快被经典的<a href="https://ieeexplore.ieee.org/abstract/document/6795963" target="_blank" rel="noopener" title="Long Short-Term Memory">长短期记忆网络(LSTM)（Hochreiter＆Schmidhuber, 1997）</a>所取代，后者对于梯度消失和爆炸问题更具鲁棒性。</p><p>LSTM单元如下图所示，而一个<a href="https://ieeexplore.ieee.org/abstract/document/6707742" target="_blank" rel="noopener" title="Hybrid speech recognition with Deep Bidirectional LSTM">bidirectional LSTM(Graves et al., 2013)</a>通常用于处理左右两侧的上下文。</p><p><img src="//s3.mindex.xyz/blog/Notes/134bf9c41fc64fb60f29effbc4adcca4.png" alt="An LSTM network"></p><p>随着卷积神经网络（CNNs）在计算机视觉中的广泛应用，它们也开始被应用于语言领域（<a href="https://arxiv.org/abs/1404.2188" target="_blank" rel="noopener" title="A Convolutional Neural Network for Modelling Sentences">Kalchbrenner et al., 2014</a>）。文本卷积神经网络仅在两个维度上运行，并且滤波器只需要沿时间维度移动。下图显示了NLP中使用的典型CNN。</p><p><img src="//s3.mindex.xyz/blog/Notes/32da185b5fde2ca9f37171f50682e7a2.png" alt="A convolutional neural network for text (Kim, 2014)"></p><p>卷积神经网络的一个优点是它们比循环神经网络更易于并行化，因为每个时间步的状态仅取决于局部上下文（通过卷积操作），而不像RNNs中那样依赖所有过去状态。可以使用扩张卷积来扩展具有更广泛感受野的CNNs以捕获更广泛的上下文（<a href="https://arxiv.org/abs/1610.10099" target="_blank" rel="noopener" title="Neural Machine Translation in Linear Time">Kalchbrenner et al., 2016</a>）。CNNs和LSTMs也可以组合和堆叠，并且可以使用卷积来加速LSTM。</p><p>RNNs和CNNs都将语言视为序列。然而，从语言学的角度来看，语言本质上是分层的：单词组成更高级别的短语和从句，这些短语和从句可以根据一组生成规则进行递归组合。在语言学启发下，将句子视为树而不是序列的想法引出了递归神经网络，如下图所示。</p><p><img src="//s3.mindex.xyz/blog/Notes/38990eb262a258a52ca3d53b52362337.png" alt="A recursive neural network (Socher et al., 2013)"></p><p>递归神经网络从底部向上构建序列的表示，与RNNs相比，后者是从左到右或从右到左处理句子。在树的每个节点处，通过组合子节点的表示来计算新的表示。由于树也可以被视为对RNNs施加不同的处理顺序，因此LSTMs自然而然地扩展到了树结构。</p><p>于是，不只是循环神经网络和长短时记忆网络可以扩展以处理分层结构，词嵌入亦可以基于局部上下文或语法上下文进行学习（<a href="https://aclanthology.org/P14-2050.pdf" target="_blank" rel="noopener" title="Dependency-Based Word Embeddings">Levy＆Goldberg, 2014</a>）， 语言模型可以根据句法堆栈生成单词（<a href="https://www.sciencedirect.com/science/article/abs/pii/S0028393220301500" target="_blank" rel="noopener" title="Localizing syntactic predictions using recurrent neural network grammars">Dyer et al., 2016</a>）， 而且图卷积神经网络可以在树上操作（<a href="https://arxiv.org/abs/1704.04675" target="_blank" rel="noopener" title="Graph Convolutional Encoders for Syntax-aware Neural Machine Translation">Bastings et al., 2017</a>）。</p><h2 id="2014-Seq2Seq-models">2014 - Seq2Seq models</h2><p>2014年，Sutskever等人提出了seq2seq，这是一种使用神经网络将一个序列映射到另一个序列的通用框架。在这个框架中，编码器神经网络逐个符号地处理一个句子，并将其压缩成向量表示；解码器神经网络根据编码器状态逐个预测输出符号，在每一步都以先前预测的符号作为输入，如下图所示。</p><p><img src="//s3.mindex.xyz/blog/Notes/259c165e05db3259338615a284cb7bc4.png" alt="A sequence-to-sequence model (Sutskever et al., 2014)"></p><p>机器翻译成为了该框架的杀手级应用。2016年，谷歌宣布开始用神经机器翻译模型（<a href="https://arxiv.org/abs/1609.08144" target="_blank" rel="noopener" title="Google's Neural Machine Translation System">Wu et al.，2016</a>）替换其基于短语的机器翻译模型。根据Jeff Dean的说法，这意味着用一个500行的神经网络模型代替了50万行的基于短语的机器翻译代码。</p><p>由于其灵活性，这个框架现在已成为自然语言生成任务的首选框架，不同的模型扮演编码器和解码器的角色。重要的是，解码器模型不仅可以基于序列进行条件化，还可以基于任意表示进行条件化。例如，在图像上生成标题（<a href="https://www.cv-foundation.org/openaccess/content_cvpr_2015/html/Vinyals_Show_and_Tell_2015_CVPR_paper.html" target="_blank" rel="noopener" title="A Neural Image Caption Generator">Vinyals et al., 2015</a>）（如下图所示），根据表格生成文本（<a href="https://arxiv.org/abs/1603.07771" target="_blank" rel="noopener" title="Neural Text Generation from Structured Data with Application to the Biography Domain">Lebret et al., 2016</a>），以及根据源代码更改生成描述（<a href="https://arxiv.org/abs/1704.04856" target="_blank" rel="noopener" title="A Neural Architecture for Generating Natural Language Descriptions from Source Code Changes">Loyola et al., 2017</a>）等许多其他应用。</p><p><img src="//s3.mindex.xyz/blog/Notes/83398534fc191b613e45801767e23402.png" alt="Generating a caption based on an image (Vinyals et al., 2015)"></p><p>序列到序列学习甚至可以应用于NLP中常见的结构化预测任务，其中输出具有特定的结构。如下图简单的成分句法分析示例，可以看出输出被线性化了。神经网络已经证明了在给定足够数量的成分句法解析（<a href="https://arxiv.org/abs/1412.7449" target="_blank" rel="noopener" title="Grammar as a Foreign Language">Vinyals et al., 2015</a>）和命名实体识别（<a href="https://arxiv.org/abs/1512.00103" target="_blank" rel="noopener" title="Multilingual Language Processing From Bytes">Gillick et al., 2016</a>）训练数据的情况下直接学习生成这种线性化输出的能力。</p><p><img src="//s3.mindex.xyz/blog/Notes/1ec99e613705027ba8bb0ff275f0a45b.png" alt="Linearizing a constituency parse tree (Vinyals et al., 2015)"></p><h2 id="2015-Attention">2015 - Attention</h2><p>注意力机制（<a href="https://arxiv.org/abs/1409.0473" target="_blank" rel="noopener" title="Neural Machine Translation by Jointly Learning to Align and Translate">Bahdanau et al., 2015</a>）是神经机器翻译（NMT）中的核心创新之一，也是使NMT模型胜过传统基于短语的机器翻译系统的关键思想。序列到序列学习的主要瓶颈在于需要将源序列的整个内容压缩成固定大小的向量。注意力通过允许解码器回顾源序列隐藏状态来缓解这个问题，然后将其作为加权平均值提供给解码器作为附加输入，如下图所示。</p><p><img src="//s3.mindex.xyz/blog/Notes/f45ebf52e4a5d70c6847755553774912.png" alt="Attention (Bahdanau et al., 2015)"></p><p>注意力机制广泛适用于任何需要基于输入的某些部分做出决策的任务，并具有潜在的实用价值。它已被应用于成分句法分析（<a href="https://arxiv.org/abs/1412.7449" target="_blank" rel="noopener" title="Grammar as a Foreign Language">Vinyals et al., 2015</a>）、阅读理解（<a href="https://arxiv.org/abs/1506.03340" target="_blank" rel="noopener" title="Teaching Machines to Read and Comprehend">Hermann et al., 2015</a>）和一次性学习（<a href="https://arxiv.org/abs/1606.04080" target="_blank" rel="noopener" title="Matching Networks for One Shot Learning">Vinyals et al., 2016</a>）等许多领域。输入甚至不需要是一个序列，而可以由其他表示形式组成，如下图所示的图像字幕生成（<a href="https://proceedings.mlr.press/v37/xuc15.html" target="_blank" rel="noopener" title="Show, Attend and Tell: Neural Image Caption Generation with Visual Attention">Xu et al., 2015</a>）。注意力机制的一个有用的副作用是通过检查注意权重来确定哪些输入部分与特定输出相关联，从而提供了对模型内部工作方式的一瞥。</p><p><img src="//s3.mindex.xyz/blog/Notes/2fad1cf2fd8986f0b2689aad1807eb75.png" alt="Visual attention in an image captioning model indicating what the model is attending to when generating the word &quot;frisbee&quot;. (Xu et al., 2015)"></p><p>注意力不仅限于查看输入序列；<strong>自注意力</strong>可以用来查看句子或文档中周围的单词，以获得更具上下文敏感性的单词表示。多层自注意是Transformer架构（<a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener" title="Attention Is All You Need">Vaswani et al.,2017</a>）的核心，这是当前最先进的NMT模型。</p><h2 id="2015-Memory-based-networks">2015 - Memory-based networks</h2><p>注意力可以被看作是一种模糊记忆形式，其中记忆由模型的过去隐藏状态组成，而模型选择从记忆中检索什么。关于注意力及其与记忆的联系的更详细概述，请查看<a href="https://dennybritz.com/posts/wildml/attention-and-memory-in-deep-learning-and-nlp/" target="_blank" rel="noopener" title="Attention and Memory in Deep Learning and NLP">此文章</a>。已经提出了许多具有更明确内存的模型。它们有不同的变体，例如神经图灵机（<a href="https://arxiv.org/abs/1410.5401" target="_blank" rel="noopener" title="Neural Turing Machines">Graves et al., 2014</a>），记忆网络（<a href="https://arxiv.org/abs/1410.3916" target="_blank" rel="noopener" title="Memory Networks">Weston et al., 2015</a>）和端到端内存网络（<a href="https://arxiv.org/abs/1503.08895" target="_blank" rel="noopener" title="End-To-End Memory Networks">Sukhbaatar et al., 2015</a>），动态内存网络（<a href="https://arxiv.org/abs/1506.07285" target="_blank" rel="noopener" title="Ask Me Anythins: Dynamic Memory Networks for Natural Language Processing">Kumar et al., 2015</a>），神经可微分计算机（<a href="https://www.nature.com/articles/nature20101" target="_blank" rel="noopener" title="Hybrid computing using a neural network with dynamic external memory">Graves et al., 2016</a>）以及循环实体网络（<a href="https://arxiv.org/abs/1612.03969" target="_blank" rel="noopener" title="Tracking the World State with Recurrent Entity Networks">Henaff et al., 2017</a>）。</p><p>记忆通常是基于与当前状态的相似性进行访问，类似于注意力，并且通常可以进行写入和读取。模型在实现和利用内存方面存在差异。例如，端到端记忆网络多次处理输入并更新内存以实现多步推理。神经图灵机还具有基于位置的寻址功能，使它们能够学习简单的计算机程序，如排序。基于记忆的模型通常应用于需要保留信息更长时间跨度可能会有帮助的任务中，例如语言建模和阅读理解。记忆概念非常灵活：知识库或表格可以作为一种内存功能，而内存也可以根据整个输入或特定部分来填充。</p><h2 id="2018-Pretrained-language-models">2018 - Pretrained language models</h2><p>预训练的词嵌入是与上下文无关的，仅用于初始化我们模型中的第一层。后来，一系列监督任务已被用来预训练神经网络（<a href="https://arxiv.org/abs/1705.02364" target="_blank" rel="noopener" title="Supervised Learning of Universal Sentence Representations from Natural Language Inference Data">Conneau et al., 2017</a>; <a href="https://proceedings.neurips.cc/paper_files/paper/2017/hash/20c86a628232a67e7bd46f76fba7ce12-Abstract.html" target="_blank" rel="noopener" title="Learned in Translation: Contextualized Word Vectors">McCann et al., 2017</a>; <a href="https://arxiv.org/abs/1804.00079" target="_blank" rel="noopener" title="Learning General Purpose Distributed Sentence Representations via Large Scale Multi-task Learning">Subramanian et al., 2018</a>）。相比之下，语言模型只需要未标记的文本；因此可以扩展到数十亿个标记、新领域和新语言。<br>预先训练的语言模型最初是在2015年提出的（<a href="https://proceedings.neurips.cc/paper_files/paper/2015/hash/7137debd45ae4d0ab9aa953017286b20-Abstract.html" target="_blank" rel="noopener" title="Semi-supervised Sequence Learning">Dai＆Le, 2015</a>）；直到18年才显示它们对各种任务都有益处。<br>语言模型嵌入可以用作目标模型（<a href="https://arxiv.org/abs/1809.09795" target="_blank" rel="noopener" title="Deep contextualized word representations">Peters et al., 2018</a>）中的特征或者可以在目标任务数据上微调语言模型（<a href="https://arxiv.org/abs/1611.02683" target="_blank" rel="noopener" title="Unsupervised Pretraining for Sequence to Sequence Learning">Ramachandran et al., 2017</a>; <a href="https://arxiv.org/abs/1801.06146" target="_blank" rel="noopener" title="Universal Language Model Fine-tuning for Text Classification">Howard＆Ruder, 2018</a>）。<br>如下图所示，在许多不同任务中添加语言模型嵌入可大幅改善现有技术水平。</p><p><img src="//s3.mindex.xyz/blog/Notes/94b544d5bf32bd5298c52e477b3bcdf2.png" alt="Improvements with language model embeddings over the state-of-the-art (Peters et al., 2018)"></p><p>预训练语言模型被证明可以在使用更少数据的情况下进行学习。由于语言模型只需要无标签数据，因此它们对于标注数据稀缺的低资源语言尤其有益。</p><h2 id="2018-Large-language-models">2018 - Large language models</h2><p>如你所知，整个NLP领域发展到了LLMs时代。参考阅读<a href="https://mp.weixin.qq.com/s/_pDxwIy7Z8punWMKoJiJKQ" target="_blank" rel="noopener" title="ChatGPT核心技术的进化之路">《ChatGPT核心技术的进化之路》</a></p><h2 id="结尾">结尾</h2><p>GPT的提出标志着NLP技术的飞速发展，但对新手来说也增加了学习难度。要从头学习NLP，Claude给出了以下建议：</p><ul><li>了解NLP基础知识。包括语言建模，词嵌入，神经网络，LSTM，Transformer等基础模型和技术。这些知识可以通过阅读《自然语言处理综述》等资料得到。</li><li>实现基本NLP任务的模型。如语言建模，文本分类，问答系统等。可以从简单的RNN和LSTM模型实现，了解基本思路和步骤。</li><li>理解Transformer和GPT等新模型。阅读论文《Attention is All You Need》和《Improving Language Understanding by Generative Pre-Training》，理解其模型结构，训练方法和创新点。</li><li>学习PyTorch和TensorFlow等深度学习框架。这些框架可以让你更容易实现复杂的NLP模型，对学习NLP模型很有帮助。</li><li>了解BERT，XLNet，RoBERTa等预训练语言模型。这些模型的使用和微调技巧需要理解，可以带来很大便利。</li><li>跟进NLP最新进展。阅读ACL，EMNLP，NAACL等顶会论文，了解最新的模型，技术和数据集。这可以让你了解NLP最新研究热点和前沿方向。</li><li>多练习和实现。上手实践是学习NLP最重要的方式之一。可以实现论文中的模型，优化和改进这些模型，并在各种数据集上进行试验。这可以加深理解和提高实践能力。</li><li>多阅读优质学习资料。像《神经网络与深度学习》《动手学深度学习》等书籍，全面且深入地介绍了深度学习和NLP相关知识。这些资料对学习NLP大有帮助。</li></ul><p>总之，要系统和全面地学习NLP，需要理论与实践相结合。理解基础知识和最新研究进展，跟进理论前沿；并且要大量动手实践，通过实现和优化相关模型来加深理解。同时，也要利用优质学习资料，能够更全面和深入地学习这个领域的知识。持之以恒，NLP的学习之路才能走得更加通透。</p>]]></content>
    
    <summary type="html">
    
      了解历史背景可以帮助我们更好地理解其概念，同时也有助于掌握其未来发展方向和趋势。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
      <category term="NLP" scheme="https://neo1989.net/tags/NLP/"/>
    
      <category term="AI" scheme="https://neo1989.net/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>LangChain | 快速释放LLMs的能力 (三)</title>
    <link href="https://neo1989.net/Notes/NOTE-langchain-3/"/>
    <id>https://neo1989.net/Notes/NOTE-langchain-3/</id>
    <published>2023-05-12T04:49:09.000Z</published>
    <updated>2023-05-12T07:10:29.459Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TL-DR">TL;DR</h2><p>本文介绍了一种方法，让LLM拥有了上网的能力。</p><h2 id="结果展示">结果展示</h2><p>如下图，问了它两个股票的价格现价，都能够正确的给出答案。</p><p><img src="//s3.mindex.xyz/blog/Notes/3c6908b694ec7ccaf268899e3e33c208.png" alt=""></p><h2 id="如何实现">如何实现</h2><p>在没有大模型之前，这个问题如何实现？</p><p>其实也简单，一点点NLP技能就可以解决。</p><p>NLP伪代码:</p><ul><li>抽取问题里的词槽，上述示例中词槽便是 stock_name: 科大讯飞</li><li>执行对应的action，也就是调用方法get_current_price(stockname=“科大讯飞”)</li><li>格式化输出</li></ul><p>那这里的问题是，在抽取阶段，你需要写很多的规则，或者自己训练一个信息抽取模型。</p><p>如今，交给LLMs就行了。</p><p>来看看LangChain是如何简化这件事情的。这里就需要用到开篇里介绍的<a href="https://python.langchain.com/en/latest/modules/agents.html" target="_blank" rel="noopener" title="LangChain Agents">Agents</a>组件了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> sina <span class="keyword">import</span> Sina</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> BaseModel, Field</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.agents <span class="keyword">import</span> AgentType, initialize_agent</span><br><span class="line"><span class="keyword">from</span> langchain.tools <span class="keyword">import</span> BaseTool</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Type, Optional</span><br><span class="line"><span class="keyword">from</span> langchain.callbacks.manager <span class="keyword">import</span> CallbackManagerForToolRun, AsyncCallbackManagerForToolRun</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockQueryInput</span><span class="params">(BaseModel)</span>:</span></span><br><span class="line">    stock_name: str = Field()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StockPriceQueryTool</span><span class="params">(BaseTool)</span>:</span></span><br><span class="line">    name = <span class="string">"StockPriceQuery"</span></span><br><span class="line">    description = <span class="string">"useful for when you need to answer questions about the price of a stock code"</span></span><br><span class="line">    args_schema: Type[BaseModel] = StockQueryInput</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_run</span><span class="params">(self, stock_name: str, run_manager: Optional[CallbackManagerForToolRun] = None)</span> -&gt; str:</span></span><br><span class="line"></span><br><span class="line">        stock_code = StockCodeMapping.get(stock_name)</span><br><span class="line">        sina = Sina(stock_code)</span><br><span class="line">        res = sina.get_current_price()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"当前时间<span class="subst">&#123;res[<span class="string">'date'</span>]&#125;</span> <span class="subst">&#123;res[<span class="string">'time'</span>]&#125;</span>，<span class="subst">&#123;res[<span class="string">'name'</span>]&#125;</span>的价格是<span class="subst">&#123;res[<span class="string">'new'</span>]&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">_arun</span><span class="params">(self, query: str, run_manager: Optional[AsyncCallbackManagerForToolRun] = None)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">"StockPriceQueryTool does not support async"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">llm = ChatOpenAI(temperature=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">tools = [StockPriceQueryTool(), ]</span><br><span class="line">agent = initialize_agent(tools, llm, agent=AgentType.ZERO_SHOT_REACT_DESCRIPTION, verbose=<span class="literal">True</span>)</span><br><span class="line">agent.run(<span class="string">"科大讯飞现在的股价是多少，什么时间的数据？"</span>)</span><br></pre></td></tr></table></figure><p>代码非常简单，核心就是继承BaseTool这个父类，以实现自定义。</p><p>打开调试模式，我们看看LangChain都干了些什么，见下图：</p><p><img src="//s3.mindex.xyz/blog/Notes/7455c3613be0d6748f24b30814cd3b7c.png" alt=""></p><p>LangChain大概的心理活动可能是：</p><ul><li>哦，任务来了，我需要提供科大讯飞的当前股价</li><li>我该找谁问呢？哦，股票的事情要问StockPriceQueryTool</li><li>StockPriceQueryTool.run(“科大讯飞”)</li><li>哦，答案来了，“当前时间2023-05-12 14:30:48，科大讯飞的价格是63.930”</li><li>这个答案完美，我组织一下语言</li></ul><p>是不是很酷？</p><h2 id="尾声">尾声</h2><p>其实笔者在LLM爆发前夜，实现了一个小型的ChatBot，利用的是NLP组合技，感兴趣的朋友看<a href="http://neo1989.net/HandMades/HANDMADE-build-a-cool-chatbot-step-by-step/" title="如何构建自己的ChatBot">这里</a></p><p>LangChain到这里就介绍完了。会不会不重要，重要的是它背后的思想。</p><p>猴子变成人，是因为学会了使用工具。既然新的工具出现了，要不要变一下？</p><p>Peace out。</p>]]></content>
    
    <summary type="html">
    
      学习使我快乐。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
      <category term="AI" scheme="https://neo1989.net/tags/AI/"/>
    
      <category term="LLM" scheme="https://neo1989.net/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>LangChain | 快速释放LLMs的能力 (二)</title>
    <link href="https://neo1989.net/Notes/NOTE-langchain-2/"/>
    <id>https://neo1989.net/Notes/NOTE-langchain-2/</id>
    <published>2023-05-09T15:18:31.000Z</published>
    <updated>2023-05-10T05:08:17.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="TL-DR">TL;DR</h2><p>本文介绍了一种方法，让LLM拥有了学习新知识的能力。</p><h2 id="结果展示">结果展示</h2><p>LLM的训练是通过大量已有的数据进行学习，由于训练的难度和高额的成本，通常情况它是无法知道最新的时事的，于是它会胡编乱造，也就是是所谓的“幻觉”。如下图所示：<br><img src="//s3.mindex.xyz/blog/Notes/cd9244074883f119f2e21f77745dc193.png" alt="胡编乱造，但像模像样"></p><p>而通过提供资料让它学习，比如作者提供了以下两篇关于<code>星火大模型</code>的新闻稿给它学习:</p><ul><li><a href="https://new.qq.com/rain/a/20230508A01E8200" target="_blank" rel="noopener" title="腾讯网关于星火大模型的报道">腾讯网：星火认知大模型发布，科大讯飞入场科技巨头AI大战？</a></li><li><a href="https://finance.stockstar.com/IG2023050900014747.shtml" target="_blank" rel="noopener" title="证券之星关于星火大模型的报道">证券之星：科大讯飞星火认知大模型发布 AI 星火营生态计划同步开启</a></li></ul><p>于是它便能很好的回答相关的问题了。如下图所示：</p><p><img src="//s3.mindex.xyz/blog/Notes/fd3e43f90ecfa7ea380c69331c93bcfa.png" alt="它是真的在学习"></p><h2 id="如何实现">如何实现</h2><p>上一篇文章已经介绍了利用LangChain的基本操作实现了一个对任意文本进行总结的小应用。<br>本篇便是在前一篇的基础上引入了<code>embedding</code> 和 <code>vectorstore</code> 这两个核心能力来实现上述能力。</p><p>先说一下伪代码，流程如下图所示:</p><ul><li>加载文档</li><li>将文档分割成文本块</li><li>对文本块进行 <code>Embedding</code></li><li>将上述结果，也就是<code>Vectors</code>，存到向量数据库中</li><li>对用户的 <code>Query</code> 进行 <code>Embedding</code>, 生成 <code>Query Vector</code></li><li>在向量数据库中，利用向量similarity查询出 相关的文本块</li><li>将上述文本块，套上 <code>Prompt Template</code>，生成最终的<code>Prompt</code></li><li>丢给<code>LLM</code>，得到回答</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/cc18b036c98679aafe101d7c47a529d5.png" alt=""></p><p>接下来看看LangChain是如何便捷的实现上述功能的。核心代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> SpacyTextSplitter</span><br><span class="line"><span class="keyword">from</span> langchain.embeddings.openai <span class="keyword">import</span> OpenAIEmbeddings</span><br><span class="line"><span class="keyword">from</span> langchain.vectorstores <span class="keyword">import</span> Chroma</span><br><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> RetrievalQA</span><br><span class="line"><span class="keyword">from</span> langchain.vectorstores.base <span class="keyword">import</span> VectorStoreRetriever</span><br><span class="line"></span><br><span class="line">doc = <span class="string">""</span></span><br><span class="line"></span><br><span class="line">text_splitter = SpacyTextSplitter(separator=<span class="string">"\n\n"</span>, pipeline=<span class="string">"zh_core_web_sm"</span>, chunk_size=<span class="number">200</span>)</span><br><span class="line">docs = text_splitter.create_documents([doc])</span><br><span class="line"></span><br><span class="line">embeddings = OpenAIEmbeddings(openai_api_version=<span class="string">'2020-11-07'</span>, model=<span class="string">"text-davinci-003"</span>)</span><br><span class="line">vectorstore = Chroma.from_documents(docs, embeddings, persist_directory=<span class="string">"vector_store"</span>)</span><br><span class="line"></span><br><span class="line">retriever = VectorStoreRetriever(vectorstore=vectorstore)</span><br><span class="line">qa = RetrievalQA.from_chain_type(llm=OpenAI(), chain_type=<span class="string">"refine"</span>, retriever=retriever)</span><br><span class="line"></span><br><span class="line">result = qa(&#123;<span class="string">"query"</span>: <span class="string">"星火认知大模型 是什么"</span>&#125;)</span><br><span class="line">result</span><br></pre></td></tr></table></figure><p>不超过10行的核心代码，是不是有手就会？</p><h2 id="什么是Embedding">什么是Embedding</h2><p>这里涉及到一点NLP的基础知识。</p><p>对于给定的一段自然语言文本，第一件事就是将其token化。所谓token就是分割出的一个字或一个词（中文场景）。</p><ul><li>给定：星火认知大模型是什么</li><li>按字：星/火/认/知/大/模/型/是/什/么</li><li>按词：星火/认知/大模型/是/什么</li></ul><p>当然还有其它的分割算法，这里按下不表。</p><p>Token化之后，如何表示呢，我们知道计算机只能处理数字，所以聪明的先驱们发明了利用一个包含很多小数的数组（也就是一组稠密向量）来表示文本。 Embedding 就是把文本变成向量的过程。</p><p>参考<a href="https://platform.openai.com/docs/guides/embeddings/what-are-embeddings" target="_blank" rel="noopener" title="OpenAI's text embeddings">OpenAI官方文档</a> ，Embeddings通常被用于以下场景：</p><ul><li>搜索（对结果集进行相关性排序）</li><li>聚类（对文本按照相关性进行分组）</li><li>分类（对文本按照标签相似度进行分类）</li><li>推荐（优先推荐相似度高的item）</li><li>异常检测（识别出相似度小的异常）</li><li>多样性衡量（对相似度的分布进行分析）</li></ul><p>那相似度是如何衡量的？就是计算两个向量之间的距离。距离近相关度高，距离远相关度低，就是这样。</p><h2 id="什么是VectorStore">什么是VectorStore</h2><p>顾名思义，向量数据库就是用来存储，检索，分析向量的数据库。</p><p>LangChain提供了非常多的选择，具体请<a href="https://python.langchain.com/en/latest/modules/indexes/vectorstores.html" target="_blank" rel="noopener" title="LangChain VectorStores">参考文档</a>。<br>本文示例中的<a href="https://www.trychroma.com/" target="_blank" rel="noopener" title="Chroma">Chroma</a>便是其中一种轻量级的，最近拿了$18M的种子轮。</p><h2 id="尾声">尾声</h2><p>另一个简单的示例，看起来已经可以拿去干点什么了。但LangChain的能力不止如此，我们下一篇再看。</p><p>Peace out。</p>]]></content>
    
    <summary type="html">
    
      学习使我快乐。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
      <category term="AI" scheme="https://neo1989.net/tags/AI/"/>
    
      <category term="LLM" scheme="https://neo1989.net/tags/LLM/"/>
    
  </entry>
  
  <entry>
    <title>LangChain | 快速释放LLM的能力 (一)</title>
    <link href="https://neo1989.net/Notes/NOTE-langchain/"/>
    <id>https://neo1989.net/Notes/NOTE-langchain/</id>
    <published>2023-05-08T05:56:52.000Z</published>
    <updated>2023-05-08T13:26:29.809Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是LangChain">什么是LangChain</h2><p>其实就是用于开发基于LLM应用程序的开发框架。<br>一个强大的应用程序肯定不是只去调用LLM的API，于是LangChain便提供了两个核心的能力：</p><ul><li>有数据意识：将LLM与其他数据源连接起来</li><li>掌握主动权：允许LLM同运行环境交互</li></ul><p><img src="http://s3.mindex.xyz/blog/Notes/c151520a5f0042caff5ecb39519eed17.png" alt=""></p><h2 id="LangChain的组件">LangChain的组件</h2><p>LangChain提供了模块化抽象，用于处理与语言模型相关的组件。LangChain还拥有所有这些抽象的实现集合。这些组件被设计成易于使用，无论您是否使用LangChain框架的其余部分。</p><h3 id="Models">Models</h3><p>LangChain提供了各种不同类型的模型，方便集成和使用。如 LLMs、Chat Models、Text Embedding Models。</p><h3 id="Prompts">Prompts</h3><p>如你所知，跟模型打交道的方式便是prompt。通常prompt很少是硬编码的，而是通过多个组件搭建起来的。LangChain提供了多个类和方法，使的结合PromptTemplate构建prompts变得容易。</p><h3 id="Chains">Chains</h3><p>对于一些简单的应用来说，孤立地使用LLM是没有问题的，但许多更复杂的应用需要将LLM串联起来。LangChain提供了标准的接口，可以轻松的创建和管理链，以便更好的控制模型的输出。</p><h3 id="Agents">Agents</h3><p>有些应用不仅需要一个预先确定的调用LLM/其他工具的链，而且可能需要一个取决于用户输入的未知链。在这些类型的链中，有一个 “代理”，它可以访问一整套的工具。根据用户的输入，代理可以决定调用这些工具中的哪个（如果有的话）。</p><p><img src="http://s3.mindex.xyz/blog/Notes/bb20e5c953c69766556b713226d80125.png" alt=""></p><h3 id="Memory">Memory</h3><p>默认情况下，链和代理是无状态的，这意味着它们会独立处理每个传入的查询（正如底层的LLM和聊天模型）。在一些应用中（聊天机器人就是一个很好的例子），记住以前的互动是非常重要的，无论是短期的还是长期的。LangChain提供了方便的Memory组件和简单的方法以集成到应用程序中。</p><h3 id="Indexes">Indexes</h3><p>索引指的是结构化文件的方法，以便LLM能够与它们进行最好的交互。<br>使用索引通常是在检索这一步发生的。即返回与用户的输入最相关的文档。LangChain支持的主要索引和检索类型是围绕着向量数据库进行的。<br>这部分包含的模块有：</p><ul><li>Document Loaders： 文档加载器，可以从各种源头加载文档</li><li>Text Splitters: 文本分割</li><li>VectorStores：向量存储</li><li>Retrievers：检索</li></ul><h2 id="LangChain实战">LangChain实战</h2><p>基本的介绍如上，详细内容请参考<a href="https://python.langchain.com/en/latest/" target="_blank" rel="noopener" title="LangChain">官方文档</a>，LearnByDoing才是正经事。</p><p>一个很简单的需求，对任意文章进行总结并输出。核心代码及部分注释如下, 10行代码搞定长文本总结：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相关依赖</span></span><br><span class="line"><span class="comment"># tiktoken==0.4.0</span></span><br><span class="line"><span class="comment"># openai==0.27.6</span></span><br><span class="line"><span class="comment"># langchain==0.0.161</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> OpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> SpacyTextSplitter</span><br><span class="line"><span class="keyword">from</span> langchain.chains.summarize <span class="keyword">import</span> load_summarize_chain</span><br><span class="line"></span><br><span class="line">doc = <span class="string">""</span>  <span class="comment"># 文章内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定文本分割器，使用Spacy的中文模型</span></span><br><span class="line">text_splitter = SpacyTextSplitter(separator=<span class="string">"\n\n"</span>, pipeline=<span class="string">"zh_core_web_sm"</span>, chunk_size=<span class="number">200</span>)</span><br><span class="line">texts = text_splitter.create_documents([doc])</span><br><span class="line"></span><br><span class="line">llm = OpenAI(model_name=<span class="string">"text-davinci-003"</span>, max_tokens=<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">tokens_num = llm.get_num_tokens(doc)  <span class="comment"># 计算文档需要多少token</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建总结链</span></span><br><span class="line">chain = load_summarize_chain(llm, chain_type=<span class="string">"map_reduce"</span>, verbose=<span class="literal">True</span>)</span><br><span class="line">output = chain.run(texts)</span><br><span class="line"></span><br><span class="line">output</span><br></pre></td></tr></table></figure><p>于是便可以很方便的集成进任意应用程序了。<br><img src="http://s3.mindex.xyz/blog/Notes/769492ddeaa20d8f26395bbe2ce9ffd3.png" alt="愚苏记示例"></p><h2 id="结尾">结尾</h2><p>一个简单的示例，但足以体现LLM的强大以及LangChain的便捷。接下来笔者将尝试在更复杂的应用场景下使用LangChain解决更复杂的问题，Peace out。</p>]]></content>
    
    <summary type="html">
    
      打不过就加入。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
      <category term="AI" scheme="https://neo1989.net/tags/AI/"/>
    
      <category term="ChatGPT" scheme="https://neo1989.net/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>ChatGPT核心技术的进化之路</title>
    <link href="https://neo1989.net/Notes/NOTE-gpt-history/"/>
    <id>https://neo1989.net/Notes/NOTE-gpt-history/</id>
    <published>2023-04-23T08:25:31.000Z</published>
    <updated>2023-04-25T07:52:45.493Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>我们面临这样一个时代的机会。它既是机会，也是挑战。</p></blockquote><h2 id="TL-DR">TL;DR</h2><p>本文简单梳理了GPT系列的核心工作，从GPT-1到InstructGPT，帮助理解GPT的发展过程。</p><h2 id="GPT-1-2018">GPT-1 | 2018</h2><p><a href="https://cdn.openai.com/research-covers/language-unsupervised/language_understanding_paper.pdf" target="_blank" rel="noopener" title="GPT-1">GPT-1</a> 这篇论文提出了“Unsupervised pre-training + Supervised fine-tuning”核心架构，即首先使用大量未标记的文本数据来训练语言模型，然后使用标记数据来微调模型，以便更好地完成特定的判别性任务。</p><p>在 GPT 出现之前，NLP 的无监督预训练方法确实很长一段时间都是基于 WordVec 的模型，如 CBOW 和 SkipGram 等。这些模型主要的目的是通过在上下文中共现的词汇之间建立近似的距离关系，从而对自然语言进行表示和分析。</p><p>但词向量的模型的主要局限是一个词的向量表示没有考虑在不同的上下文环境里词的含义不同。 因此后续进化出了模型如 ELMo，使用双向 LSTM 对句子建模，得到前向和后向两种特征表示，然后将这两种特征表示拼接起来，作为最终的词向量表示，从而能够较好的处理多义词问题。</p><p>然而 ELMo 模型存在计算开销大，对上下文建模和长程依赖较弱，并且本身只能获得句子语义表示等一定的缺陷与局限性。 于是 Transformer 崛起，BERT 和 GPT 便是基于 Transformer 的杰出改进成果。</p><p>BERT 在训练过程中采用了 Masked Language Model(MLM) 和 Next Sentence Prediction(NSP) 任务使得两个方向的上下文信息保持一致，以更好的捕捉全局的语义信息。</p><p>区别于 BERT，GPT 的无监督预训练阶段，使用的是多层 Transformer Decoder，在对某个位置 i 的 token 进行预测时，利用 i 之前的所有 token 的信息输入 Transformer 进行编码，输出一个条件概率分布来预测 i 位置的 token.</p><p><img src="http://s3.mindex.xyz/blog/Notes/9cfe2357f08d51c4e2fe95f113ecefd0.png" alt="unsupervised pre-training | GPT"></p><p>在完成 GPT 的预训练，就进入有监督微调阶段。在特定的任务中使用标记数据微调模型，见下图右.</p><p><img src="http://s3.mindex.xyz/blog/Notes/cf4aa7093b4248108d916c90254f981f.png" alt="GPT summary"></p><p>概括下来，GPT-1 的核心是通过在大量未标记文本语料库上对语言模型进行生成式预训练(generative pre-training)，然后对每个特定任务进行判别性微调(discriminative fine-tuning)，来提高自然语言理解能力。</p><h2 id="GPT-2-2019">GPT-2 | 2019</h2><p><a href="https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf" target="_blank" rel="noopener" title="GPT-2">GPT-2</a> 展现出的能力是在特定的数据集上训练时，能够在没有明确监督的情况下学习特定的任务，即 Zero-shot learning。GPT-2 表明在极限情况下，预训练技术能够学习直接执行任务，而不需要监督适应或者修改。</p><p>下图表明 GPT-2 在多个任务上进行了实验的结果，表明 GPT-2 只有在具有足够的容量时才能够在许多典型的任务上取得良好的零样本表现。<br><img src="http://s3.mindex.xyz/blog/Notes/45a1d879b6ffd17674d83c06e15556a7.png" alt="performance | GPT-2"></p><p>虽然 GPT-2 的零样本表现为很多任务建立了 baseline，但并不清楚 fine-tuning 的上限。于是沿着 GPT-2 的思路，诞生了 GPT-3.</p><h2 id="GPT-3-2020">GPT-3 | 2020</h2><p><a href="https://arxiv.org/abs/2005.14165" target="_blank" rel="noopener" title="GPT-3">GPT-3</a> 便沿着 GPT-2 的思路，思考如何让下游任务更好的适配预训练语言模型。<br>首先他们在无监督预训练阶段，加入了&quot;in-context learning&quot;。简单讲就是模型在不更新自身参数的情况下，通过在模型输入中代入新任务的描述和少量样本，就能让模型“学习”的新任务的特征。<br><img src="http://s3.mindex.xyz/blog/Notes/c74565286e6ebba3d5ebaed295769bb1.png" alt=""></p><p>GPT-3 没有使用 fine-tuning，而是在 in-context learning 阶段尝试了三种设定：Zero-sot，One-shot 以及 Few-shot。Prompt 便是在这个阶段加入的。<br><img src="http://s3.mindex.xyz/blog/Notes/25962a81939bed0c6b631ddefab0a633.png" alt=""></p><p>其次，他们使用了更多、更高质量的语料，训练出了更大的模型。<br><img src="http://s3.mindex.xyz/blog/Notes/f67772aa8935bf2630356cdcf701d30c.png" alt=""></p><p>GPT-3 一经发布，便引起了学术界产业界爱好者们前沿的广泛讨论, 列举几篇</p><ul><li><a href="https://www.huxiu.com/article/385064.html" target="_blank" rel="noopener" title="虎嗅的：与 GPT-3 对话：它的回答令人细思极恐">虎嗅的：与 GPT-3 对话：它的回答令人细思极恐</a></li><li><a href="https://zhuanlan.zhihu.com/p/334340996" target="_blank" rel="noopener" title="AI TIME：地表最强的 GPT-3，是在推理，还是胡言乱语？">AI TIME：地表最强的 GPT-3，是在推理，还是胡言乱语？</a></li><li><a href="https://mp.weixin.qq.com/s/Lp93p0sYJcw42JPG6ItEYg" target="_blank" rel="noopener" title="新智元：GPT-3 真是人工智能「核武器」吗？花 1200 万美元训练却没能通过图灵测试">新智元：GPT-3 真是人工智能「核武器」吗？花 1200 万美元训练却没能通过图灵测试</a></li></ul><p>研究者们也在论文中提出了一些关于 GPT-3 的担忧。</p><ul><li>语言模型的滥用</li><li>公平性、偏见上的挑战</li><li>资源消耗巨大</li></ul><p>当然，困难是不会打倒开拓者们的。</p><h2 id="InstructGPT-2022">InstructGPT | 2022</h2><p><a href="https://cdn.openai.com/papers/Training_language_models_to_follow_instructions_with_human_feedback.pdf" target="_blank" rel="noopener" title="InstructGPT">InstructGPT</a> 的核心是如何让 GPT 生成的回答更符合人类的需求。而该模型引入了一种名为 <a href="https://arxiv.org/abs/2204.05862" target="_blank" rel="noopener" title="RLHF">RLHF</a> 的方法来进行微调。结果表明，InstructGPT 模型的输出比 GPT-3 更受欢迎，而且更真实，更少的有毒输出。利用 RLHF 微调，是使语言模型与人类意图保持一致的一个有前途的方向。</p><p>概括起来就三个步骤</p><ul><li>预训练一个语言模型 (LM)，并在高质量 prompt 数据集上进行有监督微调</li><li>聚合对比数据并训练一个奖励模型 (Reward Model，RM)</li><li>用强化学习 (RL) 方式微调 LM</li></ul><p><img src="http://s3.mindex.xyz/blog/Notes/73e84a5630105ccd9d034ce8a24d943b.png" alt=""></p><p>于是，GPT 便朝着人类期望的方向不断的进化了。</p><h2 id="ChatGPT-2022-末">ChatGPT | 2022 末</h2><p>2022 年 11 月 30 日，OpenAI 发布了一个通过由 GPT-3.5 系列 LLM 微调而成的全新对话式 AI 工具 ChatGPT，掀起了人工智能的热潮。</p><h2 id="拐点已至-2023">拐点已至 | 2023</h2><ul><li><p>OpenAI 获得微软投资 100 亿美元</p></li><li><p><a href="https://www.microsoft.com/en-gb/bing" target="_blank" rel="noopener" title="New Bing 发布">Feb 7, New Bing 发布</a></p></li><li><p><a href="https://openai.com/research/gpt-4" target="_blank" rel="noopener" title="GPT-4 发布">Mar 14, GPT-4 发布</a></p></li><li><p><a href="https://www.anthropic.com/index/introducing-claude" target="_blank" rel="noopener" title="Claude 发布">Mar 14, Claude 发布</a></p></li><li><p><a href="https://github.com/features/preview/copilot-x" target="_blank" rel="noopener" title="Copilot-X 发布">Mar 22, Copilot-X 发布</a></p></li><li><p><a href="https://openai.com/blog/chatgpt-plugins" target="_blank" rel="noopener" title="ChatGPT-plugins 发布">Mar 23, ChatGPT-plugins 发布</a></p></li></ul><h2 id="One-More-Thing">One More Thing</h2><p>文章开头引用来自于陆奇最新演讲<a href="https://mp.weixin.qq.com/s/_ZvyxRpgIA4L4pqfcQtPTQ" target="_blank" rel="noopener" title="我的大模型世界观">《我的大模型世界观》</a> ，利用AI总结了以下几点take-away:</p><ul><li>大模型时代的发展速度非常快，甚至他自己都跟不上</li><li>OpenAI在大模型领域处于领先地位，并且未来有可能比Google更大</li><li>未来是一个模型无处不在的时代</li><li>大模型时代对每个人都将产生深远和系统性影响，每个人很快将有副驾驶员</li><li>陆奇认为，创业公司基本上有三类：数字化技术、满足人类需求和改变世界</li></ul><p>如果您还未能将使用ChatGPT等AI作为习惯，我感到非常遗憾。</p><p>如果您还没有使用 ChatGPT 的渠道，关注这个公众号👇并打招呼，可以获取使用入口。</p>]]></content>
    
    <summary type="html">
    
      打不过就加入。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
      <category term="AI" scheme="https://neo1989.net/tags/AI/"/>
    
      <category term="ChatGPT" scheme="https://neo1989.net/tags/ChatGPT/"/>
    
  </entry>
  
  <entry>
    <title>日落收集</title>
    <link href="https://neo1989.net/SeizeTheDay/COLLECTION-sunsets/"/>
    <id>https://neo1989.net/SeizeTheDay/COLLECTION-sunsets/</id>
    <published>2023-03-04T14:34:15.000Z</published>
    <updated>2023-05-13T14:11:06.947Z</updated>
    
    <content type="html"><![CDATA[<h3 id="May-13-2023">May 13, 2023</h3><p><img src="//s3.mindex.xyz/blog/Notes/02be63a08b4d3f50fe9f022c13f21291.png" alt="清水路/环湖大道 | 苏州"></p><h3 id="Apr-15-2023">Apr 15, 2023</h3><p><img src="//s3.mindex.xyz/blog/Notes/97765437415756031a4b064691e3fc5e.png" alt="清水路/环湖大道 | 苏州"></p><h3 id="Mar-11-2023">Mar 11, 2023</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/d1c296dc199be5df7087034673e4267a.png" alt="On the Rock @ NamPhrae | Thailand"></p><h3 id="Mar-10-2023">Mar 10, 2023</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/3454d0d46192236de9293e1261e6a65c.png" alt="Route 107 | Thailand"></p><h3 id="Mar-4-2023">Mar 4, 2023</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/7d8d79718363def5e1f35fc64c131589.png" alt="米堆山 | 苏州"></p><h3 id="Jan-30-2023">Jan 30, 2023</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/cb9d279f773c498fb81893d84e3801a1.png" alt="滨江中路 | 上海"></p><h3 id="Nov-8-2022">Nov 8, 2022</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/2e7efec1c357cc31f2d9d9111263fcf6.png" alt="自家楼顶 | 上海"></p><h3 id="Oct-29-2022">Oct 29, 2022</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/480778a07a8ad62f4667758d7b9f1838.png" alt="自家阳台 | 上海"></p><h3 id="Oct-21-2022">Oct 21, 2022</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/60a5da12bed4e3378b8b06b131961ada.png" alt="望金路 | 苏州"></p><h3 id="Oct-12-2022">Oct 12, 2022</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/ea79b3cb30dbbd25b2a8f50cdc6e787e.png" alt="隔离酒店 | 上海"></p><h3 id="Oct-3-2022">Oct 3, 2022</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/a64244c75a29eb7f5229965d1019dd9f.png" alt="新巴尔虎左旗 | 呼伦贝尔"></p><h3 id="Sept-9-2022">Sept 9, 2022</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/588fe20a7f83e4ebea9248bffc3c02cd.png" alt="正大立方大厦 | 上海"></p><h3 id="Aug-12-2022">Aug 12, 2022</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/256ec6bd4be58d507b83a7674bbf3e5d.png" alt="陆家嘴 | 上海"></p><h3 id="Jul-2-2022">Jul 2, 2022</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/5b3a941292b14a6ed57e5d8472e4d166.png" alt="淀峰村 | 上海"></p><h3 id="Feb-26-2022">Feb 26, 2022</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/ed0aed30bd1f5eb7e812f6b910e2d272.png" alt="广富林郊野公园 | 上海"></p><h3 id="Feb-5-2022">Feb 5, 2022</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/252a930e286996cb70257dc33cdfd179.png" alt="申嘉湖高速 | 嘉兴"></p><h3 id="Dec-19-2021">Dec 19, 2021</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/20658e52339f61f6fa2cacc6378f1597.png" alt="望金路 | 苏州"></p><h3 id="Oct-23-2021">Oct 23, 2021</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/096adcde8f85c1e11e0935ec5c1c33b8.png" alt="广富林郊野公园 | 上海"></p><h3 id="Oct-5-2021">Oct 5, 2021</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/431a40cf0e17f31eca88b6d183bf0977.png" alt="小柴旦湖 | 海西"></p><h3 id="Oct-2-2021">Oct 2, 2021</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/c0d17cf3a1e1d0ce86aef91b63b49166.png" alt="黑独山 | 海西"></p><h3 id="Sept-21-2021">Sept 21, 2021</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/8150b4294afbf75dce10bd0e35c53328.png" alt="望金路 | 苏州"></p><h3 id="Sept-5-2021">Sept 5, 2021</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/cfe9e81ec7bb7732d7c37059e7719356.png" alt="望金路 | 苏州"></p><h3 id="Oct-5-2020">Oct 5, 2020</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/d9332c6fae74c9383402562a60efd961.png" alt="石头公园 | 文昌"></p><h3 id="Aug-30-2020">Aug 30, 2020</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/bf9d8d69f72adfa310a5e43609ffe447.png" alt="家附近 | 上海"></p><h3 id="Jul-28-2019">Jul 28, 2019</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/74b15296714f1663e085455cf6203a36.png" alt="欢乐谷 | 上海"></p><h3 id="Jun-16-2019">Jun 16, 2019</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/6c4c12c624df285655f099d06dc25497.png" alt="中谭路 | 上海"></p><h3 id="Apr-27-2019">Apr 27, 2019</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/69ab3d05f731687f45ddbfb7a101b883.png" alt="直岛 | 日本"></p><h3 id="Sept-9-2018">Sept 9, 2018</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/39920b32a2d354c61351c98100d5d341.png" alt="松江新城 | 上海"></p><h3 id="Jul-14-2018">Jul 14, 2018</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/1d03b9cc2dad2f2a729a619a34d9ea14.png" alt="中谭路 | 上海"></p><h3 id="May-11-2017">May 11, 2017</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/5722cafa310b4aeb6aedcf4dbbe07543.png" alt="Baiyoke Tower | Bankok"></p><h3 id="May-4-2017">May 4, 2017</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/75728df9ad538b27fdaf54abf50d6534.png" alt="Lanta | Krabi"></p><h3 id="May-3-2017">May 3, 2017</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/a90e458e957d32e3bcc8a54fe7870ccc.png" alt="Lanta | Krabi"></p><h3 id="May-1-2017">May 1, 2017</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/6bcd6f83a888c1beb19625c29e47f7d3.png" alt="Patong | Phuket"></p><h3 id="Apr-22-2017">Apr 22, 2017</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/15dc820477de2bc560c2f4495f8f913e.png" alt="陆家嘴金融广场 | 上海"></p><h3 id="Oct-5-2016">Oct 5, 2016</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/70da8fd8fa5ef68c87b457bc1165b69e.png" alt="家楼顶 | 官港"></p><h3 id="Mar-31-2016">Mar 31, 2016</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/bd759acc6ffdcad5637434f94911b3ea.png" alt="曾厝垵 | 厦门"></p><h3 id="Mar-6-2016">Mar 6, 2016</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/eb64a0ff6ac66640838a0eea11eaa59d.png" alt="康桥 | 上海"></p><h3 id="Feb-20-2016">Feb 20, 2016</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/dbeaec79d916ce1f60a75f3afef56d69.png" alt="淮海中路 | 上海"></p><h3 id="Jan-25-2016">Jan 25, 2016</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/27e5876049c7553a7cd3062d692679e0.png" alt="浦软 | 上海"></p><h3 id="Sept-24-2015">Sept 24, 2015</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/1e9de7867582054def65e0a6e12c337c.png" alt="浦软 | 上海"></p><h3 id="Jan-15-2014">Jan 15, 2014</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/a87b05e7aeeb54bc490bc283fbec81af.png" alt="创智天地 | 上海"></p><h3 id="Oct-3-2013">Oct 3, 2013</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/3fd71e4380cd0024aa7967dcbe0b3c1a.png" alt="阳朔 | 桂林"></p><h3 id="May-11-2013">May 11, 2013</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/825ec397bfc4623828ed3eb7566ead05.png" alt="广储门 | 扬州"></p><h3 id="Mar-3-2013">Mar 3, 2013</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/9614bee33966b93edfdaebd9ba865da8.png" alt="世纪公园 | 上海"></p>]]></content>
    
    <summary type="html">
    
      日落尤其温柔，人间皆是浪漫。
    
    </summary>
    
    
      <category term="SeizeTheDay" scheme="https://neo1989.net/categories/SeizeTheDay/"/>
    
    
  </entry>
  
  <entry>
    <title>A Demo of the CNN LSTM</title>
    <link href="https://neo1989.net/HandMades/HANDMADE-CNN-LSTM-try/"/>
    <id>https://neo1989.net/HandMades/HANDMADE-CNN-LSTM-try/</id>
    <published>2023-02-15T02:00:17.000Z</published>
    <updated>2023-04-25T07:55:44.420Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>The moving square video prediction problem is contrived to demonstrate the CNN LSTM. The problem involves the generation of a sequence of frames. In each image a line is drawn from left to right or right to left. Each frame shows the extension of the line by one pixel. The task is for the model to classify whether the line moved left or right in the sequence of frames.Technically, the problem is a sequence classification problem framed with a many-to-one prediction model.</p></blockquote><p>&quot;Moving Square Video Prediction&quot;是<a href="https://machinelearningmastery.com/lstms-with-python/" target="_blank" rel="noopener">《Long Short-Term Memory Networks With Python》</a> 这本书里的一个示例。我在这里做了一下扩展，将其变成一个多分类问题。</p><h3 id="The-Problem">The Problem</h3><p>问题定义为一个帧序列，从边缘开始每多一帧就增加一个像素点，以展示朝某个方向延伸的一条线（从上到下，从下到上，从左到右，从右到左）。<br>模型的任务就是预测这条线是如何运动的。<br>很明显，这就是一个many-to-one的分类任务。输入帧序列，输出单个标签（<a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="noopener">图片来源</a>）。</p><p><img src="//s3.mindex.xyz/blog/Notes/faf00c2f0f3277b8c0c8e95a7d504552.png" alt="Recurrent Neural Networks"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码示例</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint, random, choice</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line"></span><br><span class="line">directions = [<span class="string">"Up"</span>, <span class="string">"Down"</span>, <span class="string">"Left"</span>, <span class="string">"Right"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_frame</span><span class="params">(last_step, last_frame, row=None, col=None)</span>:</span></span><br><span class="line">    lower = max(<span class="number">0</span>, last_step<span class="number">-1</span>)</span><br><span class="line">    upper = min(last_frame.shape[<span class="number">0</span>]<span class="number">-1</span>, last_step+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    step = randint(lower, upper)</span><br><span class="line"></span><br><span class="line">    frame = last_frame.copy()</span><br><span class="line">    <span class="keyword">if</span> row <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        frame[row, step] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> col <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        frame[step, col] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> frame, step</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_frames</span><span class="params">(size)</span>:</span></span><br><span class="line">    frames = list()</span><br><span class="line"></span><br><span class="line">    frame = np.zeros((size, size))</span><br><span class="line">    step = randint(<span class="number">0</span>, size<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    towards = choice(directions)</span><br><span class="line">    <span class="keyword">if</span> towards <span class="keyword">in</span> [<span class="string">"Up"</span>, <span class="string">"Down"</span>]:</span><br><span class="line"></span><br><span class="line">        down = <span class="number">1</span> <span class="keyword">if</span> towards == <span class="string">"Down"</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        row = <span class="number">0</span> <span class="keyword">if</span> down <span class="keyword">else</span> size<span class="number">-1</span></span><br><span class="line">        frame[row, step] = <span class="number">1</span></span><br><span class="line">        frames.append(frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">            row = i <span class="keyword">if</span> down <span class="keyword">else</span> size<span class="number">-1</span>-i</span><br><span class="line">            frame, step = next_frame(step, frame, row=row)</span><br><span class="line">            frames.append(frame)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right = <span class="number">1</span> <span class="keyword">if</span> towards == <span class="string">"Right"</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        col = <span class="number">0</span> <span class="keyword">if</span> right <span class="keyword">else</span> size<span class="number">-1</span></span><br><span class="line">        frame[step, col] = <span class="number">1</span></span><br><span class="line">        frames.append(frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">            col = i <span class="keyword">if</span> right <span class="keyword">else</span> size<span class="number">-1</span>-i</span><br><span class="line">            frame, step = next_frame(step, frame, col=col)</span><br><span class="line">            frames.append(frame)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> frames, towards</span><br><span class="line"></span><br><span class="line">size = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">frames, towards = build_frames(size)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f"Towards: <span class="subst">&#123;towards&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">pyplot.figure(figsize=[<span class="number">8</span>, <span class="number">8</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">    pyplot.subplot(size // <span class="number">10</span>, <span class="number">10</span>, i+<span class="number">1</span>)</span><br><span class="line">    pyplot.imshow(frames[i], cmap=<span class="string">'Greys'</span>)</span><br><span class="line">    ax = pyplot.gca()</span><br><span class="line">    ax.get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">pyplot.show()</span><br></pre></td></tr></table></figure><p><img src="//s3.mindex.xyz/blog/Notes/973e4cf02597baebd977e10eca8a6ce9.png" alt="显示运动方向为向上 (从左上到右下逐帧)"></p><h3 id="CNN-LSTM">CNN LSTM</h3><p>使用CNN层对输入数据进行特征提取, 使用LSTM来做序列预测。<br>这种架构还被用于语音识别和自然语言处理问题，其中CNN被用作音频和文本输入数据上的特征提取器，以供LSTM使用。<br>此架构适用于以下问题：</p><ul><li>在其输入中具有空间结构，例如 2D 结构或图像中的像素或句子，段落或文档中的单词的一维结构。</li><li>在其输入中具有时间结构，诸如视频中的图像的顺序或文本中的单词，或者需要生成具有时间结构的输出，诸如文本描述中的单词。</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/e018c5595051507361a05e2ecb6aa01d.png" alt="卷积神经网络长短期记忆网络架构"></p><h3 id="generate-examples">generate_examples</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder, OneHotEncoder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># label encode</span></span><br><span class="line">label_encoder = LabelEncoder()</span><br><span class="line">label_encoded = label_encoder.fit_transform(directions)</span><br><span class="line">label_encoded = label_encoded.reshape(len(directions), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># one hot encode</span></span><br><span class="line">onehot_encoder = OneHotEncoder(sparse=<span class="literal">False</span>)</span><br><span class="line">onehot_encoder.fit(label_encoded)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_examples</span><span class="params">(size, n_patterns)</span>:</span></span><br><span class="line">    X, y = list(), list()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n_patterns):</span><br><span class="line">        frames, towards = build_frames(size)</span><br><span class="line">        X.append(frames)</span><br><span class="line">        y.append(towards)</span><br><span class="line">    X = np.array(X).reshape(n_patterns, size, size, size, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    label_encoded = label_encoder.transform(np.array(y))</span><br><span class="line">    y = onehot_encoder.transform(label_encoded.reshape(len(label_encoded), <span class="number">1</span>)) </span><br><span class="line">    <span class="keyword">return</span> X, y</span><br></pre></td></tr></table></figure><h3 id="CNN-Model">CNN Model</h3><p>The Conv2D will interpret snapshots of the image (e.g. small squares) and the pooling layers will consolidate or abstract the interpretation.<br>We will define a Conv2D as an input layer with 2 filters and a 2 × 2 kernel to pass across the input images. The use of 2 filters was found with some experimentation and it is convention to use small kernel sizes. The Conv2D will output 2 49 × 49 pixel impressions of the input.</p><p>Convolutional layers are often immediately followed by a pooling layer. Here we use a MaxPooling2D pooling layer with a pool size of 2 × 2, which will in effect halve the size of each filter output from the previous layer, in turn outputting two 24 × 24 maps.</p><p>The pooling layer is followed by a Flatten layer to transform the [24,24,2] 3D output from the MaxPooling2D layer into a one-dimensional 1,152 element vector…</p><p>We want to apply the CNN model to each input image and pass on the output of each input image to the LSTM as a single time step.<br>We can achieve this by wrapping the entire CNN input model (one layer or more) in a TimeDistributed layer.</p><p>Next, we can define the LSTM elements of the model. We will use a single LSTM layer with 50 memory cells, configured after a little trial and error. The use of a TimeDistributed wrapper around the whole CNN model means that the LSTM will see 50 time steps, with each time step presenting a 1,152 element vector as input.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Conv2D</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> MaxPooling2D</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> LSTM</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Flatten</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> TimeDistributed</span><br><span class="line"></span><br><span class="line">size = <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define the model</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(TimeDistributed(Conv2D(<span class="number">2</span>, (<span class="number">2</span>, <span class="number">2</span>), activation=<span class="string">'relu'</span>), input_shape=(<span class="literal">None</span>, size, size, <span class="number">1</span>)))</span><br><span class="line">model.add(TimeDistributed(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>))))</span><br><span class="line">model.add(TimeDistributed(Flatten()))</span><br><span class="line">model.add(LSTM(<span class="number">50</span>))</span><br><span class="line">model.add(Dense(len(directions), activation=<span class="string">'softmax'</span>))</span><br><span class="line">model.compile(loss=<span class="string">'binary_crossentropy'</span>, optimizer=<span class="string">'adam'</span>, metrics=[<span class="string">'acc'</span>])</span><br><span class="line"></span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><p><img src="//s3.mindex.xyz/blog/Notes/22c2c8bfed7763a934fe6044eefac0e8.png" alt="Model Summary"></p><h3 id="fit-and-evaluate-the-model">fit and evaluate the model</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fit model</span></span><br><span class="line">X, y = generate_examples(size, <span class="number">5000</span>)</span><br><span class="line">model.fit(X, y, batch_size=<span class="number">32</span>, epochs=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># evaluate model</span></span><br><span class="line">X, y = generate_examples(size, <span class="number">100</span>)</span><br><span class="line">loss, acc = model.evaluate(X, y, verbose=<span class="number">0</span>)</span><br><span class="line">print(<span class="string">f"loss: <span class="subst">&#123;loss:<span class="number">.10</span>f&#125;</span> acc: <span class="subst">&#123;acc:<span class="number">.10</span>f&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><p><img src="//s3.mindex.xyz/blog/Notes/f09f8a2296dd060ce612753e82a28c1f.png" alt="fit &amp; evaluate"></p><h3 id="prediction">prediction</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prediction on new data</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    X, y = generate_examples(size, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    yhat = model.predict(X, verbose=<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">f"predict_i: <span class="subst">&#123;i&#125;</span>"</span>)</span><br><span class="line">    print(label_encoder.inverse_transform([np.argmax(y[<span class="number">0</span>, :])]), y)</span><br><span class="line">    print(label_encoder.inverse_transform(np.array([np.argmax(yhat[<span class="number">0</span>, :])])), yhat)</span><br></pre></td></tr></table></figure><p><img src="//s3.mindex.xyz/blog/Notes/f757cfdf47d2ecf0da2a4fe6c9a09e38.png" alt="predictions"></p><h3 id="Further-Reading">Further Reading</h3><ul><li><a href="https://keras.io/api" target="_blank" rel="noopener">Keras API.</a></li><li><a href="https://arxiv.org/abs/1411.4389" target="_blank" rel="noopener">Long-term Recurrent Convolutional Networks for Visual Recognition and Description, 2015.</a></li><li><a href="https://arxiv.org/abs/1411.4555" target="_blank" rel="noopener">Show and Tell: A Neural Image Caption Generator, 2015.</a></li><li><a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43455.pdf" target="_blank" rel="noopener">Convolutional, Long Short-Term Memory, fully connected Deep Neural Networks, 2015.</a></li><li><a href="https://arxiv.org/abs/1508.06615" target="_blank" rel="noopener">Character-Aware Neural Language Models, 2015.</a></li><li><a href="https://arxiv.org/abs/1506.04214" target="_blank" rel="noopener">Convolutional LSTM Network: A Machine Learning Approach for Precipitation Nowcasting, 2015.</a></li></ul>]]></content>
    
    <summary type="html">
    
      “只要学不死，就往死里学。”
    
    </summary>
    
    
      <category term="HandMades" scheme="https://neo1989.net/categories/HandMades/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
      <category term="DL" scheme="https://neo1989.net/tags/DL/"/>
    
      <category term="AI" scheme="https://neo1989.net/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>《为什么没人早点告诉我》</title>
    <link href="https://neo1989.net/Notes/NOTE-why-has-nobody-told-me-this-before/"/>
    <id>https://neo1989.net/Notes/NOTE-why-has-nobody-told-me-this-before/</id>
    <published>2023-02-13T01:59:49.000Z</published>
    <updated>2023-02-14T01:28:06.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="就是开心不起来怎么办">就是开心不起来怎么办</h3><h4 id="如何看待情绪低落">如何看待情绪低落</h4><ul><li>情绪有起伏波动是狠正常的，没有人能一直开兴。但我们不能被情绪控制，而应该去做一些有帮助的事情。</li><li>情绪低落并不是大脑出了问题，更可能是因为需求没有得到满足。</li><li>我们生活中的每一刻都可以拆解成体验的不同方面。</li><li>这些方面相互影响，向我们展示了我们是如何陷入情绪低落（甚至是抑郁）的恶性循环的。</li><li>我们的情绪是通过那些我们能影响的事情构建的。</li><li>情绪没有开关，我们也无法选择情绪，但我们可以利用可控的东西来改变自己的感受。</li><li>使用十字概念化这个工具（如下图所示）来培养觉察能力，注意哪些因素会影响我们的情绪，让我们深陷其中。</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/87e1ba72e2112f5c0b54a8843a4b41a7.png" alt="纠结于消极的想法很可能会让人情绪低落，而情绪低落又会催生出更多消极的想法。这张图很好地说明了我们是如何陷入情绪低落的恶性循环，同时也告诉我们，如何才能走出困境。"></p><h4 id="当心情绪陷阱">当心情绪陷阱</h4><ul><li>思维偏差是不可避免的，但对其负面影响，我们并不是无能为力。</li><li>我们会自然而然地寻找证据来证实自己的看法，并坚定地相信它，尽管有很多其他证据表明这种看法并不正确。</li><li>情绪低落是由什么引起的，都会让我们将注意力集中在威胁与消极因素上。</li><li>如果我们持续关注这些因素，并把它们当作事实，那么这种负面偏见就会中庸到我们身上，加剧情绪低落。</li><li>对抗这种恶性循环的策略就是要弄明白，感受并不能作为证据，它不能证明你的想法就是事实。</li><li>另一种策略是保持好奇、探究的态度。</li><li>通过了解常见的思维偏差类型，和这些想法保持距离，注意它们可能会在什么时候出现，时刻记住它们只是偏见，不是事实。</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/ee25c3fe40343a79901e40c4edefbebe.png" alt="思维偏差的种类及实例"></p><h4 id="怎么做才有用">怎么做才有用</h4><ul><li>我们无法控制突然出现在脑海中的想法，但我们可以控制注意力的聚焦点。</li><li>试图不去想某件事，只会让你想得更多。</li><li>允许所有想法的存在，但要确定哪些想法是值得投入时间和精力的，这对我们的情感体验有很大的影响。</li><li>正念练习与感恩练习能够训练我们转移注意力的能力。</li><li>当我们专注与一个问题的时候，也要关注我们前进的方向，以及我们想要如何感受，如何行动。</li><li>想法不是事实，想法只是大脑给出的意见，帮助我们理解这个世界。</li><li>一个想法对我们能有多大影响，取决于我们在多大程度上相信它是事实。</li><li>要从想法中汲取力量，就需要后退异步，与它保持一定的距离（元认知策略：注意到你的脑海中出现了哪些想法，并观察它们给你带来的感受的过程。），看清它的真实面目。</li></ul><h4 id="如何把糟糕的一天变成美好的一天">如何把糟糕的一天变成美好的一天</h4><ul><li>我们应该专注于做出好的决定，而不是完美的决定。以“足够好”为标准，会引导你做出真正的改变。完美主义会导致你瞻前顾后，难以做出选择，而要想改善情绪，你必须做出决定，采取行动。</li><li>改变可以从小事做起，要持之以恒。</li><li>别人情绪低落时，我们通常会表现得友好、体贴，因为我们知道这正是它们所需要的。所以当我们努力调节情绪和心理状态时，也应该练习自我关怀。</li><li>明白了这些，你就能以此为出发点，找到自己想要的方向，并专注于脚下的路。</li></ul><h4 id="防御，让你不被打倒的力量">防御，让你不被打倒的力量</h4><ul><li>守护心理健康的“守门员”为身心健康打下了基础。如果你每天都能照顾好它们，它们一定会给你丰厚的回报。</li><li>如果你今天只想给自己安排一件事，那就去运动吧。选择你喜欢的运动，这样更容易坚持。</li><li>睡眠与心理健康是相互作用的。高质量的睡眠对心理健康有益，改变心理状态也会促进睡眠。</li><li>你给大脑充电的方式会影响你的感受。研究表明，传统的<a href="https://zh.wikipedia.org/zh-hans/%E5%9C%B0%E4%B8%AD%E6%B5%B7%E9%A3%B2%E9%A3%9F" target="_blank" rel="noopener">地中海饮食</a>、<a href="https://zh.wikipedia.org/zh-hans/%E6%97%A5%E6%9C%AC%E6%96%99%E7%90%86" target="_blank" rel="noopener">日本饮食</a>与<a href="https://zh.wikipedia.org/zh-hans/%E6%8C%AA%E5%A8%81%E9%A3%B2%E9%A3%259https://zh.wikipedia.org/zh-hans/%E6%8C%AA%E5%A8%81%E9%A3%B2%E9%A3%9FF" target="_blank" rel="noopener">挪威饮食</a>对心理健康有益。</li><li>人与人的连接是强化复原力的有力工具。人际关系会改变你的身心状态。</li></ul><h3 id="做事提不起精神，没有动力怎么办">做事提不起精神，没有动力怎么办</h3><h4 id="理解驱动力">理解驱动力</h4><ul><li>驱动力并不是与生俱来的。</li><li>那种充满动力，想要去做某事的感觉不会一直存在，所以你不能依赖它。</li><li>要掌控你的驱动力，就是培养这样一种能力：无论你有多么不想做，你也会自动去做那些对你最重要的事。</li><li>拖延症通常是为了逃避压力和不适感。</li><li>快感缺失指的是我们现在无法从过去喜欢做的事中找到乐趣，通常和情绪低落、抑郁症有关。</li><li>如果有些事对你很重要，同时又对你的健康有益，那么现在就去做，不要等到你想做的时候才行动。</li></ul><h4 id="如何培养动机感">如何培养动机感</h4><ul><li>虽然我们无法控制动机感，但我们可以做一些事情来让自己更多地体验到动机感。</li><li>要培养动机感，得先让身体动起来。哪怕是少量的运动，也比完全不运动好，能让你充满动力。</li><li>与目标保持连接有助于持续激发驱动力。</li><li>从微小而持续的行动开始。</li><li>在压力环境中学会休息，补充能量，能最大程度地锻炼意志力。</li><li>羞耻感并不像你想的那样，能够让你产生驱动力。你要做的是改变你与失败的关系。</li></ul><h4 id="不想做一件事时，怎样才能让自己去做呢">不想做一件事时，怎样才能让自己去做呢</h4><ul><li>驱动力不是永远存在的。</li><li>我们可以练习与冲动相反的行为，我们要按照自己的价值观做事，而不是根据当下的感受。</li><li>只要重复的次数足够多，一个新的行为就能成为习惯。</li><li>要想实现远大的目标，在前进的道路上就必须休息、充电，就像优秀的运动员那样，这非常重要。</li><li>在实现目标的过程中，不断给自己小小的奖励。</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/31cfde9c9f710898c3d6388cf1fd70f3.png" alt="做出改变与维持现状的利弊"></p><h4 id="重大的人生改变，应该从哪里开始">重大的人生改变，应该从哪里开始</h4><ul><li>我们有时候并不清楚应该改变什么以及如何去改变。</li><li>没有对自我的理解，就无法改变。</li><li>彻底了解你的问题所在，才能更容易确定下一步应该怎么做。</li><li>事情发生后，先反思一下。</li><li>准备好诚实地面对：你是如何导致问题的出现，又是如何让自己陷入困境的。</li><li>心理治疗的过程能为你提供支持，如果你没机会看心理医生，也可以从记日记开始。</li></ul><h3 id="陷入痛苦情绪怎么办">陷入痛苦情绪怎么办</h3><h4 id="让情绪全部消失">让情绪全部消失</h4><ul><li>情绪既不是敌人，也不是朋友。</li><li>我们对自己的情绪状态的影响力笔我们以为的要大的很多。</li><li>抗拒情绪只会带来更多问题，我们不如接纳情绪，顺其自然。</li><li>情绪不是事实，只是一个可能的视角。</li><li>如果你现在有痛苦的情绪，保持好奇心，提出问题——情绪能告诉你什么？</li></ul><h4 id="如何处理情绪">如何处理情绪</h4><ul><li>感受不能代表你，你也不能等同于你的感受。</li><li>情绪的感受就是经由你身体的体验。</li><li>每种情绪都能给你提供信息，但这些信息并不全面。</li><li>情绪的作用就是告诉你，你需要什么。</li><li>当你感受到情绪时，就给它起个名字。情绪不仅包括快乐或悲伤，还应该有更细致的分类方式。</li><li>我们应该接纳情绪，而不是抗拒情绪。要学会自我安抚。</li></ul><h4 id="如何利用语言的力量">如何利用语言的力量</h4><ul><li>我们所使用的语言极大地影响这我们对世界的体验。</li><li>描述自己感受的词汇越多越好。</li><li>想不出合适的词语时，可以参考感受圆盘。</li><li>注意别人是如何用词的，你可以通过读书、看电影等多种凡是来扩大自己的情绪词汇量。</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/df5eae13d31c1027bd7bc01863922a4a.png" alt="在感受圆盘中找到能描述自己感受的词汇"></p><h4 id="当你关心的人陷入痛苦时">当你关心的人陷入痛苦时</h4><ul><li>当别人出现心理问题时，我们想去帮助他，但又觉得不知所措、力不从心，这是很正常的。</li><li>看到别人遭受痛苦，你想支持他，又怕自己说错话，这回让你很有压力，但一定不要因此回避他。</li><li>强有力的支持并不意味着要解决所有问题。</li><li>要照顾好自己，别让自己心力交瘁。维护自己的利益，设定清晰的界限。</li><li>永远不要低估倾听的力量。</li></ul><h3 id="无法走出悲伤怎么办">无法走出悲伤怎么办</h3><h4 id="理解悲伤">理解悲伤</h4><ul><li>那些对我们来说意义重大的事物的结束，都会引发悲伤——这种结束不一定是死亡。</li><li>悲伤是人类情感体验中很正常、自然的一部分。</li><li>痛苦可以是情绪上的，也可以是身体上的。</li><li>有帮助的事情并不会让痛苦小事，也不会迫使你放手。</li><li>完全回避悲伤可能会导致更深层次的问题。</li></ul><h4 id="悲伤的阶段">悲伤的阶段</h4><ul><li>否认能帮助我们承受住悲伤带来的痛苦。否认消退后，新的情绪会付出水面。</li><li>如果你无法控制愤怒的情绪，可以去做运动，利用生理唤醒，让身体暂时恢复平静。</li><li>反复思考“假如…现在会怎样”，很容易把自己引入自责的陷阱。</li><li>抑郁是失去亲人后的正常反应。</li><li>接受并不意味这你喜欢或认可现状。</li></ul><h4 id="哀悼的任务">哀悼的任务</h4><ul><li>治愈悲伤的第一步是允许自己感受痛苦。</li><li>我们需要时间来适应亲人已不复存在的生活。</li><li>我们需要找到一种方法，即使亲人不在了，也能继续和他们保持连接。</li><li>接受新的现实，我们才能继续去做那些对我们很重要的事。无论你有什么样的感受，都是正常的。</li><li>不要低估每一小步的作用，稳步前进。</li></ul><h4 id="力量的支柱">力量的支柱</h4><ul><li>时间、努力与坚持能帮合租你重建失去亲人后的生活。</li><li>通过新的方式与逝去的人保持连接，比如去你们一起去过的、有特殊意义的地方，或者去墓地悼念。</li><li>在整个过程中要尽可能地倾听自己的需求。</li><li>表达悲伤的方式无所谓对错。</li><li>不要规定自己必须多长时间走出悲伤。</li></ul><h3 id="低自尊人格，经常自我怀疑怎么办">低自尊人格，经常自我怀疑怎么办</h3><h4 id="如何看待别人的批评与否定">如何看待别人的批评与否定</h4><ul><li>学习正确地看待批评与否定，这是一项重要的生活技能。</li><li>我们天生就在乎别人对我们的看法，说“我不在乎任何人的想法”的人都不是真心的。</li><li>取悦别人绝不是表面上的与人为善，而是在任何情况下都把别人的需求置于自己的需求之上，甚至不惜损害自己的健康和幸福。</li><li>要理解为什么有些人总是吹毛求疵，这对你很有帮助。</li><li>你可以培养自尊感与羞耻感复原力，这能改变你的人生。</li></ul><h4 id="建立信心的关键">建立信心的关键</h4><ul><li>一个人只有在缺乏自信的情况下才会增加自信。</li><li>想要建立自信，就要走出舒适区。每天重复这样做，你的自信心会与日自增。</li><li>自信会根据情境而改变，当情境发生变化时，你要相信自己能克服畏惧，从而增强自信。</li><li>你不需要把自己置于最恶劣的环境中，可以从小的改变开始。</li><li>在建立自信的过程中，要做好自己的教练，而不是最苛刻的批评者。</li><li>先有勇气，再有自信。</li></ul><h4 id="你的错误不能代表你这个人">你的错误不能代表你这个人</h4><ul><li>大多数自我怀疑都与我们和失败的关系有关。</li><li>别人如何看待你的失败并不能说明你的个性，也不代表你作为人的价值。</li><li>失败带来的痛苦会驱使我们麻痹自己，自我封闭。就算你一开始没有觉察到自己的感受，你也可以觉察自己是通过哪些行为来屏蔽情绪的。</li><li>做自己的教练，把失败变成学习的机会，你才能不断进步，朝着你觉得最重要的方向努力。</li><li>失败会引发巨大的情绪反应，所以不要着急。</li></ul><h4 id="对自己更“狠”一些">对自己更“狠”一些</h4><ul><li>有一种误解，认为自我接纳会让人变得懒惰、自满、缺乏动力。</li><li>研究表明，那些能学着自我接纳、自我关怀的人不太可能惧怕失败，他们也更愿意再次尝试。</li><li>自我接纳不是被动地接受失败。</li><li>自我关怀也包括选择那条更难走但对你更有利的路。</li></ul><h3 id="极度焦虑，整天忧心忡忡怎么办">极度焦虑，整天忧心忡忡怎么办</h3><h4 id="消除焦虑">消除焦虑</h4><ul><li>人们希望消除焦虑是可以理解的，因为焦虑会令人不适。</li><li>要战胜恐惧，首先必须愿意面对它。</li><li>逃避只能短期缓解焦虑，长期来看，它只会加重焦虑。</li><li>我们为了控制和消除恐惧而做出的努力，正支配着我们的一举一动。</li><li>威胁应对系统会快速行动，你还来不及仔细思考，它就拉响了警报。</li></ul><h4 id="哪些做法会加重焦虑">哪些做法会加重焦虑</h4><ul><li>人在焦虑时最自然而然的反应就是逃避。</li><li>但逃避不会让焦虑消失。</li><li>仅仅告诉大脑某些东西是安全的还不够，你必须亲身体验，才能真正相信。</li><li>你需要一遍一遍重复这种行为，大脑才会被说服。</li><li>你做的最多的失去会成为你的舒适区。</li><li><strong>要想减轻对某件事的焦虑，就反复做这件事</strong>。</li></ul><h4 id="如何平复当下的焦虑">如何平复当下的焦虑</h4><ul><li>焦虑时，呼吸会变得急促、短浅。</li><li>想要让身体平静下来，请慢慢地深呼吸。</li><li>试着让呼气时间比吸气时间更长，呼气比吸气更有力。</li><li>要给它一些时间，焦虑反应会开始消退。</li></ul><h4 id="如何处理焦虑的想法">如何处理焦虑的想法</h4><ul><li>发现偏差并确定它是哪种类型的，这样才能与焦虑的想法保持距离。</li><li>记住，即使你还是会持续关注焦虑的想法，但你可以控制关注的焦点。</li><li>善意能减轻威胁反应，无论是来自他人的善意，还是我们对自己的善意。</li><li>将威胁重新定义为挑战，能让我们充满勇气。</li><li>行动要与价值观一致，你做决定应该根据什么对你最重要，而不是处于恐惧。</li></ul><h4 id="对不可避免的事情的恐惧">对不可避免的事情的恐惧</h4><ul><li>我们都惧怕死亡，包括它的已知和未知。</li><li>对于有些人来说，接近死亡会让他们成长，也会带来积极的生活转变。</li><li>接受死亡并不意味着放弃生命，而是恰恰相反。</li><li>接受死亡才能让我们赋予生命意义。</li></ul><h3 id="压力大到濒临崩溃怎么办">压力大到濒临崩溃怎么办</h3><h4 id="压力和焦虑有什么不同吗">压力和焦虑有什么不同吗</h4><ul><li>人们常把“压力”和“焦虑”这两个词混用</li><li>当我们的生理状态能够与外部需求相匹配时，即便有压力，我们也会把它解读为积极的感受。</li><li>当我们的大脑在为我们要做的事做准备时，我们就会感到压力。</li><li>大脑会释放能量，以提高警觉性，让我们对环境做出反应。</li><li>我们常把焦虑理解为基于恐惧而做出反应，实际上它是为了满足你的需求而产生的一种压力反应。</li></ul><h4 id="为什么减压不是唯一的答案">为什么减压不是唯一的答案</h4><ul><li>压力并不总是敌人，它也是最有价值的工具。</li><li>要学着在承受压力后充实身心，与试图消除压力相比，这个做法更实际。</li><li>压力能帮助你表现得更出色，也能驱使你做最重要的事，但我们不能一直处于压力状态。</li><li>适度的压力会让生活充满乐趣和挑战，但压力太大会让人无法感受到生活的美好。</li></ul><h4 id="当有益的压力变得有害">当有益的压力变得有害</h4><ul><li>短期的压力反应能激发出最好的状态。</li><li>长期压力就像在高速公路上开车挂二挡，用不了多长时间，就会出事故。</li><li>倦怠不仅仅是工作造成的。</li><li>没有万能的灵丹妙药。对其他人保持平衡有用的方法对你也许没有作用。</li><li>如果你出现倦怠的迹象，你要倾听它们并及时回应，要学着满足自己的需求。</li></ul><h4 id="把压力变成动力">把压力变成动力</h4><ul><li>改变一些简单的行为模式，比如呼吸模式，能改变你的压力水平。</li><li>科学表明，冥想对大脑和我们处理问题的方式有显著影响。</li><li>与他人建立连接能帮助我们从压力中恢复。社交隔离会让人身心俱疲，承受巨大压力。</li><li>以做出贡献为目标，而不是把竞争当成目标，这样在面对压力时，我们才有动力和毅力。</li><li>寻找能让自己产生敬畏之心的体验，以改变视角。</li></ul><h4 id="如何处理必须面对的压力">如何处理必须面对的压力</h4><ul><li>我们对压力的看法会影响我们在压力状态下的表现。</li><li>把压力看作一种财富，可以帮助你实现目标，你不需要花太多精力去摆脱压力，而是要专注于你被要求做到的事。</li><li>关注应该做什么，而不是不该做什么。</li><li>调整你的关注点可以改变压力水平。</li><li>改变你与失败的关系，培养羞耻感复原力，能帮助你应对高压环境。</li></ul><h3 id="觉得人生没有意义怎么办">觉得人生没有意义怎么办</h3><h4 id="关于“我只想要幸福”的问题">关于“我只想要幸福”的问题</h4><ul><li>我们经常被灌输的观念史，幸福才是常态，一个人要是觉得不幸福，那他肯定是有心理问题的。</li><li>有时我们会觉得不幸福，这恰恰是因为我们是人，而且，人生本就艰难。</li><li>让生命有价值的人或是带给我们的不仅仅是幸福感，也混杂了爱、快乐、恐惧、羞愧和伤害。</li><li>要弄清楚自己的价值观，因为它能引导我们去设定人生目标，而实现目标的过程是有意义、有价值的。</li><li>要把价值观放在第一位，因为它能帮助我们熬过人生的痛苦时刻，让我们知道自己走在正确的路上。</li></ul><h4 id="找到最重要的事">找到最重要的事</h4><ul><li>你可以通过一些简单的练习来弄清楚自己现阶段的价值观。</li><li>价值观会随着时间的推移而改变，我们的生活与价值观的一致程度也会改变，因此，有必要经常审视自己的价值观。</li><li>我们可以根据价值观进行大的目标设定，并确立日常的小目标。</li><li>重点不在于你希望会发生什么，而在于你想成为什么样的人，你想做出什么样的贡献，以及无论发生什么，你都会如何面对生活。</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/5ee2743c032d16c193da31c6c6daae4b.png" alt="价值观——请圈出对你而言最重要、最有意义的价值观"><br><img src="//s3.mindex.xyz/blog/Notes/ba2d9900c52c6ccd737d32a3680d4b23.png" alt="这张表格中的示例能说明价值观与目标的区别，应该如何让目标与价值观一致，并转化为日常行为。"></p><h4 id="如何创造有意义的人生">如何创造有意义的人生</h4><ul><li>在下定决心要做出改变时，我们往往会给自己设立一个宏大的、激进的新目标。</li><li>只有一个目标并不足以保证我们能做出改变，更不能保证长久的改变。</li><li>花时间思考并想象你要成为怎样的人，并把这些想法转化为具体的、可持续的行动，这样你会觉得自己的努力更有意义。</li><li>将你行动的初衷与身份认同练习起来，这样最初的目标实现后，新的行为习惯也会持续下去。</li></ul><h4 id="关系">关系</h4><ul><li>当我们谈到幸福生活时，关系要比金钱、名誉、社会阶层、基因以及所有我们被告知要尽力争取的东西都要重要。</li><li>我们的关系以及我们在关系中感受到的幸福程度与我们的整体健康密不可分，关系是幸福和健康的核心。</li><li>改善自我有助于改善关系，而改善关系又有助于改善自我。</li><li>童年时期所形成的依恋关系通常会体现在成年后的关系中。</li></ul><h4 id="何时该寻求帮助">何时该寻求帮助</h4><ul><li>只要你关心自己的心理健康，你随时可以去寻求帮助。</li><li>如果你不确定自己需要多少帮助，专业人士可以帮助你做出决策。</li><li>在理想的世界，无论是谁，只要需要，就能得到专业的心理治疗。但理想的世界并不存在。</li><li>如果没有条件获得专业服务，那就抓住一切机会去了解关于心理疗愈的只是，并向你信任的人寻求支持。</li></ul>]]></content>
    
    <summary type="html">
    
      人生中的事分两类，你能控制的，你不能控制的。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="Health" scheme="https://neo1989.net/tags/Health/"/>
    
  </entry>
  
  <entry>
    <title>人格障碍</title>
    <link href="https://neo1989.net/Notes/NOTE-personality-disorder/"/>
    <id>https://neo1989.net/Notes/NOTE-personality-disorder/</id>
    <published>2023-01-31T04:24:53.000Z</published>
    <updated>2023-01-31T05:16:25.479Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A类人格障碍">A类人格障碍</h3><p>表现为古怪的思想或行为。</p><h4 id="偏执型">偏执型</h4><ul><li>对他人的动机普遍表现出不信任和怀疑</li><li>毫无根据地认为他人试图伤害或欺骗自己</li><li>毫无根据地对他人的忠诚或诚信产生怀疑</li><li>由于无端地担心他人会利用获知的信息对付您，而不愿向他人倾诉</li><li>将无恶意言论或无威胁性情况视为人身侮辱或攻击</li><li>对察觉到的侮辱或轻蔑表现出愤怒或敌对反应</li><li>有怨恨倾向</li><li>毫无根据地反复怀疑配偶或性伴侣不忠</li></ul><h4 id="类精神分裂型">类精神分裂型</h4><ul><li>对社会或人际关系缺乏兴趣，喜欢独处</li><li>情感表达范围有限</li><li>在大多数活动中都无法获得乐趣</li><li>无法察觉社交暗示</li><li>看起来对别人很冷淡或漠不关心</li><li>几乎没有兴趣与他人发生性关系</li></ul><h4 id="精神分裂型">精神分裂型</h4><ul><li>穿着奇特、思想奇怪、有奇异的信念、言语怪异或行为怪癖</li><li>具有奇怪的感知经验，例如听到有声音在轻声呼唤自己的名字</li><li>表现出情绪平淡或不是当的情绪反应</li><li>社交焦虑、缺乏密切关系或对密切关系感到不适</li><li>表现出对他人冷淡」不当或怀疑的反应</li><li>“奇幻思维” —— 相信能用自己的思想影响身边的人和事</li><li>相信某些偶然时间具有仅对自己有意义的隐藏信息</li></ul><h3 id="B类人格障碍">B类人格障碍</h3><p>表现为戏剧性、过度情绪化或不可预测的思想或行为</p><h4 id="反社会型">反社会型</h4><ul><li>忽视他人的需求或感受</li><li>习惯撒谎、偷窃、使用别名和哄骗他人</li><li>反复违法</li><li>屡次侵犯他人的权利</li><li>经常有攻击和暴力行为</li><li>忽视自己或他人的安全</li><li>冲动行为</li><li>一贯不负责任</li><li>对自己的行为毫无悔意</li></ul><h4 id="边缘型">边缘型</h4><ul><li>表现出冲动和危险行为，例如不安全性行为、赌博或暴饮暴食</li><li>自我形象不稳定或脆弱</li><li>关系不稳定且紧张</li><li>心情起伏不定，往往是对人际压力的反应</li><li>自杀行为或自残威胁</li><li>强烈恐惧孤独或被抛弃</li><li>持续的空虚感</li><li>频繁且强烈地表现出愤怒</li><li>压力引起的妄想症，时有时无</li></ul><h4 id="表演型">表演型</h4><ul><li>不断寻求关注</li><li>用过度情绪化、戏剧化或性挑逗行为引起注意</li><li>固执己见，但几乎没有事实或细节支持</li><li>容易受他人影响</li><li>头脑简单，情绪变化太快</li><li>过度关注外表</li><li>过度乐观估计与他人的关系</li></ul><h4 id="自恋型">自恋型</h4><ul><li>认为自己很特别，且比他人更重要</li><li>对权力、成功和吸引力抱有幻想</li><li>不能认识到他人的需求和感受</li><li>对自己的成就或才能夸大其词</li><li>期望得到不断的赞美和欣赏</li><li>傲慢自大</li><li>不合理地期望得到利益和好处，经常利用他人</li><li>嫉妒他人，或认为被他人嫉妒</li></ul><h3 id="C类人格障碍">C类人格障碍</h3><p>表现为焦虑和恐惧的思想或行为</p><h4 id="回避型">回避型</h4><ul><li>对批评或拒绝太过敏感</li><li>感觉能力不足、自卑或缺乏吸引力</li><li>回避需要人际交往的工作活动</li><li>在社交上压抑、胆怯和孤立，不愿意参加新的活动或与陌生人见面</li><li>在社交场合和人际关系中极为害羞</li><li>害怕不被认可、尴尬或受到嘲笑</li></ul><h4 id="依赖型">依赖型</h4><ul><li>过度依赖他人，感觉自己需要被照顾</li><li>对他人表现出顺从或粘人的行为</li><li>害怕独自一人时不得不照顾自己</li><li>缺乏自信，即使做出很小的决定也需要别人的过度建议和肯定</li><li>因缺乏自信而难以独自开始或完成项目</li><li>难以与他人持不同意见，担心不被认可</li><li>即使有其他选择，也会容忍粗暴或虐待行为</li><li>当一段亲密关系结束时，迫切需要开始一段新的关系</li></ul><h4 id="强迫型">强迫型</h4><p>强迫型人格障碍不同于强迫症。</p><ul><li>对于细节、秩序和规则的先占观念</li><li>极端的完美主义，当未能达到完美时，例如因为没有达到自己的严格标准而无法完成一个项目，会导致身体机能障碍和痛苦</li><li>渴望控制他人、任务和局势，却无法委派任务</li><li>对工作或项目过度投入。从而忽视朋友和娱乐活动</li><li>无法丢弃破损或毫无价值的东西</li><li>刻板而固执</li><li>在道德、伦理或价值观方面过于死板</li><li>在控制预算和花钱方面很严格且吝啬</li></ul>]]></content>
    
    <summary type="html">
    
      如果您有任何一种人格障碍的体征和症状，请咨询您的医生、其他初级保健专家或心理健康专家。如果不加以治疗，人格障碍会给您的生活带来严重问题，并且情况可能变得越来越糟。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="Health" scheme="https://neo1989.net/tags/Health/"/>
    
  </entry>
  
  <entry>
    <title>Building a cool chatbot</title>
    <link href="https://neo1989.net/HandMades/HANDMADE-build-a-cool-chatbot-step-by-step/"/>
    <id>https://neo1989.net/HandMades/HANDMADE-build-a-cool-chatbot-step-by-step/</id>
    <published>2022-12-06T08:43:27.000Z</published>
    <updated>2023-04-25T07:55:37.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Concepts">Concepts</h2><p><strong>Natural Language Processing (NLP)</strong> is a field of Artificial Intelligence that enables computers to analyze and understand the human language.</p><p><strong>Natural Language Understanding (NLU)</strong> is a subset of a bigger picture of NLP, just like machine learning, deep learning, NLP, and data mining are a subset of a bigger picture of Artificial Intelligence (AI), which is an umbrella term for any computer program that does something smart.</p><p><strong><a href="https://spacy.io/" target="_blank" rel="noopener">spaCy</a></strong> is an open-source software library for advanced NLP, written in Python and Cython. It provides intuitive APIs to access its methods trained by deep learning models.</p><h2 id="Cornerstones">Cornerstones</h2><p>Before we actually dive into spaCy and code snippets, make sure we have the necessary setup ready.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/chatBot &amp;&amp; <span class="built_in">cd</span> ~/chatBot</span><br><span class="line">pyenv virtualenv 3.8.5 chatBot</span><br><span class="line">pyenv <span class="built_in">local</span> chatBot</span><br><span class="line">pip install spacy==3.4.3</span><br></pre></td></tr></table></figure><p><a href="https://spacy.io/models" target="_blank" rel="noopener">spaCy models</a> are just like any other machine learning or deep learning models. A model is a yield of an algorithm or, say, an object that is created after training data using a machine learning algorithm. spaCy has lots of such models that can be placed directly in our program by downloading it just like any other Python package.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m spacy download zh_core_web_lg</span><br><span class="line">python -m spacy download en_core_web_lg</span><br></pre></td></tr></table></figure><h3 id="POS-Tagging">POS Tagging</h3><p>Part-of-speech (POS) tagging is a process where you read some text and assign parts of speech to each word or token, such noun, verb, adjective, etc.<br>POS tagging becomes extremely important when you want to identify some entity in a given sentence. The first step is to do POS tagging and see what our text contains.<br>Let’s get our hands dirty with some of the examples of real POS tagging.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'zh_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">'明天的天气如何？'</span>)</span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    print(token.text, token.pos_)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">明天 NOUN</span><br><span class="line">的 PART</span><br><span class="line">天气 NOUN</span><br><span class="line">如何 VERB</span><br><span class="line">？ PUNCT</span><br></pre></td></tr></table></figure><h3 id="Stemming-and-Lemmatization">Stemming and Lemmatization</h3><p><strong>Stemming</strong> is the process of reducing inflected words to their word stem, base form.<br>A stemming algorithm reduces the words “saying” to the root word “say”, whereas “presumable” becomes “presum”. As you can see, this may or may not always be 100% correct.<br><strong>Lemmatization</strong> is closely related to <strong>stemming</strong>, but lemmatization is the algorithmic process of determining the lemma of a word based on its intended meaning.<br>spaCy doesn’t have any in-built stemmer, as lemmatization is considered more correct and productive. (spaCy 没有内置的词干提取器，因为词形还原被认为更加准确和有效。)<br>Difference between Stemming and lemmatization:</p><ul><li><strong>Stemming</strong> does the job in a crude, heuristic way that chops off the ends of words, assuming that the remaining word is what we are actually looking for, but it often includes the removal of derivational affixes.</li><li><strong>Lemmatization</strong> tries to do the job more elegantly with the use of a vocabulary and morphological analysis of words. It tries its best to remove inflectional endings only and return the dictionary form of a word, konwn as the lemma.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.stem.porter <span class="keyword">import</span> PorterStemmer</span><br><span class="line">stemmer = PorterStemmer()</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> [<span class="string">'went'</span>, <span class="string">'goes'</span>]:</span><br><span class="line">    print(w, stemmer.stem(w))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">went went</span><br><span class="line">goes goe</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'en_core_web_lg'</span>)</span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> nlp(<span class="string">'went goes'</span>):</span><br><span class="line">    print(token.text, token.lemma_)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">went go</span><br><span class="line">goes go</span><br></pre></td></tr></table></figure><p>Since you are pretty much aware what a stemming or lemmatization does in NLP, you should be able to understand that whenever you come across a situation where you need the root form of the word, you need to do lemmatization there. For example, it is often used in building search engines. You must have wondered how Google gives you the articles in search results that you meant to get even when the search text was not properly formulated.<br>This is where one makes use of lemmatization.<br>Imageine you search with the text, “When will the next season of Game of Thrones be releasing?”<br>Now, suppose the search engine does simple document word frequency matching to give you search results. In this case, the aforementioned query probably won’t match an article with a caption “Game of Thrones next season release date”.<br>If we do the lemmatization of the orginal question before going to matchh the input with the documents, then we may get better results.</p><h3 id="Named-Entity-Recognition">Named-Entity Recognition</h3><p><strong>NER</strong>, also known by other names like <strong>entity identification</strong> or <strong>entity extraction</strong>, is a process of finding and classifying <a href="https://en.wikipedia.org/wiki/Named_entity" target="_blank" rel="noopener">named entities</a> existing in the given text into pre-defined categories.<br>The NER task is hugely dependent on the knowledge base used to train the NE extraction algorithm, so it may or may not work depending upon the provided dataset it was trained on.<br>spaCy comes with a very fast entiry recognition model that is capable of identifying entity phrases from a given document. Entities can be of different types, such as person, location, organization, dates, numerals, etc. These entities can be accessed through .ents property of the doc object.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'zh_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">"欧盟拟向东南亚投资100亿欧元"</span>)</span><br><span class="line"><span class="keyword">for</span> ent <span class="keyword">in</span> doc.ents:</span><br><span class="line">    print(ent.text, ent.label_)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">欧盟 ORG</span><br><span class="line">东南亚 LOC</span><br><span class="line"><span class="number">100</span>亿欧元 MONEY</span><br></pre></td></tr></table></figure><h3 id="Stop-Words">Stop Words</h3><p>Stop words are high-frequency words like a, an, the, to and also that we sometimes want to filter out of a document before further processing. Stop words usually have little lexical content and do not hold much of meaning.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy.lang.zh.stop_words <span class="keyword">import</span> STOP_WORDS</span><br><span class="line">print(list(STOP_WORDS)[:<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">[<span class="string">'岂止'</span>, <span class="string">'当即'</span>, <span class="string">'纵'</span>, <span class="string">'▲'</span>, <span class="string">'几经'</span>, <span class="string">'上来'</span>, <span class="string">'什麽'</span>, <span class="string">'假使'</span>, <span class="string">'×'</span>, <span class="string">'『'</span>]</span><br></pre></td></tr></table></figure><p>Tosee if a word is a stop word or not, you can use the nlp object of spaCy. We can use the nlp object’s is_stop attribute.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nlp.vocab[<span class="string">"的"</span>].is_stop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="Dependency-Parsing">Dependency Parsing</h3><p>Dependency parsing is one of the more beautiful and powerful features of spaCy that is fast and accurate. The parser can also be used for sentence boundary detection and lets you iterate over base noun phrases, or “chunks”.<br>This feature of spaCy gives you a parsed tree that explains the parent-child relationship between the words or phrases and is indenpendent of the order in which words occur.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'en_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">"Book me a flight from Bangalore to Goa"</span>)</span><br><span class="line">print(doc[<span class="number">5</span>], list(doc[<span class="number">5</span>].ancestors))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">Bangalore [<span class="keyword">from</span>, flight, Book]</span><br></pre></td></tr></table></figure><p>Ancestors are the rightmost token of this token’s syntactic descendants.<br>To check if a doc object item is an ancestor of another <em>doc</em> object item programmactically, we can do the following:<br><code>doc[3].is_ancestor(doc[5])</code><br>The above returns <code>True</code> because doc[3] (i.e., flight) is an ancestor of doc[5] (i.e., Bangalore).</p><p>Children are immediate syntactic dependents of the token. We can see the children of a word by using children attribute just like we used ancestors.<br><code> list(doc[3].children)</code> will output <code>[a, from, to]</code></p><p>Dependency parsing is one the most important parts when building chatbots from scratch. It becomes far more important when youn want to figure out the meaning of a text input from your user to your chatbot. There can be cases when you haven’t trained your chatbots, but still you don’t want to lose your customer or reply like a dumb machine.<br>In these cases, dependency parsing really helps to find the relation and explain a bit more about what the user may be asking for.<br>If we were to list things for which dependency parsing helps, some might be:</p><ul><li>It helps in finding relationships between words of grammatically correct sentences.</li><li>It can be used for sentence boundary detection.</li><li>It is quite useful to find out if the user is talking about more than one context simulationeously.<br>You need to write your own custom NLP to understand the context of the user or your chatbot and, based on that, identify the possible grammatical mistakes a user can meke.</li></ul><p>All in all, you must b ready for such scenarious where a user will input garbage values or grammatically incorrect sentences. You can’t handle all such scenarios at once, but you can keep improve you chatboot by adding custom NLP code or by limiting user input by design.</p><h3 id="Noun-Chunks">Noun Chunks</h3><p>Noun chunks or NP-chunking are basically “base noun phrases”. We can say they are flat phrases that have anoun as their head. You can think of noun chunks as a noun with the words describing the noun.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'en_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">"Boston Dynamics is gearing up to produce thousands of robot dogs"</span>)</span><br><span class="line">print(list(doc.noun_chunks))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">[Boston Dynamics, thousands, robot dogs]</span><br></pre></td></tr></table></figure><p><strong>The ‘noun_chunks’ syntax iterator is not implemented for language 'zh’</strong></p><h3 id="Finding-Similarity">Finding Similarity</h3><p>Finding similarity between two words is a use-case you will find most of the time working with NLP. Sometimes it becomes fairly important to find if two words are similar. While building chatbots you will often come to situations where you don’t have to just find similar-lokking words but also how closely related two words are logically.<br>spaCy uses high-quality word vectors to find similarity between two words using <strong>GloVe algorithm</strong> (Global Vectors for Word Representation).<br>GloVe is an unsupervised learning algorithm for obtaining vector representations for words. GloVe algorithm uses aggregated global word-word co-occurrence statistics from a corpus to train the model.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'zh_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">"美团小贷注册资本增至75亿元"</span>)</span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">     print(token.text, token.vector[:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Output #</span><br><span class="line">美团 [<span class="number">-0.78366</span>  <span class="number">0.31008</span> <span class="number">-1.0793</span>  <span class="number">-0.87563</span>  <span class="number">0.56224</span>]</span><br><span class="line">小贷 [ <span class="number">1.0563</span>  <span class="number">-2.695</span>   <span class="number">-0.44203</span>  <span class="number">0.98277</span> <span class="number">-4.8158</span> ]</span><br><span class="line">注册 [ <span class="number">3.4941</span> <span class="number">-2.8909</span> <span class="number">-4.572</span>  <span class="number">-2.0436</span> <span class="number">-1.9986</span>]</span><br><span class="line">资本 [ <span class="number">3.8849</span>  <span class="number">0.3031</span> <span class="number">-2.382</span>   <span class="number">2.8471</span> <span class="number">-2.7938</span>]</span><br><span class="line">增至 [ <span class="number">1.469</span>   <span class="number">1.0054</span>  <span class="number">5.4963</span>  <span class="number">1.8396</span> <span class="number">-3.7624</span>]</span><br><span class="line"><span class="number">75</span>亿 [ <span class="number">0.3056</span>   <span class="number">0.69498</span>  <span class="number">1.4444</span>   <span class="number">0.91454</span> <span class="number">-0.97031</span>]</span><br><span class="line">元 [ <span class="number">2.8509</span>  <span class="number">-0.53181</span> <span class="number">-2.646</span>   <span class="number">-0.5862</span>  <span class="number">-4.0398</span> ]</span><br></pre></td></tr></table></figure><p>Seeing this output, it doesn’t make much sense and meaning. From an application’s perspective, what matters the most is how similar the vectors of different words are – that is, the word’s meaning itself.<br>In order to find similarity between two words in spaCy, we can do the following.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'en_core_web_lg'</span>)</span><br><span class="line"><span class="builtin-name">print</span>(nlp(<span class="string">"car"</span>).similarity(nlp(<span class="string">"truck"</span>)))</span><br><span class="line"><span class="builtin-name">print</span>(nlp(<span class="string">"car"</span>).similarity(nlp(<span class="string">"plane"</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">0.7760473774094219</span><br><span class="line">0.4592993678544094</span><br></pre></td></tr></table></figure><p>The word ‘car’ is more related and similar to the word ‘truck’ than the word ‘plane’.<br>We can also get the similarity between sentences.</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> spacy</span><br><span class="line"><span class="attr">nlp</span> = spacy.load('en_core_web_lg')</span><br><span class="line"><span class="attr">str1</span> = nlp(<span class="string">"When will next season of Game of Thrones be releasing?"</span>)</span><br><span class="line"><span class="attr">str2</span> = nlp(<span class="string">"Game of Thrones next season release date?"</span>)</span><br><span class="line">print(str1.similarity(str2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line"><span class="number">0.8226084934378249</span></span><br></pre></td></tr></table></figure><p>As we can see in this example, the similarity between both of the sentences is about 82%, which is good enough to say that both of the sentences are quite similar, which is true. This can help us save a lot of time for writing custom code when build chatbots.</p><h3 id="Tokenization">Tokenization</h3><p>Tokenization is one of the simple yet basic concepts of NLP where we split a text into meaningful segments. spaCy first tokenizes the text (i.e., segments it into words and then punctuation and other things). A question might come to your mind: Why can’t I just use the built-in split method of Python language and do the tokenization? Python’s split method is just a raw method to split the sentence into tokens given a sepatator. It doesn’t take any meaning into account, whereas tokenization tries to preserve the meaning as well.</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'zh_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">"告诉我处女座今天的运势"</span>)</span><br><span class="line">for tk <span class="keyword">in</span> doc:</span><br><span class="line">    print(tk.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Output #</span><br><span class="line">告诉</span><br><span class="line">我</span><br><span class="line">处女座</span><br><span class="line">今天</span><br><span class="line">的</span><br><span class="line">运势</span><br></pre></td></tr></table></figure><p>If you are not satisfied with spaCy’s tokenization, you can use its <em>add_special_case</em> method to add your own rules before relying completely on spaCy’s tokenization method.</p><h3 id="Regular-Expressions">Regular Expressions</h3><p>You must already know about regular expressions and their usage.<br>Text analysis and processing is a big subject in itself. Sometimes words play together in a way that makes it extremely difficult for machines to understand and get trained upon.<br>Regular expression can come handy for some fallback for a machine learning model. It has the power of pattern-matching, which can ensure that the data we are processing is correct or incorrect. Most of the early chatbots were hugely dependent on pattern-matching.<br>Given the power of machine learning these days, regular expression and pattern-matching has taken a back step, but make sure you brush up a bit about it as it may be needed at any time to parse specific details from words, sentences, or text documents.</p><h2 id="The-Hard-Way">The Hard Way</h2><p>“Building Chatbots the Hard Way” is not to hard to learn. It’s the hard way of building chatbots to have full control over your own chatbots. If you want to build everything yourself, then you take the hard route. The harder route is hard when you go through it but beautiful and clear when you look back.</p><blockquote><p>It is a rough road that leads to the heights of etness. – Lucius Annaeus Seneca</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install rasa==<span class="number">3.4</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><h3 id="构建Rasa机器人的步骤">构建Rasa机器人的步骤</h3><ul><li>初始化项目</li><li>准备NLU训练数据</li><li>准备故事story</li><li>定义领域domain</li><li>定义规则rule</li><li>定义动作action</li><li>配置config</li><li>训练模型</li><li>测试机器人</li><li>发布机器人</li></ul><h3 id="Building-a-Simple-Horoscope-Bot">Building a Simple Horoscope Bot</h3><p>Let’s decide the scope of this chatbot and see what it does and can do.</p><ul><li>The Horoscope Bot should be able to understand greetings and reply with a greeting.</li><li>The bot should be able to understand if there user is asking for horoscope.</li><li>The bot should be able to ask the horoscope sign of the user if the user doesn’t provide it.</li><li>The bot should learn from existing responses to formulate a new response.<br>It is pretty simple what our bot is supposed to do here.</li></ul><p>Possible intents</p><ul><li>Greeting Intent: User starting with a greeting</li><li>Get Horoscope Intent: User asking for horoscope</li><li>User’s Horoscope Intent: User telling the horoscope sign</li></ul><p>We’ll try to build the bot that does the basic task of giving a horoscope.<br>Let’s create a possible conversation script between our chatbot and the user.</p><pre><code>User: HelloBot: 你好，有什么能帮到你？User: 看一下今年的运势Bot: 想查哪个星座的运势?User: 双鱼的Bot: 由于天王星的逆行，可能会打乱双鱼座的节奏，所以双鱼座本年要懂得韬光养晦，要努力的去沉淀自己...</code></pre><p>This conversation is just to have a fair idea of how our chatbot conversation is going to look.<br>We can have our chatbot model itself trained to prepare a valid response instead of writing a bunch of <code>if ... else</code> statements.</p><h4 id="Initializing-the-bot">Initializing the bot</h4><p>Let’s init our bot.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/chatBot</span><br><span class="line">rasa init --no-prompt</span><br></pre></td></tr></table></figure><h4 id="Preparing-data">Preparing data</h4><p>First, prepare the <strong>nlu</strong> data. (nlu负责意图提取和实体提取)<br>The following is what my <strong><code>nlu.yml</code></strong> under <strong>data</strong> folder looks like:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">nlu:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">greet</span></span><br><span class="line">    <span class="attr">examples:</span> <span class="string">|</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hello</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">goodbye</span></span><br><span class="line">    <span class="attr">examples:</span> <span class="string">|</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bye</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">goodbye</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">    <span class="attr">examples:</span> <span class="string">|</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">查一下[今天](date_time)的运势</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">看一下[狮子座](horoscope_sign)如何</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">info_date_time</span></span><br><span class="line">    <span class="attr">examples:</span> <span class="string">|</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">[今日](date_time)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">[明天](date_time)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">info_horoscope_sign</span></span><br><span class="line">    <span class="attr">examples:</span> <span class="string">|</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">[白羊](horoscope_sign)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">[金牛](horoscope_sign)</span></span><br></pre></td></tr></table></figure><p>Then, prepare the <strong>stories</strong> data (Rasa是通过学习story的方式来学习对话管理知识).<br>The following is what my <strong><code>stories.yml</code></strong> under <strong>data</strong> folder looks like:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stories:</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">story:</span> <span class="string">greet</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">greet</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">utter_greet</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">story:</span> <span class="string">say</span> <span class="string">goodbye</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">goodbye</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">utter_goodbye</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">story:</span> <span class="string">get</span> <span class="string">horoscope</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">or:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">      <span class="attr">entities:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">horoscope_sign:</span> <span class="string">双鱼</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">      <span class="attr">entities:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">date_time:</span> <span class="string">今天</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">      <span class="attr">entities:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">horoscope_sign:</span> <span class="string">双鱼</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">date_time:</span> <span class="string">今天</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">horoscope_form</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="string">horoscope_form</span></span><br></pre></td></tr></table></figure><p>Then, prepare the <strong>domain</strong> data (domain定义了chatbot需要知道的所有信息，包括intent, entity, slot, action, form, response).<br>The following is what my <strong><code>domain.yml</code></strong> under project root looks like:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">intents:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">greet</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">goodbye</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get_horoscope</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">info_date_time</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">info_horoscope_sign</span></span><br><span class="line"></span><br><span class="line"><span class="attr">entities:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">date_time</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">horoscope_sign</span></span><br><span class="line"></span><br><span class="line"><span class="attr">slots:</span></span><br><span class="line">  <span class="attr">date_time:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">text</span></span><br><span class="line">    <span class="attr">influence_conversation:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">mappings:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">entity:</span> <span class="string">date_time</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">from_entity</span></span><br><span class="line">        <span class="attr">conditions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="string">horoscope_form</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">horoscope_sign:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">text</span></span><br><span class="line">    <span class="attr">influence_conversation:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">mappings:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">entity:</span> <span class="string">horoscope_sign</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">from_entity</span></span><br><span class="line">        <span class="attr">conditions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="string">horoscope_form</span></span><br><span class="line"><span class="attr">responses:</span></span><br><span class="line">  <span class="attr">utter_greet:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">text:</span> <span class="string">"你好，有什么能帮到你？"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">utter_goodbye:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">text:</span> <span class="string">"再见"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">utter_ask_horoscope_sign:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">text:</span> <span class="string">"想查哪个星座的运势?"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">utter_ask_date_time:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">text:</span> <span class="string">"想查今天、明天、本周、本月还是今年的运势？"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">utter_greet</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">utter_goodbye</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">utter_ask_horoscope_sign</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">utter_ask_date_time</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">action_get_horoscope</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">action_default_fallback</span></span><br><span class="line"></span><br><span class="line"><span class="attr">forms:</span></span><br><span class="line">  <span class="attr">horoscope_form:</span></span><br><span class="line">    <span class="attr">ignored_intents:</span> <span class="string">[]</span></span><br><span class="line">    <span class="attr">required_slots:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">date_time</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">horoscope_sign</span></span><br><span class="line"></span><br><span class="line"><span class="attr">session_config:</span></span><br><span class="line">  <span class="attr">session_expiration_time:</span> <span class="number">60</span></span><br><span class="line">  <span class="attr">carry_over_slots_to_new_session:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Then, prepare the <strong>rule</strong> (rule负责将问题分类映射到对应的动作上).<br>The following is what my <strong><code>rules.yml</code></strong> under <strong>data</strong> folder looks like:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">rule:</span> <span class="string">activate</span> <span class="string">horoscope</span> <span class="string">form</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">horoscope_form</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="string">horoscope_form</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">rule:</span> <span class="string">submit</span> <span class="string">form</span></span><br><span class="line">    <span class="attr">condition:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="string">horoscope_form</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">horoscope_form</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="literal">null</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">slot_was_set:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">requested_slot:</span> <span class="literal">null</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">action_get_horoscope</span></span><br></pre></td></tr></table></figure><p>Then, prepare the <strong>action</strong> (action接收用户输入和对话状态信息，按照业务逻辑进行处理，并输出改变对话状态的事件和回复用户的消息).<br>The following is what my <strong><code>actions.py</code></strong> under <strong>actions</strong> folder looks like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionGetHoroscope</span><span class="params">(Action)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span> -&gt; Text:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"action_get_horoscope"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, dispatcher: CollectingDispatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">            tracker: Tracker,</span></span></span><br><span class="line"><span class="function"><span class="params">            domain: Dict[Text, Any])</span> -&gt; List[Dict[Text, Any]]:</span></span><br><span class="line"></span><br><span class="line">        date_time = tracker.get_slot(<span class="string">"date_time"</span>)</span><br><span class="line">        horoscope_sign = tracker.get_slot(<span class="string">"horoscope_sign"</span>)</span><br><span class="line"></span><br><span class="line">        dispatcher.utter_message(</span><br><span class="line">            text=json_object.get(horoscope_sign, &#123;&#125;) \</span><br><span class="line">                            .get(date_time, <span class="string">"抱歉，我目前无法找到您的运势"</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionDefaultFallback</span><span class="params">(Action)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span> -&gt; Text:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"action_default_fallback"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        dispatcher: CollectingDispatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">        tracker: Tracker,</span></span></span><br><span class="line"><span class="function"><span class="params">        domain: Dict[Text, Any],</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> -&gt; List[Dict[Text, Any]]:</span></span><br><span class="line">        dispatcher.utter_message(text=<span class="string">"我不明白您说的内容，请换个说法。"</span>)</span><br><span class="line">        <span class="keyword">return</span> [UserUtteranceReverted(), ]</span><br></pre></td></tr></table></figure><p>Then, prepare the <strong>config</strong>.<br>The following is what my <strong>config.yml</strong> under project root looks like:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">recipe:</span> <span class="string">default.v1</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh</span></span><br><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SpacyNLP</span></span><br><span class="line">    <span class="attr">model:</span> <span class="string">zh_core_web_lg</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SpacyTokenizer</span></span><br><span class="line">    <span class="attr">intent_tokenization_flag:</span> <span class="literal">False</span></span><br><span class="line">    <span class="attr">intent_split_symbol:</span> <span class="string">"_"</span></span><br><span class="line">    <span class="attr">token_pattern:</span> <span class="string">None</span></span><br><span class="line">  <span class="comment"># - name: WhitespaceTokenizer</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RegexFeaturizer</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LexicalSyntacticFeaturizer</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CountVectorsFeaturizer</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CountVectorsFeaturizer</span></span><br><span class="line">    <span class="attr">analyzer:</span> <span class="string">char_wb</span></span><br><span class="line">    <span class="attr">min_ngram:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">max_ngram:</span> <span class="number">4</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DIETClassifier</span></span><br><span class="line">    <span class="attr">epochs:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">constrain_similarities:</span> <span class="literal">true</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">EntitySynonymMapper</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ResponseSelector</span></span><br><span class="line">    <span class="attr">epochs:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">constrain_similarities:</span> <span class="literal">true</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">FallbackClassifier</span></span><br><span class="line">    <span class="attr">threshold:</span> <span class="number">0.3</span></span><br><span class="line">    <span class="attr">ambiguity_threshold:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">policies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MemoizationPolicy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TEDPolicy</span></span><br><span class="line">    <span class="attr">max_history:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">epochs:</span> <span class="number">200</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RulePolicy</span></span><br><span class="line">    <span class="attr">core_fallback_threshold:</span> <span class="number">0.5</span></span><br><span class="line">    <span class="attr">core_fallback_action_name:</span> <span class="string">action_default_fallback</span></span><br><span class="line">    <span class="attr">enable_fallback_prediction:</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="Training">Training</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rasa train</span><br></pre></td></tr></table></figure><h4 id="Test">Test</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rasa <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>Ok, if everything goes well, we’ve got a simple chatbot out there.</p><h4 id="Run">Run</h4><p>Run an action server.</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rasa <span class="built_in">run</span> actions <span class="comment">--actions actions.actions</span></span><br></pre></td></tr></table></figure><p>Run a shell</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rasa <span class="keyword">shell</span></span><br></pre></td></tr></table></figure><p>Let’s play with it in that shell.</p><p><img src="http://s3.mindex.xyz/blog/HandMades/5f12e717d8eb6d73616a80621a19ef31.png" alt="Test Case"></p><p>Try it out for yourself.</p><h2 id="References">References</h2><ul><li><a href="https://www.amazon.com/Building-Chatbots-Python-Language-Processing/dp/1484240952/" target="_blank" rel="noopener">Building Chatbots with Python</a></li><li><a href="https://www.amazon.cn/dp/B09T353ZJF" target="_blank" rel="noopener">RASA实战</a></li><li><a href="https://github.com/neo1989/chatbot" target="_blank" rel="noopener">chatbot-github</a></li></ul>]]></content>
    
    <summary type="html">
    
      Learn from what you&#39;ve done.
    
    </summary>
    
    
      <category term="HandMades" scheme="https://neo1989.net/categories/HandMades/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
      <category term="NLP" scheme="https://neo1989.net/tags/NLP/"/>
    
      <category term="AI" scheme="https://neo1989.net/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>《AI 3.0》</title>
    <link href="https://neo1989.net/Notes/NOTE-AI3.0/"/>
    <id>https://neo1989.net/Notes/NOTE-AI3.0/</id>
    <published>2022-11-01T03:39:11.000Z</published>
    <updated>2023-01-13T03:01:21.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="若想对未来下注，先要厘清人工智能为何仍然无法超越人类智能">若想对未来下注，先要厘清人工智能为何仍然无法超越人类智能</h2><h3 id="智能是个手提箱">智能是个手提箱</h3><p>对于任何谈论人工智能的人来说，定义“人工智能”都是一个挑战。因为人工智能的核型概念——智能，仍然没有明晰的定义。针对蕾丝“智能”及其引申义，如“思想” “认知” “意识” “情感” 这样的词语，明斯基肠燥了 “手提箱式词汇” 这一术语，其意思是：每个词语就像是打包封装了不通含义的手提箱。人工智能就经过了“打包”，在不同的上下文中承担不同的含义。</p><p>大多数人会认同人类是智能的，而尘埃颗粒不是。同样的道理，我们普遍认为人类比虫子更加智能。对于人类智能，智商是在单一尺度上衡量的，但我们也会探讨智能的不同纬度，如情感、语言、空间、逻辑、艺术、社交等。因此，智能的定义可能是二元的（一个物体是或不是智能的）、在一个<a href="https://zh.m.wikipedia.org/zh-hans/%E8%BF%9E%E7%BB%AD%E7%BB%9F" target="_blank" rel="noopener">连续统</a>上（一个物体比另一个物体更智能），或者是多维的（一个人可以具有高语言智能和低情感智能）。确实，“智能”这个词语是一个满载的手提箱，而拉链就在随时可能撑破的边缘上。</p><h3 id="神经网络是现代人工智能的基础">神经网络是现代人工智能的基础</h3><p>20世纪80年代中期，依赖人类创建并反映特定领域专家知识规则的符号人工智能方法——专家系统，越来越暴露出自身的脆弱性：容易出错，且在面对新情况时往往无法进行一般化或适应性的处理。在分析这些系统的局限性时，研究人员发现，便携规则的人类专家实际上或多或少依赖于常识以便明智地行动。这种常识通常难以通过程序化的规则或逻辑推理来获取，而这种常识的缺乏严重限制了符号人工智能方法的广泛应用。简而言之，在经历了过度承诺、巨额的资金支持和媒体炒作的一轮周期之后，符号人工智能又将面临另一个人工智能的寒冬。</p><p>根据联结主义的支持者观点，智能的关键在于构建一个合适的计算结构以及系统从数据或现实世界的行为中进行学习的能力，这是受到了大脑的启发。突然之间，神经网络又流行起来。</p><h3 id="强弱人工智能之争">强弱人工智能之争</h3><p>尽管深度学习近年来取得了很大成功，但和迄今为止所有的人工智能实例一样，这些程序仍然只是所谓的“狭义”或“弱”人工智能的例子。此处的“狭义”和“弱”是用来形容哪些仅能执行一些狭义任务或一组相关任务的系统。AlphaGo可能是世界上最好的围棋玩家，但除此之外什么也做不了，它甚至不会玩跳棋、井字棋等游戏。谷歌翻译可以把英文的影评翻译成中文，但它无法告诉你影评者是否喜欢这部电影，更不用说让它自己来观看和评论电影了。</p><p>“狭义”和“弱”人工智能往往是与“强” “人类水平” “通用” 或 “全面” 人工智能（有时候也称作AGI，即通用人工智能）对比而言的，后者即那种我们在电影中常看到的，可做我们人类所能做的几乎所有的使其，甚至更多事情的智能。通用人工智能是人工智能领域研究最初的目标，但至今还没有创建出任何能够在通用意义上被称为“智能”的人工智能程序。该领域最近的一项研究表明：“一堆狭义智能永远也不会堆砌成一种通用人工智能。通用人工智能的实现不在于单个能力的数量，而在于这些能力间的整合。“</p><h2 id="视觉识别：始终是“看”起来容易“做”起来难">视觉识别：始终是“看”起来容易“做”起来难</h2><h3 id="从大脑识别到ConvNets识别">从大脑识别到ConvNets识别</h3><p><strong>大脑识别模式：</strong> 当人的眼镜聚焦于一个场景是，眼睛接收到的是有场景中的物体发出或其表面反射的不同波长的光，这些光线激活了视网膜上的细胞，本质上说是激活了眼睛后面的一个神经元网格。这些神经元通过位于眼睛后面的纤长的视觉神经来交流彼此的激活信息并将其传入大脑，最终激活位于大脑后部视皮层的神经元。视皮层大致是由一系列按层排列的神经元组成，就像婚礼蛋糕那样一层一层堆在一起，每一层的神经元都将其激活信息传递给下一层的神经元。</p><p><strong>ConvNets识别模式：</strong> C哦女N额头上由一些列模拟神经元组成，在这里，我还是将这些模拟神经元称为单元。每层中的单元为下一层的单元提供输入，当一个ConvNets处理一张图像时，每个单元都有一个特定的激活值——根据单元的输入及其连接权重计算所得的真实的数值。ConvNets的输入是一幅图像，即与图像每个像素的颜色和亮度一一对应的一个数值组。它的最终输出是网络对于每种类别（狗或猫）的置信度（0～100%）。我们的目标是让网络学会对输入图像所属的正确类别输出高置信度，对其他类别输出低置信度。这样，网络将了解输入图像的哪些特征对完成这项任务最有帮助。</p><h3 id="机器视觉智能的3个致命短板">机器视觉智能的3个致命短板</h3><p>如今，机器智能在ImageNet上的目标识别能力是否已经超越人类的争论众说纷纭。这一论断是基于人类的错误率约为5%，而机器的错误率接近2%的一个声明，这难道无法证明计算机在这项任务上的表现比人类更好吗？答案是否定的。</p><p>第一，当你读到“一台机器正确地识别了目标”时，你会认为，给定一张篮球的图像，机器会输出“篮球”这一结果；但在ImageNet竞赛中，正确地识别仅意味着正确类别出现在机器给出的前5个输出类别中。如果给机器输入一张篮球的图像，机器按顺序输出的是门球、比基尼、疣猪、篮球和搬家货车，即可被判定是正确识别。</p><p>第二，对于“人类在ImageNet上的识别错误率为5%”这个声明，其中的“人类”一词实际上表述得并不是非常准确，因为这一结果来自被试只有一个实验。</p><p>第三，当一个人说照片中有一条狗时，我们认为这是因为人类在图像中实际上看到了一条狗，但是如果ConvNets“说”图像中有狗时，也许知识图像中有一些其他对象，如网球、飞盘、被叼住的鞋子，这些对象在训练图像中往往与狗有关，而ConvNets在识别这些对象时就会假设图像中有一条狗。这类关联的结果往往会愚弄程序，使其做出误判。</p><h3 id="难以避免的长尾效应">难以避免的长尾效应</h3><p>知名的深度学习专家本吉奥说：“实事求是地讲，我们不可能对世界上的所有食物都进行标注，并一丝不苟地把每一个细节都解释给计算机听。” 这一情况由于长尾效应的存在而进一步恶化：人工智能系统可能要面临各种可能的意外情况，自动驾驶汽车在一天的行驶期间可能会遇到各种假设情况的可能性可以很好地说明这一现象。遇到红色交通灯或停车标志等都是常见的情况，被评定为具有高可能性；中等可能性的情况包括遇到碎玻璃或者风吹过来的塑料袋；不太常见的情况是自动驾驶汽车遇到了被水淹没的道路或者被雪遮挡住的车道标志，等等。</p><p>“长尾”这个术语来自统计学，其中包含的一长串可能性低，但却可能发生的情况被称为一个概率分布的“尾巴”，尾巴上的情况优势被称为“边缘情况”。人工智能在先是世界的大多数领域中都会面对这种长尾效应；现实世界的大部分时间通常是可预测的，但仍有一长串地概率的意外事件发生。如果我们的单纯依靠监督学习来提升人工智能系统对世界的认知，那么就会存在一个问题：尾部的情况并不经常出现在训练数据中，所以当遇到这些意外情况时，系统就会更容易出错。</p><h3 id="“新机器人三定律”">“新机器人三定律”</h3><ol><li><p>有用的人工智能<br>在考虑人工智能在我们社会中的作用时，我们很容易把注意力集中在不利的一面，但是，有必要记住，人工智能系统已经为社会带来了巨大好处，并且它们有潜力发挥更大的作用。</p></li><li><p>可解释的人工智能<br>在人工智能“自动决策制定”的情况下，任何一个影响公民的决策都需要提供其中所涉及的与逻辑有关的有意义信息，并且这些信息需要使用清晰明了的语言，以简洁、透明、易懂和易于访问的形式来沟通和传达，这打开了有关解释问题的闸门。</p></li><li><p>可信的人工智能<br>在赋予计算机“道德智能”方面的进展不能与其他类型智能的进展分开，真正的挑战是创造出能够真正理解它们所面临的场景的机器。换句话说，可信任的道德理性的一个先决条件时通用的尝试，而这，正如我们所见，即使在当今最好的人工智能系统中也是缺失的。</p></li></ol><h2 id="游戏与推理：开发具有更接近人类水平的学习和推理能力的机器">游戏与推理：开发具有更接近人类水平的学习和推理能力的机器</h2><h3 id="强化学习，让AlphoGo名声大噪的幕后推手">强化学习，让AlphoGo名声大噪的幕后推手</h3><p>在最纯粹的形势下，强化学习不需要任何被标记的训练样本。代替它的是一个智能体，既学习程序，在一种特定环境（通常是计算机仿真环境）中执行一些动作，并偶尔从环境中获得奖励，这些间歇出现的奖励是智能体从学习中获得的唯一反馈。</p><p>强化学习的目标是：让智能体自己学习并获得能对即将到来的奖励进行更好的预测的值，前提是智能体在采取相关行动后一直在做正确的选择。正如我们阿奎那道德，习得给定状态下特定动作的值通常需要经过许多次试错。</p><p>尽管计算机程序可能不会对一个吻或一局热情的“你是最棒的”做出反应，但是它可以被设置为能够对与这种赞美等价的奖励做出响应，比如向机器的内存中添加正数，然后算法会高速机器如何从自己的经验中学习。</p><p>强化学习的实践者几乎都会构建机器人和环境的模拟，然后在模拟世界而非在现实世界中执行所有的学习片段，然而，环境愈复杂和不可预测，讲机器人在模拟中学到的技能转移到现实世界的尝试就愈加难以成功。迄今为止强化学习最大的成功不是在机器人领域，而是在那些能够在计算机上进行完美模拟的领域，特别是游戏领域。</p><h3 id="好的游戏，可以从更好的猜测中学习猜测">好的游戏，可以从更好的猜测中学习猜测</h3><p>如果你是那个学习智能体，当前状态下某个动作是对你在选择某一动作并持续选择高价值动作的条件下，本片段结束后你将获得多少奖励的估计，那么，越接近这一片段的结尾，估值就越准确，因为在一个片段的结尾处，你能计算出你将获得的实际讲理！其中的诀窍是：假设网络在当前迭代的输出比上一次迭代的输出更接近于正确值，然后，通过反向传播学习调整网络权重，从而使得当前与先前迭代输出之间的差异最小化。</p><p>理查德·萨顿是这种方法的鼻祖之一，他把该方法称为：从猜测中学习猜测。我把它修改为：从更好的猜测中学习猜测。简而言之，强化学习不是将其输出与人类给定的标签进行比较，而是假设后续迭代给出的值比前面迭代给出的值更好，网络学习的是使其输出在一次迭代到下一次迭代的过程中保持一致。</p><h3 id="像人一样学会迁移">像人一样学会迁移</h3><p>在机器学习领域，迁移学习是一个充满前景的学习方法，它是指一个程序将其所学的关于一项任务的知识进行迁移，以帮助其获得执行不同的相关任务的能力。对于人类来说，迁移学习是自动进行的，比如，学会打乒乓球之后，我们就能讲其中的一些技巧进行迁移来帮助我们学习打羽毛球和网球；知道如何下西洋跳棋，也有助于我们学习国际象棋。</p><p>人类这种从一种任务到另一种任务的能力迁移看起来好不费劲，我们对所学知识进行泛化的能力正式思考的核心部分。因而，我们可以说，迁移学习的另一种表达就是学习本身。</p><p>与人类形成鲜明对比的是，当今人工智能领域中的大多数学习算法在相关的任务之间是不可迁移的。在这一点上，该领域离哈萨比斯所说的通用人工智能仍然有很远的距离。尽管迁移学习是目前机器学习从业者最活跃的研究领域之一，但这方面的研究仍然处于初级阶段。</p><h2 id="自然语言：让计算机理解它所“阅读”的内容">自然语言：让计算机理解它所“阅读”的内容</h2><h3 id="理解语言，理解我们赖以生存的隐喻">理解语言，理解我们赖以生存的隐喻</h3><p>理解语言，特别是理解其中隐含的部分，是人类智能的一个基本部分。图灵把他著名的图灵测试，构造为一场关于语言之生成和理解的比赛，这决非偶然。</p><p>语言常常是充满歧义的，极度依赖语境，而且通常语言沟通的各方需要具备大量共同的背景知识。与人工智能的其他领域一样，自然语言处理相关的研究在最初的几十年集中在符号化的、基于规则的方法上，就是那种给定语法和其他语言规则，并把这些规则应用到输入语句上的方法。这些方法并没有取得很好的效果，看来通过使用一组明确的规则来捕捉语言的微妙是行不通的。自动语音识别是深度学习在自然语言处理中的第一个重大成就，并且我敢说，这是迄今为止人工智能在所有领域中取得的最重要的成就。</p><p>在深度网络开始在计算机视觉和语音识别上“得心应手”后不久，自然语言处理的研究者就开始试着把它们应用于情感分析。</p><h3 id="破解机器翻译，攀登人工智能的天梯">破解机器翻译，攀登人工智能的天梯</h3><p>在线翻译系统可以为人们提供全天候的即时翻译服务，而且通常可以处理100多种不同的语言，但是，其水平仍然远低于优秀的人类翻译员。</p><p>机器翻译的原始方法依赖于人类制定规则的复杂集合，所以，它们相当脆弱，需要面对来自自然语言处理领域所面临的所有挑战。</p><p>从20世纪90年代开始，一种被称为“统计机器翻译”的新方法开始占据主导地位，此方法依赖于从数据而非从人类制定的规则中学习。</p><p>谷歌翻译可能是目前最为广泛使用的自动翻译程序，使用的是一种更加优越的基于深度学习的翻译方法，也就是神经机器翻译。</p><p>深度学习时代的机器翻译所取得的巨大成功是由大数据和快速计算造就的，但这种成功完全是基于对单个句子翻译水平的评估，而非篇幅更长的文章。</p><h3 id="阅读理解的关键不仅在于“提取答案”，还在于“具备常识”">阅读理解的关键不仅在于“提取答案”，还在于“具备常识”</h3><p>《星际迷航》或许给我们许多人都编织了一个梦想：能够向计算机询问任何事情，并且它可以做出准确、简洁和有用的回应。如果你使用过当今任意一款人工智能语音助手，如Siri、Alexa、Cortana、Google Now，你就会知道这个梦想还尚未实现——这些系统并不能理解我们所问的问题的含义。</p><p>虽然计算机目前已经可以准确地转述我们的请求，但我们的终极目标是：让计算机真正理解我们所问的问题的含义。这本质上是一种阅读理解任务，但目前计算机其实并不能完全读懂一个特定文本中字里行间的意思，也无法做到真正的推理，比起阅读理解，计算机能做到的应该叫做“答案提取”。答案提取对机器来说是一项有用的技能，事实上，答案提取也正是Alexa、Siri以及其他数字助理软件所需要做的：将接收道德问题转换为一个搜索引擎查询序列，然后从搜索结果中提取答案。</p><p>“提问-回答”的话题一直是自然语言处理研究的一个重点。若想正确回答这些问题，不仅需要答案提取的技能，还需要具备自然语言处理和常识推理的集成能力，以及一些必要的背景知识。尽管深度学习已近在语音识别、语言翻译、情感分析及自然语言处理的其他领域取得了一些非常显著的进展，但人类水平的语言处理能力仍然是一个遥远的目标。</p><h2 id="常识——人工智能打破意义障碍的关键">常识——人工智能打破意义障碍的关键</h2><h3 id="理解力是一种预测力，而预测力与我们的经历息息相关">理解力是一种预测力，而预测力与我们的经历息息相关</h3><p>我们都拥有心理学家所说的关于世界的重要方面的“心智模型”，这个模型基于的是我们掌握的物理学和生物学上的事实、因果关系和人类行为的知识，并揭示了世界是如何运作的。心智模型不仅能够使你预测在特定情况下可能会发生什么，还能让你想象如果特定事件发生将会引发什么。</p><p>我们通过核心物理知识来理解抽象概念。如果物理意义上的“温暖”概念在心理上被激活，例如，通过手持一杯热咖啡，这也会激活更抽象、隐喻层面上的“温暖”概念。如果我们对概念和情境的理解是使用心智模型来进行模拟的，那么，也许意识以及我们对自我的全部概念，都来自我们构建并模拟自己的心智模型的能力。</p><p>我们拥有的与物理感觉相关的概念可能会激活关于自我的抽象概念，后者通过神经系统的反馈，产生一种对自我的物理感知，你也可以将这里的“自我”称为意识。这种循环因果关系类似侯世达所说的意识的“怪圈”：“符号和物理层面相互作用，并颠倒了因果关系，符号似乎拥有了自由意志，并获得了推动例子运动的自相矛盾的能力。” 我们所谓的感知、分类、识别、泛化和联想都涉及我们对所经历过的情境进行抽象的行为。</p><h3 id="我们是否可以为机器赋予常识">我们是否可以为机器赋予常识</h3><p>在人工智能发展的早期阶段，机器学习和神经网络还尚未在该领域占主导地位，那时候，人工智能研究人员还在人工地对程序执行任务所需要的规则和知识编码，对他们来说，通过“内在构建”的方法来捕捉足够的人类常识以在机器中实现人类水平的只能，看起来是完全合理的。</p><p>当深度学习开始展示其一系列非凡的成功时，不管是人工智能领域的内行还是外行，大家都乐观地认为我们即将实现通用的、人类水平的人工智能了。然而，正如本书中反复强调的那样，随着深度学习系统的应用愈加广泛，其智能正逐渐露出“破绽”。即便是最成功的系统，也无法在其狭窄的专业领域之外进行良好的泛化、形成抽象概念或者学会因果关系。此外，它们经常会犯一些不像是人类会犯的错误，以及在对抗样本上表现出的脆弱性都表明：它们并不真正理解我们教给它们的概念。</p><p>要想令人工智能实现真正的进步，就需要让及其具备常识，但是，很多处于我们潜意识里的知识，我们甚至不知道自己拥有这些知识，或者说常识，却是我们人类所共有的，而且是在任何地方都没有记载的知识。这包括我们在物理学、生物学和心理学上的许多核心直觉知识，这些知识是所有我们关于世界的更广泛的知识的基础。如果你没有有意识地认识到自己知道什么，你就不能成为向一台计算机明确地提供这些知识的专家。</p><h2 id="思考6个关键问题，激发人工智能的终极潜力">思考6个关键问题，激发人工智能的终极潜力</h2><ol><li>自动驾驶汽车还要多久才能普及？</li><li>人工智能会导致人类大规模失业吗？</li><li>计算机能够具有创造性吗？</li><li>我们距离创建通用的人类水平AI还有多远？</li><li>我们应该对人工智能感到多恐惧？</li><li>人工智能中有哪些激动人心的问题还尚未解决？</li></ol><h2 id="Reference">Reference</h2><p>[1] <a href="https://book.douban.com/subject/35351678/" target="_blank" rel="noopener">AI 3.0</a></p>]]></content>
    
    <summary type="html">
    
      “现在的人工智能可以做什么，以及在未来几十年我们能从它们身上期待什么”。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的记忆法</title>
    <link href="https://neo1989.net/CheatSheet/CHEATSHEET-memorization-techniques/"/>
    <id>https://neo1989.net/CheatSheet/CHEATSHEET-memorization-techniques/</id>
    <published>2022-09-23T06:56:52.000Z</published>
    <updated>2023-01-06T08:06:00.132Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">记忆法</th><th style="text-align:center">概述</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">反复出声读</td><td style="text-align:center">反复出声读自己想记的内容</td><td style="text-align:center">无须准备，简单易行</td><td style="text-align:center">过程中一旦出错，就会不小心把错误的内容给记下来。单单使用这种方法无法确定自己究竟有没有记住</td></tr><tr><td style="text-align:center">反复抄写</td><td style="text-align:center">反复抄写自己想记的内容</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">反复读同时抄写</td><td style="text-align:center">上述两种方法的结合</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">留出时间来复习</td><td style="text-align:center">确认一下自己之前记忆的是否牢固</td><td style="text-align:center">防止“一旦记住就再也不管了”的情况</td><td style="text-align:center">很容易忘记去复习</td></tr><tr><td style="text-align:center">记忆唤起</td><td style="text-align:center">遮住正确答案，努力会想，然后立刻确认自己的回答是否正确。多次重复这一过程。单词卡就是该方法的一种应用</td><td style="text-align:center">一旦记忆出现偏差，可以立刻修正。不会出现“自以为记住了但是其实没记住”的情况</td><td style="text-align:center">很难用来记忆那些无法一次性处理的信息，例如比较长的单词和文章</td></tr><tr><td style="text-align:center">SAFMEDS法</td><td style="text-align:center">全称为 Say All Fast Minute EveryDay Suffle，把问题卸载卡片的正面，答案写在卡片的背面，没图打乱卡片顺序后，在一分钟內用最快的速度回答卡片上的问题，并记录自己答对的题数，制作成图表</td><td style="text-align:center">能够一眼看出自己记住了多少内容，有助于提升积极性</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">间隔复习法</td><td style="text-align:center">逐渐拉长复习的间隔</td><td style="text-align:center">比单纯的复习记忆的更牢固</td><td style="text-align:center">需要安排并且记住复习的时间点，比较麻烦</td></tr><tr><td style="text-align:center">DWM(Day-Week-Month)法</td><td style="text-align:center">复习一天前、一周前和一个月前记忆过的内容</td><td style="text-align:center">复习的时间点更好记</td><td style="text-align:center">需要想一想一个月后的复习要如何安排</td></tr><tr><td style="text-align:center">35分钟模拟法</td><td style="text-align:center">以35分钟为一个模块，结合DWM法来复习</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">SRS笔记</td><td style="text-align:center">用一个笔记本来管理间隔复习的时间点和想要记忆的内容</td><td style="text-align:center">同上</td><td style="text-align:center">随着想要记忆的内容不断增加，笔记本会变得越来越厚</td></tr><tr><td style="text-align:center">SRS软件</td><td style="text-align:center">使用Anki、Logseq等SRS软件来记忆</td><td style="text-align:center">App会自动帮我们设定时间，且不会变厚</td><td style="text-align:center">需要电脑或手机</td></tr><tr><td style="text-align:center">短间隔复述法</td><td style="text-align:center">听到或看到想要记忆的内容，反复出声复述，并逐渐拉长复述的间隔时间</td><td style="text-align:center">无须准备，简单易行</td><td style="text-align:center">过程中一旦出错，就会不小心把错误的内容给记下来。单单使用这种方法无法确定自己究竟有没有记住</td></tr><tr><td style="text-align:center">自我测试法</td><td style="text-align:center">自己出一份试卷，然后自己作答</td><td style="text-align:center">一旦记忆出现偏差，可以立刻修正。不会出现“自以为记住了但是其实没记住”的情况</td><td style="text-align:center">出试卷很费功夫</td></tr><tr><td style="text-align:center">反复答题法</td><td style="text-align:center">反复回答简单的问题，达到记忆的目的</td><td style="text-align:center">能够发现自己记错或是记忆不准确的部分，及时修正。适合用力啊提高记忆的精确性和回想的速度</td><td style="text-align:center">容易厌烦。正确率提升后会逐渐失去动力</td></tr><tr><td style="text-align:center">LowFirst</td><td style="text-align:center">按照错误率从高到低的顺序来复习。剔除低错误率的项目以提高复习效率</td><td style="text-align:center">比间隔复习法的效率高</td><td style="text-align:center">计算错误率，安排复习时间的过程比较麻烦</td></tr><tr><td style="text-align:center">影像记忆法</td><td style="text-align:center">在脑中将想记的内容转换成影像来记忆</td><td style="text-align:center">记忆会更容易在脑内扎根</td><td style="text-align:center">不一定适合所有人。对于不熟练的人来说，想象的过程可能会很费时间</td></tr><tr><td style="text-align:center">联想记忆法</td><td style="text-align:center">想一想自己看到这些内容后首先联想到了什么，将二者联系起来记忆</td><td style="text-align:center">利用自己脑内产生的联想来记忆，会更容易一些</td><td style="text-align:center">不一定适合所有人。对于不熟练的人来说，联想的过程可能会很费时间</td></tr><tr><td style="text-align:center">谐音记忆法</td><td style="text-align:center">把想记的内容换成其他发音相似的字，变成不通的意思</td><td style="text-align:center">在记忆数字时使用这种方式，会比直接记忆更有效</td><td style="text-align:center">想谐音会比较麻烦</td></tr><tr><td style="text-align:center">关键词记忆法</td><td style="text-align:center">找到母语中发音比较相似的词，在想象中将二者联系起来</td><td style="text-align:center">在记忆数字和外语单词时是用这种方式，会比直接记忆更有效</td><td style="text-align:center">有时很难从母语中找到发音相似的词</td></tr><tr><td style="text-align:center">利用韵律来记忆</td><td style="text-align:center">-</td><td style="text-align:center">在记忆数字和外语单词时是用这种方式，会比直接记忆更有效</td><td style="text-align:center">对押韵不熟悉的人很难应用</td></tr><tr><td style="text-align:center">自我关联记忆法</td><td style="text-align:center">把想记的内容写到一篇与自己相关的文章中</td><td style="text-align:center">与自己相关的事物记忆起来会更容易</td><td style="text-align:center">写文章比较麻烦</td></tr><tr><td style="text-align:center">故事记忆法</td><td style="text-align:center">把想记的内容编成一个故事</td><td style="text-align:center">故事记忆起来会更容易一些</td><td style="text-align:center">编故事比较麻烦</td></tr><tr><td style="text-align:center">歌词记忆法</td><td style="text-align:center">把想记的内容编成一首歌</td><td style="text-align:center">伴随着旋律去记忆，印象会更深刻</td><td style="text-align:center">编歌词和旋律的过程比较麻烦</td></tr><tr><td style="text-align:center">首字母记忆法</td><td style="text-align:center">把想记的内容的首字母提取出来，串联成一个单词</td><td style="text-align:center">更好记一些，回想起来也更容易</td><td style="text-align:center">首字母组成的新单词有时候会很难拼写</td></tr><tr><td style="text-align:center">记忆桩</td><td style="text-align:center">把已知的事物（记忆桩）和想记的内容在想象中联系起来</td><td style="text-align:center">更好记一些，回想起来也更容易</td><td style="text-align:center">刚开始还不熟练的适合，这个想象的过程会花费不少时间</td></tr><tr><td style="text-align:center">系统化记忆法</td><td style="text-align:center">通过重新归纳整理来记忆</td><td style="text-align:center">经过处理的信息很难忘记，还易于应用</td><td style="text-align:center">由于需要先理解，所以比较花时间</td></tr><tr><td style="text-align:center">类推记忆法</td><td style="text-align:center">通过上下文推测单词的意思，从而达到记忆的目的</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">记忆树</td><td style="text-align:center">以记忆的主题为树干，将相关的内容写到枝叶的位置上</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">凝缩笔记法</td><td style="text-align:center">像打小抄一样，把考试范围內的活字典全部都总结到一张小纸片上</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">康奈尔笔记法</td><td style="text-align:center">把笔记本上的一页分成三栏（正文、标题-评论、摘要），利用评论和摘要来复习</td><td style="text-align:center">同上，加入了复习机制，十分有效</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">互测法</td><td style="text-align:center">两个人分别出一份试卷，然后交换作答</td><td style="text-align:center">比自测法更高效</td><td style="text-align:center">需要一个学习伙伴</td></tr><tr><td style="text-align:center">交互式教学</td><td style="text-align:center">两个人一遍对话，一边使用预测、提问、总结和析疑四种策略来理解文章</td><td style="text-align:center">经过处理的信息很难忘记，还易于应用。在社会性相互作用下，使用过的信息会记得更牢固一些</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">情感关联法</td><td style="text-align:center">将内容与情感联系起来记忆</td><td style="text-align:center">情感越是强烈，与之相关的记忆就越牢固</td><td style="text-align:center">激发感情是一件难事</td></tr><tr><td style="text-align:center">情景记忆法</td><td style="text-align:center">将能够用到这些内容的场景还原出来，在场景下记忆</td><td style="text-align:center">还原的场景与实际场景越相似，回忆起来就越容易</td><td style="text-align:center">如果还原不出相似的场景，那就能难使用这个方法</td></tr><tr><td style="text-align:center">早期学习状态重置法</td><td style="text-align:center">回想第一次学汉子、骑自行车、背乘法口诀时的场景，将自己还原到当时的状态中</td><td style="text-align:center">这样能够重拾记忆力旺盛的心理状态</td><td style="text-align:center">效果具体如何尚不明确</td></tr><tr><td style="text-align:center">极端状态法</td><td style="text-align:center">把自己放到一种极端的状态下</td><td style="text-align:center">当自己所拥有的只是在新的环境完全派不上用场时，为了能够生存，学习效率会大幅提升</td><td style="text-align:center">可能对注意力的集中有危害</td></tr><tr><td style="text-align:center">张贴记忆法</td><td style="text-align:center">把想记的内容贴在自己平时经常会看到的地方</td><td style="text-align:center">把记忆需要付出的努力最小化</td><td style="text-align:center">效率不高，需要做一定的准备</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      理解是最棒的记忆法
    
    </summary>
    
    
      <category term="CheatSheet" scheme="https://neo1989.net/categories/CheatSheet/"/>
    
    
      <category term="SoftSkills" scheme="https://neo1989.net/tags/SoftSkills/"/>
    
  </entry>
  
  <entry>
    <title>Golang小记</title>
    <link href="https://neo1989.net/Notes/NOTE-key-points-for-mastering-golang/"/>
    <id>https://neo1989.net/Notes/NOTE-key-points-for-mastering-golang/</id>
    <published>2022-02-28T08:31:59.000Z</published>
    <updated>2023-03-01T10:50:20.672Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Go的设计哲学">Go的设计哲学</h3><p>Go在语言层面的简单让Go收货了不逊于C++/Java等的表现力的同时，还获得了更好的可读性、更高的开发效率等在软件工程领域更为重要的元素。<br>“高内聚、低耦合”。Go崇尚通过组合的方式将正交的语法元素组这在一起来形成应用程序骨架，接口就是在这一哲学下诞生的语言精华。<br>Go语言提供了内置于语言中的简单并发原语——go（goroutine）、channel和select，大幅降低了开发人员在云计算多核时代编写大规模并发网络服务程序时的心智负担。</p><p>Go工具链:</p><pre><code>构建和运行：go build / go run依赖包查看与获取：go list / go get / go mod xx编辑辅助格式化：go fmt / gofmt文档查看：go doc / godoc单元测试/基准测试/测试覆盖率：go test代码静态分析：go vet性能剖析与跟踪结果查看：go tool pprof / go tool trace升级到新Go版本API的辅助工具：go tool fix报告Go语言bug：go bug</code></pre><h3 id="使用Go命名惯例对标识符进行命名">使用Go命名惯例对标识符进行命名</h3><p>Go语言追求简单一致且利用上下文辅助名字信息传达的命名惯例。</p><h3 id="使用一致的变量的声明形式">使用一致的变量的声明形式</h3><p>如图示，要想做好代码中变量声明的一致性，需要明确要声明的变量是包级变量还是局部变量、是否要延迟初始化、是否接受默认类型、是否为分支控制变量，并结合聚类和就近原则。</p><p><img src="//s3.mindex.xyz/blog/Notes/61917c13d1270327ea4531de658f8058.png" alt="变量声明形式使用决策流程图"></p><h3 id="使用无类型常量简化代码">使用无类型常量简化代码</h3><p>所有常量表达式的求值计算都可以在编译期而不是在运行期完成，这样既可以减少运行时的工作，也能方便编译器进行编译优化。当操作数是常量时，在编译时也能发现一些运行时的错误，例如整数除零、字符串索引越界等。<br>无类型常量是Go语言推荐的实践，它拥有和字面值一样的零或特性，可以直接用于更多的表达式而不需要进行显示类型转换，从而简化了代码编写。此外，按照<a href="https://go.dev/ref/spec" target="_blank" rel="noopener">Go官方语言规范</a>的描述，数值型无类型常量可以提供比基础类型更高精度的算术运算，至少有256bit的运算精度。</p><h3 id="使用iota实现枚举常量">使用iota实现枚举常量</h3><h3 id="尽量定义零值可用的类型">尽量定义零值可用的类型</h3><p>Go语言零值可用的理念给内置类型、标准库的使用者带来很多遍历。不过Go并非所有类型都零值可用的，并且零值可用也有一定的限制，比如：</p><p>在append场景下，零值可用的切片类型不能通过下标形式操作数据:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="number">12</span>           <span class="comment">// 报错！</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">12</span>)   <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>另外，像map这样的原生类型也没有提供对零值可用的支持：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">m[<span class="string">"go"</span>] = <span class="number">1</span>         <span class="comment">// 报错！</span></span><br><span class="line"></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">m1[<span class="string">"go"</span>] = <span class="number">1</span>        <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>另外零值可用的类型要注意尽量避免值复制：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu1 := mu       <span class="comment">// 错误：避免值复制</span></span><br><span class="line">foo(mu)         <span class="comment">// 错误：避免值复制</span></span><br></pre></td></tr></table></figure><p>我们可以通过指针方式传递类似Mutex这样的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">foo(&amp;mu)        <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>保持与Go一致的理念，给自定义的类型一个合理的零值，并尽量保持自定义类型的零值可用，这样我们的Go代码会更加复合Go语言的惯用法。</p><h3 id="使用复合字面值作为初值构造器">使用复合字面值作为初值构造器</h3><p>对于零值不适用的场景，我们要为变量赋予一定的初值。对于复合类型，我们应该首选Go提供的复合字面值作为初值构造器。对于不同复合类型，我们要记住下面几点：</p><ul><li>使用field: value 形式的复合字面值为结构体类型的变量赋初值。</li><li>在为稀疏元素赋值或让编译器推导数组大小的时候，多使用index: value的形式为数组/切片类型变量赋初值。</li><li>使用key: value形式的复合字面值为map类型的变量赋初值。（Go 1.5版本后，复合字面值中的key和value类型均可以省略不写。）</li></ul><h3 id="了解切片实现原理并高效使用">了解切片实现原理并高效使用</h3><p>切片是数组的描述符，在大多数场合替代了数组，并减少了数组指针作为函数参数的使用。<br>append在切片上的运用让切片类型部分支持了“零值可用”的理念，并且append对切片的动态扩容将Gopher从手工管理底层存储的工作中解放出来。<br>在可以预估初元素容量的前提下，使用cap参数创建切片可以提升append的平均操作性能，减少或消除因动态扩容带来的性能损耗。</p><h3 id="了解map实现原理并高效使用">了解map实现原理并高效使用</h3><ul><li>不要依赖map的元素遍历顺序</li><li>map不是线程安全的，不支持并发写</li><li>不要尝试获取map中元素（value）的地址</li><li>尽量使用cap参数创建map，以提升map平均访问性能，减少频繁扩容带来的不必要损耗</li></ul><h3 id="了解string实现原理并高效使用">了解string实现原理并高效使用</h3><p>Go语言内置了string类型，统一了对字符串的抽象，并且为string类型提供提供了强大的内置操作支持，包括基于<code>+/+=</code>的字符串连接操作，基于<code>==、!=、&gt;、&lt;</code>等的比较操作，O(1)复杂度的长度获取操作，对非ASCII字符提供原生支持，对string类型与slice类型的相互转换提供优化等。<br>此外，Go语言还在标准库中提供了strings和strconv包，可以辅助Gopher对string类型数据进行更多高级操作。</p><h3 id="理解Go语言的包导入">理解Go语言的包导入</h3><ul><li>Go编译器在编译过程种必然要使用的是编译单元（一个包）所依赖的包的源码</li><li>Go源码文件头部的包导入语句中import后面的部分是一个路径，路径的最后一个分段是目录名，而不是包名。</li><li>Go编译器的包源码搜索路径由基本搜索路径和包导入路径组成，两者结合在一起后，编译器便可确定一个包的所有依赖包的源码路径的集合，这个集合构成了Go编译器的源码搜索路径空间。</li><li>同一源码文件的依赖包在同一源码搜索路径空间下的包名冲突问题可以由显示指定包名的方式解决。</li></ul><h3 id="理解Go语言表达式的求值顺序">理解Go语言表达式的求值顺序</h3><ul><li>包级别变量声明语句中的表达式求值顺序由变量的声明顺序和初始化依赖关系决定，并且包级变量表达式求值顺序优先级最高。</li><li>表达式操作数中的函数、方法及channel操作按普通求值顺序，即从左到右的次序进行求值。</li><li>赋值语句求值分为两个阶段：先按照普通求值规则对等号左边的下标表达式、指针解引用表达式和等号右边的表达式中的操作数进行求值，然后按从左到右的顺序对变量进行赋值。</li><li>重点关注switch-case和select-case语句中的表达式“惰性求值”规则。</li></ul><h3 id="理解Go语言代码块与作用域">理解Go语言代码块与作用域</h3><h3 id="了解Go语言控制语句惯用法及使用注意事项">了解Go语言控制语句惯用法及使用注意事项</h3><ul><li>使用if语句时遵循“快乐路径”原则</li><li>小心for range的循环变量重用，明确真实参与循环的是range表达式的副本</li><li>明确break和continue执行后的真实“目的地”</li><li>使用fallthrough关键字前，考虑能否用简洁、清晰的case表达式列表替代</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">"快乐路径"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    当出现错误时，快速返回</span></span><br><span class="line"><span class="comment">    成功逻辑不要嵌入if-else语句中</span></span><br><span class="line"><span class="comment">    “快乐路径”的执行逻辑在代码布局上始终靠左，这样读者可以一眼看到该函数的正常逻辑流程</span></span><br><span class="line"><span class="comment">    “快乐路径”的返回值一般在函数最后一行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "快乐路径"伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> errorCond1 &#123;</span><br><span class="line">        <span class="comment">// 错误逻辑</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> err1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成功逻辑</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> errorCond2 &#123;</span><br><span class="line">        <span class="comment">// 错误逻辑</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> err2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成功逻辑</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在init函数中检查包级变量">在init函数中检查包级变量</h3><ul><li>init函数有几个特点：运行时调用、顺序、仅执行一次</li><li>init函数是包出厂前的唯一“质检员”</li><li>记住Go程序的初始化顺序<br><img src="//s3.mindex.xyz/blog/Notes/c9aa6b692a70d019fe7ced19e982ec1d.png" alt="Go程序初始化顺序"></li></ul><h3 id="让自己习惯于函数是“一等公民”">让自己习惯于函数是“一等公民”</h3><ul><li>Go函数可以像变量值那样被赋值给变量、作为参数传递、作为返回值返回和在函数内部创建等</li><li>函数可以像变量那样被显示类型转换</li><li>基于函数特质，了解Go中的几种有用的函数式编程风格，如<a href="https://zh.wikipedia.org/zh/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="noopener">柯里化</a>、函子等</li><li>不要为了复合特定风格而滥用函数特质</li></ul><h3 id="使用defer让函数更简洁、更健壮">使用defer让函数更简洁、更健壮</h3><ul><li>理解defer的运作机制，即deferred函数注册与调度执行</li><li>了解defer的常见用法</li><li>了解关于defer使用的几个关键问题，避免入“坑”</li></ul><h3 id="理解方法的本质以选择正确的receiver类型">理解方法的本质以选择正确的receiver类型</h3><ul><li>Go方法的本质：一个以方法所绑定类型实例为第一个参数的普通函数。。</li><li>Go语法糖使得我们在通过类型实例调用类型方法时无须考虑实例类型与receiver参数类型是否一致，编译器会为我们做自动转换。</li><li>在选择receiver参数类型时要看是否要对类型实例进行修改。如有修改需求，则选择<code>*T</code>；如无修改需求，T类型receiver传值的性能损耗也是考量因素之一。</li></ul><h3 id="方法集合决定接口实现">方法集合决定接口实现</h3><ul><li>方法集合是类型与接口间隐式关系的纽带，只有当类型的方法集合是某接口类型的超集时，我们才说类型实现了某接口</li><li>类型T的方法集合是以T为receiver类型的所有方法的集合，类型<code>*T</code>的方法集合是以<code>*T</code>为receiver类型的所有方法的集合与类型T的方法集合的并集</li><li>了解类型嵌入对接口类型和自定义结构体类型的方法集合的影响</li><li>基于接口类型创建的defined类型与原类型具有相同的方法集合，而基于自定义非接口类型创建的defined类型的方法集合为空</li><li>类型别名与原类型拥有完全相同的方法集合</li></ul><h3 id="了解变长参数函数的妙用">了解变长参数函数的妙用</h3><ul><li>了解变长参数函数的特点和约束</li><li>变长参数可以在有限情况下模拟函数重载、可选参数和默认参数，但要谨慎使用，不要造成混淆</li><li>利用变长参数函数实现功能选项模式</li></ul><h3 id="了解接口类型变量的内部表示">了解接口类型变量的内部表示</h3><ul><li>接口类型变量在运行时表示为eface和iface，eface用于表示空接口类型变量，iface用于表示非空接口类型变量</li><li>当且仅当两个接口类型变量的类型信息（eface.__type / iface.tab.__type）相同，同数据指针（eface.data / iface.data）所指数据相同时，两个接口类型才是相等的</li><li>通过println可以输出接口类型变量的两部分指针变量的值</li><li>可通过复制runtime包eface和iface相关类型源码，自定义输出eface/iface详尽信息的函数</li><li>接口类型变量的装箱操作由Go编译器和运行时共同完成</li></ul><h3 id="尽量定义小接口">尽量定义小接口</h3><ul><li>接口是将对象的行为进行抽象而形成的契约</li><li>Go青睐定义小接口，即方法数量为1~3个、通常为1个的接口 (<a href="//github.com/bigwhite/itfmc" target="_blank" rel="noopener">接口方法数量统计工具</a>)</li><li>小接口抽象程度高，被接纳度高，易于实现和测试，易于复用组合</li><li>先抽象出接口，再拆分为小接口，另外接口的契约职责应尽可能保持单一</li></ul><h3 id="尽量避免使用空接口作为函数参数类型">尽量避免使用空接口作为函数参数类型</h3><h3 id="使用接口作为程序水平组合的连接点">使用接口作为程序水平组合的连接点</h3><ul><li>深入理解Go的组合设计哲学</li><li>垂直组合可实现方法实现和接口定义的重用</li><li>掌握使用接口作为程序水平组合的连接点的几种形式</li></ul><h3 id="使用接口提高代码的可测试性">使用接口提高代码的可测试性</h3><p>适当抽取接口，让接口成为好代码与单元测试之间的桥梁是Go语言的一种最佳实践。</p><h3 id="优先考虑并发设计">优先考虑并发设计</h3><p>并发在程序的设计和实现阶段，并行在程序的执行阶段。</p><h3 id="了解goroutine的调度原理">了解goroutine的调度原理</h3><ul><li>了解goroutine调度器要解决的主要问题</li><li>了解gorutine调度器的调度模型演进</li><li>掌握goroutine调度器当前G-P-M调度模型的运行原理</li><li>掌握gorutine调度器状态查看方法</li><li>学习goroutine调度实例分析方法</li></ul><h3 id="掌握Go并发模型和常见并发模式">掌握Go并发模型和常见并发模式</h3><ul><li>了解基于CSP的并发模型与传统基于共享内存的并发模型的区别</li><li>了解Go为实现CSP模型而提供的并发原语及功能</li><li>掌握常见的并发模型，包括创建模式、多种退出模式、管道模式、超时和取消模式等</li></ul><h3 id="了解channel的妙用">了解channel的妙用</h3><ul><li>了解Go并发原语channel和select的基本语义</li><li>掌握无缓冲channel在信息传递、替代锁同步场景下的应用模式</li><li>掌握带缓冲channel在消息队列、计数信号量场景下的应用模式，了解在特定场景下利用len函数侦测带缓冲channel的状态</li><li>了解nil channel在特定场景下的用途</li><li>掌握select与channel结合使用的一些惯用法及注意事项</li></ul><h3 id="了解sync包的正确用法">了解sync包的正确用法</h3><ul><li>明确sync包中原语应用的适用场景</li><li>sync包内定义的结构体或包含这些类型的结构体在首次使用后禁止复制</li><li>明确sync.RWMutex的使用场景</li><li>掌握条件变量的应用场景和使用方法</li><li>实现单利模式时优先考虑sync.Once</li><li>了解sync.Pool的优点，使用中可能遇到的问题及解决方法</li></ul><h3 id="使用atomic包实现伸缩性更好的并发读取">使用atomic包实现伸缩性更好的并发读取</h3><p>随着并发量提升，使用atomic实现的共享变量的并发读写性能表现更为稳定，尤其是原子读操作，这让atomic与sync包中的原语比起来表现出更好的伸缩性和更高的性能。<br>atomic包更适合一些对性能十分敏感、并发量较大且读多写少的场合。<br>但atomic原子操作可用来同步的范围有较大限制，仅是一个整型变量或自定义类型变量。如果要对一个复杂的临界区数据进行同步，那么首选依旧是sync包中的原语。</p><h3 id="了解错误处理的4种策略">了解错误处理的4种策略</h3><ul><li>尽量使用透明错误处理策略降低错误处理方与错误值构造方之间的耦合</li><li>如果可以通过错误值类型的特征进行错误检视，那么尽量使用错误行为特征检视策略</li><li>在上述两种策略无法实施的情况下，再用“哨兵”策略和错误值类型检视策略</li><li>在Go1.13及后续版本中，尽量用errors.Is和errors.As方法替换原先的错误检视比较语句</li></ul><h3 id="尽量优化反复出现的-if-err-nil">尽量优化反复出现的 <code>if err != nil</code></h3><ul><li>使用显示错误结果和显示的错误检查是Go语言成功的重要因素，也是<code>if err != nil</code>反复出现的根本原因</li><li>了解关于改善Go错误处理的两种观点</li><li>了解减少甚至消除<code>if err != nil</code>代码片段的两个优化方向，即改善视觉呈现与降低复杂度</li><li>掌握错误处理代码优化的四种常见方法，并根据所处场景与约束灵活使用</li></ul><h3 id="不要使用panic进行正常的错误处理">不要使用<code>panic</code>进行正常的错误处理</h3><ul><li>深入理解不要使用panic进行正常错误处理的原因</li><li>Go标准库中panic的常见使用场景</li><li>理解程序发生panic时输出的栈帧信息有助于快速定位bug，找出“元凶”</li></ul><h3 id="理解包内测试与包外测试的差别">理解包内测试与包外测试的差别</h3><h3 id="有层次地组织测试代码">有层次地组织测试代码</h3><h3 id="优先编写表驱动的测试">优先编写表驱动的测试</h3><h3 id="使用testdata管理测试依赖的外部数据文件">使用testdata管理测试依赖的外部数据文件</h3><h3 id="正确运用fake、stub和mock等辅助单元测试">正确运用fake、stub和mock等辅助单元测试</h3><h3 id="使用模糊测试让潜在bug无处遁形">使用模糊测试让潜在bug无处遁形</h3><h3 id="为被测对象建立性能基准">为被测对象建立性能基准</h3><h3 id="使用pprof对程序进行性能剖析">使用pprof对程序进行性能剖析</h3><h3 id="使用expvar输出度量数据，辅助定位性能瓶颈点">使用expvar输出度量数据，辅助定位性能瓶颈点</h3><h3 id="使用Delve调试Go代码">使用Delve调试Go代码</h3><h3 id="Reference">Reference</h3><p><a href="https://www.amazon.cn/dp/B09P57NF34" target="_blank" rel="noopener">Go语言精进1</a><br><a href="https://www.amazon.cn/dp/B09P58GCD6" target="_blank" rel="noopener">Go语言精进2</a></p>]]></content>
    
    <summary type="html">
    
      “只要学不死，就往死里学。”
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
  </entry>
  
  <entry>
    <title>《软件架构师的12项修炼》</title>
    <link href="https://neo1989.net/Notes/NOTE-12-more-essential-skills-for-software-architects/"/>
    <id>https://neo1989.net/Notes/NOTE-12-more-essential-skills-for-software-architects/</id>
    <published>2022-02-08T08:32:37.000Z</published>
    <updated>2023-01-13T02:59:38.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Project-Skills">Project Skills</h2><h3 id="Partnership">Partnership</h3><p>The road to partnerships begins with</p><ul><li>Establishing alignment<ul><li>Finding the right partners</li><li>Finding the thought leaders</li><li>Knowing the influencers</li><li>Establishing trusted advisers</li><li>Leveraging community review</li><li>Aligning a shared vision</li></ul></li><li>Establishing trust<ul><li>Establishing open disclosure</li><li>Avoiding overcommitment</li><li>Learning to occasionally say no</li></ul></li><li>Establishing context<ul><li>Understanding the nature of the partnership</li><li>Being knowledgeable of the business context</li><li>Framing technical decisions with a partnership</li><li>Realizing that technical decisions are political decisions</li><li>Learning to sell with a context</li><li>Having your partners’ backs</li><li>Realizing there is safety in numbers</li></ul></li><li>Establishing collaboration<ul><li>Bringing value to the table</li><li>Being willing to be a mentor and knowing when to seek a mentor</li><li>Recognizing oppourtunities</li><li>Enabling ideation</li></ul></li><li>Establishing relationships<ul><li>Being more than just about business</li><li>Making deposits before you begin withdrawing</li><li>Leveraging external relationships</li><li>Overcoming bad experiences from the past</li><li>Avoiding caustic members of the organization</li></ul></li></ul><h3 id="Discovery">Discovery</h3><p>The road to discovery begins with</p><ul><li>Understanding your customer<ul><li>Partnering with sales, marketing, and new product development</li><li>Visualizing your products from the vantage point of the customer</li><li>Preparing for customer visits</li><li>Meeting with customers</li><li>Recapping information learned from customer visits</li><li>Focusing on capturing the voice of the customer</li><li>Seeking to delight the customer</li></ul></li><li>Understanding the market in which your products compete<ul><li>Learning about your customers’ customers</li><li>Discovering where your customers are willing to spend money</li><li>Keeping an eye on the competition</li><li>Listening for themes across customers</li></ul></li><li>Understanding your business<ul><li>Learning what your business wants to do</li><li>Personalizing your company’s goal</li><li>Developing a business context for decision making</li></ul></li></ul><h3 id="Conceptualization">Conceptualization</h3><p>The road to conceptualization begins with</p><ul><li>Ideation with bussiness partnerships</li><li>Getting involved as early as possible in the process</li><li>Concept formulation<ul><li>Understanding the language of the customer</li><li>Developing domain models</li><li>Understanding the context of the customer</li><li>Committing cautiously when you are the new kid on the block</li><li>Visualizing the concept</li></ul></li><li>Concept reification<ul><li>Developing a minimum viable product</li><li>Experimenting with prototypes</li><li>Establishing assumptions</li><li>Establishing essential capabilities and customer roles</li><li>Reifying with customers</li></ul></li><li>Concept evolution<ul><li>Being a student of history</li><li>Embracing multiple perspectives</li><li>Recognizing adjacent opportunities</li></ul></li></ul><h3 id="Estimation">Estimation</h3><p>The road to estimation begins with</p><ul><li>Understanding the purpose of the estimate being sought</li><li>Understanding the project context</li><li>Understanding the estimating process</li><li>Developing an architectural approach</li><li>Knowing the estimating strategies and principles</li><li>Knowing how to bring it all together</li></ul><h3 id="Management">Management</h3><p>The road to management begins with</p><ul><li>Striving toward technology excellence</li><li>Delivering projects</li><li>Resolving issue</li><li>Partnering with executives</li><li>Managing your time</li><li>Grooming technical talent</li><li>Enhancing your skill set</li></ul><h2 id="Technology-Skills">Technology Skills</h2><h3 id="Platform-development">Platform development</h3><p>The road to platform development begins with</p><ul><li>Managing platform capabilities<ul><li>Defining the set of platform objectives</li><li>Defining the set of platform capabilities</li><li>Focusing on leverageable capabilities</li><li>Developing a strong conceptual model</li><li>Embracing APIs, configuration, and eventing as the keys to the platform</li></ul></li><li>Focusing on the platform ecosystem<ul><li>Konwing the platform users</li><li>Understanding platform ownership</li><li>Understanding platform management</li><li>Driving platform development</li><li>Acknowledging platform costs</li><li>Managing platform quality</li><li>Understanding platform integration</li></ul></li><li>Guiding the platform growth through principles</li></ul><h3 id="Architetectural-Perspective">Architetectural Perspective</h3><p>The road to architectural perspective begins with</p><ul><li>Knowing and understanding architectural principles</li><li>Knowing and understanding key areas of architectural concern</li><li>Creating architectural artifacts to bring clarity to what is being created</li></ul><h3 id="Governance">Governance</h3><p>The road to governance begins with</p><ul><li>Getting management support and sponsorship to do governance activities</li><li>Understanding and embrancing the governance and the underlying principles</li><li>Using governance as a mechanism to help guide both the architecture and its associated systems</li><li>Focusing on creating value for the business, not undue process</li></ul><p>The key is to find the right balance of governance and help mitigate risks, help reduce costs, and help promote leverage for the business.</p><h3 id="Know-how">Know-how</h3><p>The road to konw-how begins with</p><ul><li>Engaging in activities that increase your know-how</li><li>Expanding the basis of your knowledge</li><li>Staying current with the directions of the industry</li><li>Filling in any gaps that are critical to your area of responsibility</li><li>Staying passionate about software</li></ul><p>Software architecture is a great job and requires broad, active know-how to be successful in decision making. The great challenge is to balance the incessant demands on your time with the need to stay relevant. There will always be far more things to do than you can possibly get done. The keys are to</p><ul><li>Focus on what will provide high value to the business</li><li>Avoid major misses that will make executives unhappy</li><li>Follow the areas you are naturally passionate about</li><li>Surround yourself with experts and maintain a strong professional network</li></ul><h2 id="Visionary-Skills">Visionary Skills</h2><h3 id="Techology-Innovation">Techology Innovation</h3><p>The road to technology innovation begins with</p><ul><li>Being aware of the trends</li><li>Aligning with the business</li><li>Engaging in strategic research</li><li>Using innovation principles</li><li>Being a pragmatic technology innovator<br>Watching and following trends can be fun and exciting. They can easily distract you from the job at hand. However, they are also the eyes into the future that may provide opportunity or peril. Architects need to be familiar with the trends that are swirling around them and approach them with caution.<br>Technology innovation is a critical aspect of soft ware architecture. Learning when and where to introduce new and potentially disruptive technologies into the business is essential for business growth and operational stability.</li></ul><h3 id="Strategic-Roadmapping">Strategic Roadmapping</h3><p>The path to roadmapping begins with</p><ul><li>Understanding the elements of roadmapping</li><li>Leveraging the roadmapping strategies</li><li>Understanding the roadmapping principles</li><li>Knowing where roadmaps are best used</li><li>Being observant of new risks</li><li>Socializing the roadmap</li><li>Knowing your role in roadmap development</li><li>Celebrating milestone successes<br>For architects, roadmaps are an essential communication tool for helping to establish a vision of what needs to be accomplished and its approximate sequencing. When the business and architecture are on the same page regarding where a product or platform is going, this partnership can help propel the success of the business.</li></ul><h3 id="Entrepreneurial-Execution">Entrepreneurial Execution</h3><p>The road to entrepreneurial execution begins with</p><ul><li>Understanding the elements of entrepreneurial execution<ul><li>Entrepreneurial spirit</li><li>Calculated risk taking</li><li>Delivering results</li></ul></li><li>Using entrepreneurial execution principles as guidance<ul><li>Affordable Loss Principle</li><li>Lemonade Principle</li><li>Patchwork Quilt Principle</li><li>Bird-in-the-Hand Principle</li><li>Pilot-in-the-Plane Principle</li><li>Seize the moment</li><li>Follow your passion</li><li>Learn to pivot</li><li>Learn by doing and making mistakes</li><li>Seek feedback</li><li>Seek leverage</li></ul></li><li>Architecting with entrepreneurial execution</li></ul>]]></content>
    
    <summary type="html">
    
      The most complicated skill is to be simple.
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="SoftSkills" scheme="https://neo1989.net/tags/SoftSkills/"/>
    
  </entry>
  
  <entry>
    <title>The End Is Not the End, 2021</title>
    <link href="https://neo1989.net/SeizeTheDay/SUMMARY-2021/"/>
    <id>https://neo1989.net/SeizeTheDay/SUMMARY-2021/</id>
    <published>2021-12-31T14:12:00.000Z</published>
    <updated>2022-11-19T03:26:18.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>和喜欢的人，做喜欢的事，过喜欢的生活。</p></blockquote><h3 id="〖-2021-〗">〖 2021! 〗</h3><ul><li>第一次在上海过春节</li><li>三月去了趟甘南，司司不小心得急性肠胃炎</li><li>五月去了汤汕头南澳岛，司司不小心得感染(UTI)</li><li>拍到沪牌，入手Volvo V60</li><li>开始疯狂露营，疯狂收集落日</li><li>刻意<a href="/SeizeTheDay/FFF-weight-management/"><strong>低碳水饮食</strong></a>，狂瘦至62.0KG</li><li>着手幸会app的系统架构及AI端开发</li><li>上手opencv、ffmpeg，构建幸会app上的拍立得拼图及相遇视频自动生成</li><li>幸会app落地</li><li>国庆自驾了一圈西北环线</li><li>第一次乌镇戏剧节，参与《晚饭花》深夜诗歌朗诵，体验一般</li><li>年底连续长跑18次，尝试了一次10KM，似乎可以坚持</li></ul><h3 id="〖-2022-〗">〖 2022? 〗</h3><ul><li>继续深入AI方向</li><li>继续去探索世界</li></ul>]]></content>
    
    <summary type="html">
    
      The summary of 2021 and new year&#39;s resolution.
    
    </summary>
    
    
      <category term="SeizeTheDay" scheme="https://neo1989.net/categories/SeizeTheDay/"/>
    
    
  </entry>
  
  <entry>
    <title>认知偏差</title>
    <link href="https://neo1989.net/Notes/NOTE-cognitive-bias/"/>
    <id>https://neo1989.net/Notes/NOTE-cognitive-bias/</id>
    <published>2021-12-15T06:21:45.000Z</published>
    <updated>2023-01-13T03:01:29.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="决策、信念与行为偏差">决策、信念与行为偏差</h2><p>⚠️  这些偏差多半会影响信念的形成、商业与经济决策，以及其他一般的人类行为它们是可复制与再现的，面临特定情景时，一半可预期人们会有相应的偏差倾向。</p><h3 id="不明确效应-Ambiguity-Effect">不明确效应 Ambiguity Effect</h3><p>我们倾向于避免未知，决策时避开资讯不足的选项，通过添加明确的细节来最大程度地减少歧义，从而提高转化率。</p><h3 id="锚定效应-Anchoring-Effect">锚定效应 Anchoring Effect</h3><p>人类在进行决策时，会过度偏重先前取得的资讯（这称为锚点），即使这个资讯与这项决定无关。在进行决策时，人类倾向于利用此段资讯（锚点），快速做出决定。</p><h3 id="注意力偏差-Attention-Effect">注意力偏差 Attention Effect</h3><p>在检查所有可能的结果时，我们倾向于关注一些看起来合理且熟悉的事物，从而忽略了其他结果。</p><h3 id="获得性启发-Availability-Heuristic">获得性启发 Availability Heuristic</h3><p>我们认为那些迅速跃入脑海的事情比那些不容易想起的事情更为常见和重要。因此，最近发生的、频繁发生的、极端的、被记住的事情比大多数信息更有影响力。</p><h3 id="可获性层叠-Availability-Cascade">可获性层叠 Availability Cascade</h3><p>这个心理效用有一个更简单的描述，叫做三人成虎，也就是一件事越常被公开讨论，人们就越相信这件事情。</p><h3 id="逆火效应-Backfire-Effect">逆火效应 Backfire Effect</h3><p>我们不能轻易改变人们的信念：与根深蒂固的信念相反的证据和论据无济于事，只会巩固信念的地位。</p><h3 id="从众效应-Bandwagon-Effect">从众效应 Bandwagon Effect</h3><p>我们经常会因为大多数人以同一种方式思考，而改变我们自己的想法。</p><h3 id="信念偏差-Belief-Bias">信念偏差 Belief Bias</h3><p>我们更倾向于接受与我们的先验知识相符的论点，而拒绝对该论点的反驳。</p><h3 id="选择支持偏差-Choice-Supporitive-Bias">选择支持偏差 Choice-Supporitive Bias</h3><p>做出决定后，我们倾向于称赞我们选择的选项，然后降级其他选项。</p><h3 id="确认偏差-Confirmation-Bias">确认偏差 Confirmation Bias</h3><p>当人本来就持有某种观点时，对这种观点的感知和注意度会被放大，会选择性地会议或手机关于它的实例。人们对于自己原本就相信的观点会更容易接受，而把反面观点搁置在一旁。</p><h3 id="知识的诅咒-Curse-of-Knowledge">知识的诅咒 Curse of Knowledge</h3><p>当我们是某个领域的专家时，会不知不觉假设其他人和我们具有相同的理解能力，尤其是对于专业术语的使用。</p><h3 id="诱饵效应-Decoy-Effect">诱饵效应 Decoy Effect</h3><p>引入第三个选项来加强旧选项的吸引力。</p><h3 id="差异偏差-Distinction-Bias">差异偏差 Distinction Bias</h3><p>在有比较项存在时，我们对微小的差异变得敏感，而实际上，这些差异并不是很大。</p><h3 id="禀赋效应-Endowment-Effect">禀赋效应 Endowment Effect</h3><p>和没有拥有的物品相比，用户更倾向于保留自己拥有的物品。他们倾向于高估自己拥有的东西，而忽略其客观的市场价值。</p><h3 id="功能固有-Functional-Fixedness">功能固有 Functional Fixedness</h3><p>指个体在解决问题时往往只看到某种事物的通常功能，而看不到其他方面可能有的功能。这是人们长期以来形成的对某些事物的功能或用途的固定看法。</p><h3 id="巴纳姆效应-Barnum-Effect">巴纳姆效应 Barnum Effect</h3><p>也称佛瑞效应。人们会对于他们认为是为自己量身定制的一些人格描述给予高度准确的评价，而这些描述往往十分模糊及普遍，以致能够放诸四海而皆准适用于很多人身上。</p><h3 id="框架效应-Framing-Effect">框架效应 Framing Effect</h3><p>框架效应的意义是，面对同一个的问题，在使用不同的描述后，人们会选择乍听只在较有利或顺耳的描述作为方案。<br>（大多数情况下，正向表达的转化率更高）</p><h3 id="频率错觉-Frequency-Illusion">频率错觉 Frequency Illusion</h3><p>首次引起我们注意后，我们很快就会从很多地方注意到相关信息。<br>（如果某人想买一辆新车，通常会突然发现到处都是这辆车）</p><h3 id="后见之明偏差-Hindsight-Bias">后见之明偏差 Hindsight Bias</h3><p>后视偏见会让人沉迷与“我早就料到了”这种感受当中，无法真正从事件中汲取到有用的经验，也难以用公平的眼光来评判客观事物和他人，主观上也很容易选择性地忽略许多客观事实。</p><h3 id="当下偏差-Current-Moment-Bias">当下偏差 Current Moment Bias</h3><p>又称限时偏差，人们更倾向于获取即时收益，而非未来的更大收益。</p><h3 id="可辨识受害者效应-Identifiable-Victim-Effect">可辨识受害者效应 Identifiable Victim Effect</h3><p>我们倾向于同情一个特定的人而不是匿名的某一个人。</p><h3 id="宜家效应-IKEA-Effect">宜家效应 IKEA Effect</h3><p>宜家效应是指人们倾向于高度评价他们参与创造的产品，消费者对于一个物品付出的劳动（情感）越多，就越容易高估该物品的价值。</p><h3 id="影响力偏差-Impact-Bias">影响力偏差 Impact Bias</h3><p>我们倾向于高估未来情绪状态的持续时间或强度。</p><h3 id="资讯偏差-Information-Bias">资讯偏差 Information Bias</h3><p>因测量误差多导致的一种偏误现象，有时亦称为观察偏误或分组错误。</p><h3 id="沉默成本谬误-Sunk-Cost-Fallacy">沉默成本谬误 Sunk Cost Fallacy</h3><p>我们在某件事上投入越多就越难放弃它。因此，我们往往会继续执行这个走向失败的行动，仅仅是因为我们过去已经在此投入了过多的事件、金钱或精力。</p><h3 id="损失趋避-Loss-Aversion">损失趋避 Loss Aversion</h3><p>指人们面对同样数量的收益和损失时，认为损失更加令他们难以忍受。损失带来的负效用为收益正效用的2至2.5倍。损失厌恶反映了人们的风险偏好并不是一致的，当涉及的是收益时，人们表现为风险厌恶；当涉及的是损失时，人们则表现为风险寻求。</p><h3 id="单纯接触效应-Mere-Exposure-Effect">单纯接触效应 Mere Exposure Effect</h3><p>人们会单纯因为自己熟悉某个事物而产生好感。它表名某一外在刺激，仅仅因为呈现的次数越频繁（使个体能够接触到该刺激的机会越多），个体对该刺激就越喜欢。</p><h3 id="负面偏差-Negativity-Bias">负面偏差 Negativity Bias</h3><p>相比于中性或者积极的事物，具有负面影响的事物对人们的心理影响更大。<br>（通过解决负面体验来说明你的产品价值，如果希望自己的故事能够产生更大的影响，就要尝试多展现情感上负面的内容）</p><h3 id="忽略可能性-Neglect-of-Probability">忽略可能性 Neglect of Probability</h3><p>当我们承受压力时，我们没有想到风险发生的可能性。结果，较小的风险可能被高估或被忽略。</p><h3 id="乐观偏差-Optimism-Bias">乐观偏差 Optimism Bias</h3><p>与别人相比，我们经常高估自己成功的几率。</p><h3 id="鸵鸟效应-Ostrich-Effect">鸵鸟效应 Ostrich Effect</h3><p>我们故意避免负面信息（或与我们的期望不一致的反馈），认为如果我们把头埋在沙子里，它们就会消失。</p><h3 id="规划谬误-Planning-Fallacy">规划谬误 Planning Fallacy</h3><p>我们倾向于低估完成一项任务所需要的事件，通常规划谬误会导致时间超支，成本超支或收益不足。将大型任务分解为较小的部分有助于解决问题。</p><h3 id="对抗心理-Reactance">对抗心理 Reactance</h3><p>当我们感到某人（或某物）试图剥夺或限制我们的选择时，对抗心理就会发生。当他们发生时，我们有一种抵制它并采取相反行动的冲动。<br>（当你与用户“争论”他的选择时要小心，说服对方时必须循循善诱，永远不要与用户直接对抗。）</p><h3 id="自制偏差-Restraint-Bias">自制偏差 Restraint Bias</h3><p>人们经常会高估自己控制冲动行为的能力。<br>（我们都认为“标题党”属于旁门左道，但我们还是容易陷入其中，不是吗？）</p><h3 id="韵律当理由效应-Rhyme-as-Reason-Effect">韵律当理由效应 Rhyme as Reason Effect</h3><p>大部分广告语朗朗上口，非常洗脑。<br>（所以，尽可能的把你的产品文案变得有韵律感，这样更容易说服用户。）</p><h3 id="风险补偿-Risk-Compensation">风险补偿 Risk Compensation</h3><p>当我们感觉到更大的风险时，我们会变得更加谨慎，而当我们收到更多保护时，我们就会没那么多谨慎。所以当我们知道在已经采取了很多安全措施以后，我们更有可能采取冒险的方式行事。<br>（在购买或注册前让用户对产品产生尽可能的安全感）</p><h3 id="选择性知觉-Selective-Perception">选择性知觉 Selective Perception</h3><p>我们对事物的看法很大程度上受到期望的影响，当人们集中注意力时，人们会从环境中过滤掉事物。</p><h3 id="幸存者偏差-Survivorship-Bias">幸存者偏差 Survivorship Bias</h3><p>过度关注幸存下来的人或事物，忽略哪些被筛选掉的人或事物（可能因为无法观察到），从而得出错误的结论。</p><h3 id="零风险偏差-Zero-Risk-Bias">零风险偏差 Zero-Risk Bias</h3><p>我们喜欢确定性，即使它适得其反。在有其他方案可以降低整个风险的情形下，仍倾向于完全消除某一项风险的偏见。一个例子是可以降低个人负责领域的风险，可是代价是整个组织风险的上升。</p><h3 id="感知价值偏差-Perceived-Value-Bias">感知价值偏差 Perceived Value Bias</h3><p>我们根据产品的外观或服务方式来感知其价值。正如人们所说：全部在包装中！</p><h3 id="分析瘫痪-Analysis-Paralysis">分析瘫痪 Analysis Paralysis</h3><p>又称选择超载。当出现太多选择时，我们的大脑就会瘫痪，很难进行选择。<br>（选择太多 = 转换率低）</p><h3 id="稀缺效应-Scarcity-Effect">稀缺效应 Scarcity Effect</h3><p>我们将稀缺物品的价值提高，将高可用性物品的价值降低。 害怕错过（FOMO）是我们更容易收到诱惑和冲动，并促使我们做出轻率的决定。<br>（使用“限时优惠”，“有限数量”等修辞来形容你的产品或服务。）</p><h3 id="流畅性启发-Fluency-Heuristic">流畅性启发 Fluency Heuristic</h3><p>我们认为那些处理速度更快、更流畅、更顺利的事物具有更高的价值。有时不合逻辑的论点在沟通良好的情况下（由有权威和经验的人提出）也可能会赢得胜利。</p><h2 id="社会偏差">社会偏差</h2><p>⚠️  这些偏差大多是由归因偏差导致。</p><h3 id="行动者-观察者偏差-Actor-Observer-Bias">行动者-观察者偏差 Actor-Observer Bias</h3><p>行动者喜欢将他们自己的行为归因于情境性因素，而观察者喜欢将同样的行为归因于行动者稳定的人格素质。</p><h3 id="达克效应-Dunning-Kruger-Effect">达克效应 Dunning-Kruger Effect</h3><p>我们无法认识到我们缺乏能力，并且由于无法分辨能力好与能力差的不同，因而认为大家都一样。</p><h3 id="错误共识效应-False-Consensus-Effect">错误共识效应 False Consensus Effect</h3><p>人们倾向于高估别人对自己的认同程度，想象其他人像我们一样，并分享我们的观点，信念，偏好，价值观和习惯，认为所有人以同样的方式思考。</p><h3 id="基本归因谬误-Fundamental-Attribution-Error">基本归因谬误 Fundamental Attribution Error</h3><p>解释他人行为时，归因于内在特质（一定是他有这样的人格，才做出这样的行为），而非外在情景（也许是情势所迫，或这个场所特有的潜规则）。基本归因谬误是矛盾和问题的常见来源，而且这种认知偏差存在于用户也同样存在于设计师本身。</p><h3 id="晕轮效应-Halo-Effect">晕轮效应 Halo Effect</h3><p>晕轮效应是指使用一个人（或事物）的一种品质来对该人或事物进行整体判断，换句话说，我们对一个人、一个产品、一家公司或一个品牌的最初印象会影响我们对其整体特征的解读。</p><h3 id="群内效应-Ingroup-Effect">群内效应 Ingroup Effect</h3><p>群内偏差常被用来引导用户决策，它是指人们会在认知傻姑娘倾向于自己所属的群体。在体验设计中利用群内偏差的关键点在于打造群体归属感，借由小群体的力量影响用户的决策。</p><h3 id="权威偏见-Authority-Bias">权威偏见 Authority Bias</h3><p>我们认为权威人士给出的建议准确性更高，并且更容易受到该建议的影响（即使事物主题与该任务的权威性无关）</p><h3 id="得寸进尺法-Foot-in-the-Door-Technique">得寸进尺法 Foot-in-the-Door Technique</h3><p>通过先提出一个简单的小请求来说服用户同意一个较大请求的劝说。</p><h2 id="记忆错误与偏差">记忆错误与偏差</h2><p>⚠️  在心理学和认知科学中，记忆偏差是一种认知偏差，导致记忆的强化、弱化（包括能否想起的机会、想起所需的时间，或两者皆有），或者记忆内容的改变。</p><h3 id="谷歌效应-Google-Effect">谷歌效应 Google Effect</h3><p>我们会容易忘记可以从网上轻松找到的信息。</p><h3 id="幽默效应-Humor-Effect">幽默效应 Humor Effect</h3><p>当信息被认为是有趣或幽默时，我们会更好地记住信息。这可以帮助提高产品的转化率，并有助于整体业务的提升。</p><h3 id="真相错觉效应-Illusion-of-Truth-Effect">真相错觉效应 Illusion of Truth Effect</h3><p>重复的事情越多，我们就越相信。</p><h3 id="峰终法则-Peak-End-Rule">峰终法则 Peak-End Rule</h3><p>用户不仅仅根据平均或所有体验的综合来评估体验，取而代之的是，他们的大脑会严重地偏向峰值（高或低）和体验的终点，峰值如果是愉悦的话，通常对应了用户旅程中令人难忘的愉悦感。</p><h3 id="图片优势效应-Picture-Superiority-Effect">图片优势效应 Picture Superiority Effect</h3><p>图片和图像比一千个单词更容易被记住。</p><h3 id="首因效应-Primacy-Effect">首因效应 Primacy Effect</h3><p>又称近时效应、序位效应。列表开头和结尾的项目比中间的项目更容易被用户记住。</p><h3 id="雷斯多夫效应-Von-Restorff-Effect">雷斯多夫效应 Von Restorff Effect</h3><p>当很多信息一起呈现时，醒目的信息和被特变强调的信息会比其他信息更容易被人们记住。</p><h3 id="蔡格尼效应-Zeigarnik-Effect">蔡格尼效应 Zeigarnik Effect</h3><p>进行中的任务会产生特定于任务的张力。当任务完成时，这种压力可以缓解，但是如果任务被终端，它将保持不变，这种张力使相关信息更易于访问和记忆。<br>（显示一个不完整的进度栏，以鼓励用户实现自己的目标）</p><h2 id="统计与几率偏差">统计与几率偏差</h2><p>⚠️  几率性推论是指根据有关几率的资讯推论事情的可能，而几率的估算通常来自统计资料，因此两者密不可分。</p><h3 id="基本比率谬误-Base-Rate-Fallacy">基本比率谬误 Base Rate Fallacy</h3><p>我们倾向于忽略一般信息，而只关注特定案例。</p><h3 id="赌徒谬误-Gambler’s-Fallacy">赌徒谬误 Gambler’s Fallacy</h3><p>我们错误的认为，如果在给定时期内某件时期频繁发生，那么这件事情在将来发生的几率就会很小。</p><h3 id="热手谬误-Hot-Handy-Fallacy">热手谬误 Hot-Handy Fallacy</h3><p>错误地认为经历过成功的人更有可能在其他尝试中进一步获得成功。一般是在某人近来做某事很成功时，认为他未来做同一件事也会成功，而忽略其成功可能只是随机与巧合导致。</p><h3 id="对样本数不敏锐-Insensitivity-to-Sample-Size">对样本数不敏锐 Insensitivity to Sample Size</h3><p>我们经常忽略样本大小并贸然下结论，即使样本数量还未达到足够的统计量。</p><h2 id="实验与研究偏差">实验与研究偏差</h2><p>⚠️  这是一些科学实验与统计研究容易发生的偏差。</p><h3 id="取样偏差-Sampling-Bias">取样偏差 Sampling Bias</h3><p>某些类型的用户被无意中从研究参与者池中提出了。亦可以理解为以偏概全，即以局部事例解释整体原因。</p><h3 id="观察者期望效应-Observer-Expectancy-Effect">观察者期望效应 Observer-Expectancy Effect</h3><p>研究者有时可能会期望出现某种结果，他们无意识地操纵了实验过程，或者错误地解释实验结果，导致研究结果严重歪曲。</p><h3 id="社会期许偏差-Social-Desirability-Bias">社会期许偏差 Social Desirability Bias</h3><p>我们倾向于多表达复合社会期许的事情，而隐瞒那些不符合社会预期的事情。例如在询问是否有不良嗜好、性伴侣数量时，大家会有意无意地隐瞒或淡化实情。</p><h3 id="遗漏变数偏差-Omitted-Variable-Bias">遗漏变数偏差 Omitted-Variable Bias</h3><p>当获得的奖励出乎意料之外，我们获得奖励的喜悦感就会增加。</p><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://zh.wikipedia.org/wiki/%E8%AA%8D%E7%9F%A5%E5%81%8F%E8%AA%A4%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">认知偏差列表</a><br>[2] <a href="https://s75w5y7vut.feishu.cn/docs/doccn3BatnScBJe7wD7K3S5poFf" target="_blank" rel="noopener">认知偏差知识手册</a></p>]]></content>
    
    <summary type="html">
    
      心理学词条。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>低碳水饮食实践</title>
    <link href="https://neo1989.net/SeizeTheDay/FFF-weight-management/"/>
    <id>https://neo1989.net/SeizeTheDay/FFF-weight-management/</id>
    <published>2021-09-05T03:02:34.000Z</published>
    <updated>2022-11-19T03:18:53.352Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="/SeizeTheDay/HEALTH-low-carb-diet/"><strong>低碳水饮食方法论</strong></a></p></blockquote><p><img src="http://s3.mindex.xyz/blog/SeizeTheDay/88a71e64f2b8bac8fc2b4aa5d33c2c5b.png" alt="Congrats!"></p>]]></content>
    
    <summary type="html">
    
      深度实践低碳水饮食
    
    </summary>
    
    
      <category term="SeizeTheDay" scheme="https://neo1989.net/categories/SeizeTheDay/"/>
    
    
      <category term="Health" scheme="https://neo1989.net/tags/Health/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Python》</title>
    <link href="https://neo1989.net/Notes/NOTE-effective-python/"/>
    <id>https://neo1989.net/Notes/NOTE-effective-python/</id>
    <published>2021-08-10T11:00:20.000Z</published>
    <updated>2023-01-13T03:01:36.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="培养Pythonic思维">培养Pythonic思维</h2><h3 id="查询自己使用的Python版本">查询自己使用的Python版本</h3><ul><li>Python3是最新版的Python，而且受到了很好的支持，大家应该用Python3开发项目。</li><li>在操作系统的命令行界面运行Python时，要确认该Python的版本是否跟你要使用的版本相同。</li><li>不要再使用Python2做开发了，该版本已于2022年1月1日停止更新维护。</li></ul><h3 id="遵循PEP8风格指南">遵循PEP8风格指南</h3><ul><li>编写Python代码时，总是应该遵循PEP8风格指南。</li><li>与广大Python开发者同时采用同一套代码风格，可以使项目更利于多人协作。</li><li>采用一致的风格编写代码，代码的后续修改跟容易。</li></ul><h3 id="了解bytes与str的区别">了解bytes与str的区别</h3><ul><li>bytes包含的是由8bits所组成的序列，str包含的是由Unicode码点所组成的序列。</li><li>我们可以编写辅助函数来确保程序收到的字符序列确实是期望要操作的类型（要知道自己想操作的到底是Unicode码点，还是原始的8位值。用UTF-8标准给字符串编码，得到的就是这样的一系列8位值）。</li><li>bytes与str这两种实例不能再某些操作符（如&gt;、==、+、%等）上面混用。</li><li>从文件中读取二进制数据（或者写入二进制数据到文件）时，应该用’rb’ (‘wb’) 这样的二进制模式打开文件。</li><li>如果要从文件中读取（或者写入）的是Unicode数据，那么必须注意系统默认的文件编码方案。若无法肯定，可通过encoding参数明确指定。</li></ul><h3 id="用支持插值的f-string取代C风格的格式字符串与str-format方法">用支持插值的f-string取代C风格的格式字符串与str.format方法</h3><ul><li>采用%操作符把值填充到C风格的格式字符串时会遇到许多问题，而且这种写法比较繁琐。</li><li>str.format方法专门用一套迷你语言来定义它的格式说明符，这套语言给我们提供了一些有用的概念，但是在其他方面，这个方法还是存在与C风格的格式字符串一样的多种缺点，所以我们也应该避免使用它。</li><li>f-string是个简洁而强大的机制，可以直接在格式说明符里嵌入任意Python表达式。</li></ul><h3 id="用辅助函数取代复杂的表达式">用辅助函数取代复杂的表达式</h3><ul><li>Python的语法很容易把复杂的额意思挤到同一行表达式里，这样写很难懂。</li><li>复杂的表达式，尤其是那种需要重复使用的复杂表达式，应该写到辅助函数里面。</li><li>用if/else结构写成的条件表达式，要比用or与and写成的Bollean表达式更好懂。</li></ul><h3 id="把数据结构直接拆分到多个变量里，不要专门通过下表访问">把数据结构直接拆分到多个变量里，不要专门通过下表访问</h3><ul><li>unpacking是一种特殊的Python语法，只需要一行代码，就能把数据结构里面的多个值分别赋给相应的变量。</li><li>unpacking在Python中应用广泛，凡是可迭代的对象都能拆分，无论它里面还有多少层迭代结构。</li><li>尽量通过unpacking来拆解序列之中的数据，而不是通过下标访问，这样可以让代码更简洁、更清晰。</li></ul><h3 id="尽量用enumerate取代range">尽量用enumerate取代range</h3><ul><li>enumerate函数可以用简洁的代码迭代iterator，而且可以指出当前这轮循环的序号。</li><li>不要先通过range指定下标的取值范围，然后用下标去访问序列，而是应该直接用enumerate函数迭代。</li><li>可以通过enumerate的第二个参数指定起始序号（默认为0）。</li></ul><h3 id="用zip函数同时遍历两个迭代器">用zip函数同时遍历两个迭代器</h3><ul><li>内置的zip函数可以同时遍历多个迭代器。</li><li>zip会创建惰性生成器，让它每次只生成一个元组，所以无论输入的数据有多长，它都是一个一个处理的。</li><li>如果提供的迭代器的长度不一致，那么只要其中任何一个迭代完毕，zip就会停止。</li><li>如果想按最长的那个迭代器来遍历，那就改用内置的itertools模块中的zip_logngest函数。</li></ul><h3 id="不要在for与while的循环后面鞋else块">不要在for与while的循环后面鞋else块</h3><ul><li>Python有种特殊的语法，可以把else块紧跟在整个for循环或while循环的后面。</li><li>只有在整个循环没有因为break提前跳出的情况下，else块才会执行。</li><li>把else块紧跟在整个循环后面，会让人不太容易看出这段代码的意思，所以要避免这样写。</li></ul><h3 id="用赋值表达式减少重复代码">用赋值表达式减少重复代码</h3><ul><li>赋值表达式通过海象操作符（:=）给变量赋值，并且让这个值成为这条表达式的结果，于是，我们可以利用这项特性来缩减代码。</li><li>如果赋值表达式是大表达式里的一部分，就得用一对括号把它括起来。</li><li>虽说Python不支持switch/case与do/while，但可以利用赋值表达式清晰地模拟出这种逻辑。</li></ul><h2 id="列表与字典">列表与字典</h2><h3 id="学会对序列做切片">学会对序列做切片</h3><ul><li>切片要尽可能写得简单一些：如果从头开始选取，就省略起始下标0；如果选到序列序列末尾，就省略终止下标。</li><li>切片允许起始下标或终止下标越界，所以很容易就能表达“取开头多少个元素”（如a[:10]） 或 “取末尾多少个元素”（如a[-10:0]）等含义，而不用担心切片是否真有这么多元素。</li><li>把切片放在赋值符号的左侧可以将原列表中这段范围内的元素用赋值符号右侧的元素替换掉，但可能会改变原列表的长度。</li></ul><h3 id="不要在切片里同时指定起止下标与步进">不要在切片里同时指定起止下标与步进</h3><ul><li>同时指定切片的起止下标与步进值理解起来会很困难。</li><li>如果要指定步进值，那就省略起止下标，而且最好采用正数作为步进值，尽量别用负数。</li><li>不要把起始位置，终止位置与步进值全都写在同一个切片操作里。如果必须同时使用这三项指标，那就分两次来做（其中一次隔位选取，另一次做切割），也可以改用itertools内置模块里的islice方法。</li></ul><h3 id="通过带星号的unpacking操作来捕获多个元素，不要用切片">通过带星号的unpacking操作来捕获多个元素，不要用切片</h3><ul><li>拆分数据结构并把其中的数据赋给变量时，可以用带星号的表达式，将结构中无法与普通变量相匹配的内容捕获到一份列表里。</li><li>这种带星号的表达式可以出现在赋值符号左侧的任意位置，它总会形成一份含有零个或多个值的列表。</li><li>在把列表拆解成互相不重叠的多个部分时，这种带星号的unpacking方式比较清晰，而通过下标与切片来实现的方式则容易出错。</li></ul><h3 id="用sort方法的key参数来表示复杂的排序逻辑">用sort方法的key参数来表示复杂的排序逻辑</h3><ul><li>列表的sort方法可以根据自然顺序给其中的字符串、整数、元组等内置类型的元素进行排序。</li><li>普通对象如果通过特殊方法定义了自然顺序，那么也可以用sort方法来排列，但这样的对象并不多见。</li><li>可以把辅助函数传给sort方法的key参数，让sort根据这个函数所返回的值来排列元素顺序，而不是根据元素本身来排列。</li><li>如果排序时要依据的指标有很多项，可以把它们放在一个元组中，让key函数返回这样的元组。对于支持一元减操作符的类型来说，可以单独给这项指标取反，让排序算法在这项指标上按照相反的方向处理。</li><li>如果这些指标不支持一元减操作符，可以多次调用sort方法，并在每次调用时分别指定key函数与reverse参数。最次要的指标放在第一轮处理，然后逐步处理更为重要的指标，首要指标放在最后一轮处理。</li></ul><h3 id="不要过分依赖给字典添加条目时所用的顺序">不要过分依赖给字典添加条目时所用的顺序</h3><ul><li>从Python3.7版开始，我们就可以确信迭代标准的字典时所看到的顺序跟这些键值对插入字典时的顺序一致。</li><li>在Python代码中，我们很容易就能定义跟标准的字典很像但本身并不是dict实例的对象。对于这种类型的对象，不能假设迭代时看到的顺序必定与插入时的顺序相同。</li><li>如果不想把这种跟标准字典很相似的类型也当成标准字典来处理，那么可以考虑这样三种办法。<br>第一，不要依赖插入时的顺序编写代码；<br>第二，在程序运行时明确判断它是不是标准的字典；<br>第三，给代码添加类型注解并做静态分析。</li></ul><h3 id="用get处理键不在字典中的情况，不要使用in与KeyError">用get处理键不在字典中的情况，不要使用in与KeyError</h3><ul><li>有四种办法可以处理键不在字典中的情况：in表达式、KeyError异常、get方法与setdefault方法</li><li>如果跟键相关联的值是像计数器这样的基本类型，那么get方法就是最好的方案；如果是那种构造起来开销比较大，或是容易出异常的类型，那么可以把这个方法与赋值表达式结合起来使用。</li><li>即使看上去最应该使用setdefault方案，也不一定要真的使用setdefault方案，而是可以考虑用defalutdict取代普通的dict。</li></ul><h3 id="用defaultdict处理内部状态中缺失的元素，而不要用setdefault">用defaultdict处理内部状态中缺失的元素，而不要用setdefault</h3><ul><li>如果你管理的字典可能需要添加任意的键，那么应该考虑能否用内置的collections模块中的defaultdict实例来解决问题。</li><li>如果这种键名比较随意的字典是别人传给你的，你无法把它创建成defaultdict，那么应该考虑通过get方法访问其中的键值。然而，在个别情况下，也可以考虑改用setdefault方法，因为那样写更短。</li></ul><h3 id="学会利用-missing-构造依赖键的默认值">学会利用__missing__构造依赖键的默认值</h3><ul><li>如果创建默认值需要较大的开销，或者可能抛出异常，那就不适合用dict类型的setdefault方法实现。</li><li>传给setdefault的函数必须是不需要参数的函数，所以无法创建出需要依赖键名的默认值。</li><li>如果要构造的默认值必须根据键名来确定，那么可以定义自己的dict子类并实现__missing__方法。</li></ul><h2 id="函数">函数</h2><h3 id="不要把函数返回的多个数值拆分到三个以上的变量中">不要把函数返回的多个数值拆分到三个以上的变量中</h3><ul><li>函数可以把多个值合起来通过一个元组返回给调用者，以便利用Python的unpacking机制取拆分。</li><li>对于函数返回的多个值，可以把普通变量没有捕获到的那些值全都捕获到一个带星号的变量里。</li><li>把返回的值拆分到四个或四个以上的变量是很容易出错的，所以最好不要那么写，而是应该通过小类或namedtuple实例完成。</li></ul><h3 id="遇到意外状况时应该抛出异常，不要返回None">遇到意外状况时应该抛出异常，不要返回None</h3><ul><li>用返回值None表示特殊情况是很容易出错的，因为这样的值在条件表达式里面，每办法与0和空白字符串之类的值区分，这些值都想当与False。</li><li>用异常表示特殊的情况，而不要返回None。让调用这个函数的程序根据文档里写得异常情况做出处理。</li><li>通过类型注解可以明确禁止函数返回None，即便在特殊情况下，它也不能返回这个值。</li></ul><h3 id="了解如何在闭包里面使用外围作用域中的变量">了解如何在闭包里面使用外围作用域中的变量</h3><ul><li>闭包函数可以引用定义它们的那个外围作用域之中的变量。</li><li>按照默认的写法，在闭包里面给变量赋值并不会改写外围作用域中的同名变量。</li><li>出特别简单的函数外，尽量少用nonlocal语句。</li></ul><h3 id="用数量可变的位置参数给函数设计清晰的参数列表">用数量可变的位置参数给函数设计清晰的参数列表</h3><ul><li>用def定义函数时，可以通过 *args 的写法让函数接受数量可变的位置参数。</li><li>调用函数时，可以在序列左边加上 * 操作符，把其中的元素当成位置参数传给 *args 所表示的这一部分。</li><li>如果 * 操作符加在生成器前，那么传递参数时，程序有可能因为耗尽内存而崩溃。</li><li>给接受 *args 的函数添加新位置参数，可能导致难以排查的bug。</li></ul><h3 id="用关键字参数来表示可选行为">用关键字参数来表示可选行为</h3><ul><li>函数的参数可以按位置指定，也可以用关键字的形式指定。</li><li>关键字可以让每个参数的作用更加明了，因为在调用函数时只按位置指定参数，可能导致这些参数的含义不够明确。</li><li>应该通过带默认值的关键字参数来扩展函数行为，因为这部会影响原有的函数调用代码。</li><li>可选关键字参数总是应该通过参数名来传递，而不应按位置传递。</li></ul><h3 id="用None和docstring来描述默认值会变得参数">用None和docstring来描述默认值会变得参数</h3><ul><li>参数的默认值只会计算一次，也就是在系统把定义函数的那个模块加载进来的时候。所以，如果默认值将来可能由调用放修改（例如{}， []）或者要随着调用时的情况变化（例如datetime.now()），那么程序就会出现奇怪的效果。</li><li>如果关键字参数的默认值属于这种会发生变化的值，那就应该写成None，并且要在docstring里面描述函数此时的默认行为。</li><li>默认值为None的关键字参数，也可以添加类型注解。</li></ul><h3 id="用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表">用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表</h3><ul><li>Keyword-Only Arguments是一种只能通过关键字指定而不能通过位置指定的参数。这迫使调用者必须指明，这个值是传给哪一个参数的。在函数的参数列表中，这种参数位于 * 符号的右侧。</li><li>Positional-Only Arguments是这样一种参数，它不允许调用者通过关键字来指定，而是要求必须按照位置传递。这可以降低调用代码与参数名称之间的耦合程度。在函数的参数列表中，这些参数位于/符号的左侧。</li><li>在参数列表中，位于 / 与 * 之间的参数，可以按位置指定，也可以用关键字来指定。这也是Python普通参数的默认指定方式。</li></ul><h3 id="用functools-wraps定义函数修饰器">用functools.wraps定义函数修饰器</h3><ul><li>修饰器是Python中的一种写法，能够把一个函数封装在另一个函数里面，这样程序在执行原函数之前与执行完毕之后，就有机会执行其他一些逻辑了。</li><li>修饰器可能会让那些利用instropection机制运作的工具（例如调试器）产生奇怪的行为。</li><li>Python内置的functools模块里有个叫wraps的修饰器，可以帮助我们正确定义自己的修饰器，从而避开相关的问题。</li></ul><h2 id="推导与生成">推导与生成</h2><h3 id="用列表推导取代map与filter">用列表推导取代map与filter</h3><ul><li>列表推导要比内置的map与filter函数清晰，因为它不用另外定义lambda表达式。</li><li>列表推导可以很容易地跳过原列表中的某些数据，加入改用map实现，那么必须搭配filter才能实现。</li><li>字典与集合也可以通过推导来创建。</li></ul><h3 id="控制推导逻辑的子表达式不要超过两个">控制推导逻辑的子表达式不要超过两个</h3><ul><li>推导的适合可以使用多层循环，每层循环可以带有多个条件。</li><li>控制推导逻辑的子表达式不要超过两个，否则代码很难读懂。</li></ul><h3 id="用赋值表达式消除推导中的重复代码">用赋值表达式消除推导中的重复代码</h3><ul><li>编写推导式与生成器表达式时，可以在描述条件的那一部分通过赋值表达式定义变量，并在其他部分复用该变量，可使程序简单易读。</li><li>对于推导式与生成器表达式来说，虽然赋值表达式也可以出现在描述条件的那一部分之外，但最好别这么写。</li></ul><h3 id="不要让函数直接返回列表，应该让它逐个生成列表里的值">不要让函数直接返回列表，应该让它逐个生成列表里的值</h3><ul><li>用生成器来实现比让函数把结果收集到列表里再返回，要更加清晰一些。</li><li>生成器函数所返回的迭代器可以产生一系列值，每次产生的那个值都是由函数体的下一条yield表达式所决定的。</li><li>不管输入的数据量有多大，生成器函数每次都只需要根据其中的一小部分来计算当前这次的输出值。它不用把整个输入值全都读取进来，也不用一次就把所有的输出值全都算好。</li></ul><h3 id="谨慎地迭代函数所收到的参数">谨慎地迭代函数所收到的参数</h3><ul><li>函数和方法如果要把收到的参数遍历很多遍，那就必须特别小心。因为如果这些阐述为迭代器，那么程序可能得不到预期的值，从而出现奇怪的效果。</li><li>Python的迭代器协议确定了容器与迭代器应该怎样跟内置的iter及next函数、for循环及相关的表达式交互。</li><li>要想让自定义的容器类型可以迭代，只需要把__iter__方法实现为生成器即可。</li><li>可以把值传给iter函数，检测它返回的是不是那个值本身。如果是，就说明这是个普通的迭代器，而不是一个可以迭代的容器。另外也可以用内置的isinstance函数判断该值是不是collections.abc.Iteration类的实例。</li></ul><h3 id="考虑用生成器表达式改写数据量较大的列表推导">考虑用生成器表达式改写数据量较大的列表推导</h3><ul><li>通过列表推导来处理大量的输入数据，可能会占用许多内存。</li><li>改用生成器表达式来做，可以避免内存使用量过大的问题，因为这种表达式所形成的迭代器每次只会计算一项结果。</li><li>生成器表达式所形成的迭代器可以当成for语句的子表达式出现在另一个生成器表达式里面。</li><li>把生成器表达式组合起来使用，能够写出执行速度快且占用内存少的代码。</li></ul><h3 id="通过yield-from把多个生成器连起来用">通过yield from把多个生成器连起来用</h3><ul><li>如果要连续使用多个生成器，那么可以通过yield from表达式来风别使用这些生成器，这样做能够免去重复的for结构。</li><li>yield from的性能要胜过那种在for循环里手工编写yield表达式的方案。</li></ul><h3 id="不要用send给生成器注入数据">不要用send给生成器注入数据</h3><ul><li>send方法可以把数据注入生成器，让它成为上一条yield表达式的求值结果，生成器可以把这个结果赋给变量。</li><li>把send方法与yield from表达式搭配起来使用，可能导致奇怪的结果，例如会让程序在本该输出有效值的地方输出None。</li><li>通过迭代器向组合起来的生成器输入数据，要比采用send方法的那种方案好，所以尽量避免使用sendfangfa。</li></ul><h3 id="不要通过throw变换生成器的状态">不要通过throw变换生成器的状态</h3><ul><li>throw方法可以把异常发送到生成器刚执行过的那条yield表达式那里，让这个异常在生成器下次推进时重新抛出。</li><li>通过throw方法注入异常，会让代码变得难懂，因为需要用多成嵌套的模板结构来抛出并捕获这种异常。</li><li>如果确实遇到了这样的特殊情况，那么应该通过类的__iter__方法实现生成器，并且专门提供一个方法，让调用者通过这方法来触发这种特殊的状态变换逻辑。</li></ul><h3 id="考虑用itertools拼装迭代器与生成器">考虑用itertools拼装迭代器与生成器</h3><ul><li>itertools包里面有三套函数可以拼装迭代器与生成器，它们分别能够连接多个迭代器，过滤源迭代器中的元素，以及用源迭代器中的元素合成新元素。</li><li>通过help(itertools)查看文档，了解这些函数所支持的其他参数，以及许多更为高级的函数和实用的代码范例。</li></ul><h2 id="类与接口">类与接口</h2><h3 id="用组合起来的类来实现多层结构，不要用嵌套的内置类型">用组合起来的类来实现多层结构，不要用嵌套的内置类型</h3><ul><li>不要在字典里嵌套字典、长元组，以及用其他内置类型构造的复杂结构。</li><li>namedtuple能够实现出轻量级的容器，以存放不可变的数据，而且将来可以灵活地转化成普通的类。</li><li>如果发现用字典来维护内部状态的那些代码已经越写越复杂了，呢么就应该考虑改用多个类来实现。</li></ul><h3 id="让简单的接口接受函数，而不是类的实例">让简单的接口接受函数，而不是类的实例</h3><ul><li>如果想设计简单的Python接口，让组件之间能够通过接口交互，那么可以考虑让接口接受挂钩函数，而不一定非得定义新类，并要求使用者传入这种类的实例。</li><li>Python的函数与方法都是头等对象，这意味者它们可以像其他类型那样，用在表达式里。</li><li>某个类如果定义了__call__特殊方法，那么它的实例就可以像普通的Python函数那样调用。</li><li>如果想用函数来维护状态，那么可以考虑定义一个带有__call__方法的新类，而不要用有状态的闭包去实现。</li></ul><h3 id="通过-classmethod多态来构造同一体系中的各类对象">通过@classmethod多态来构造同一体系中的各类对象</h3><ul><li>Python只允许每个类有一个构造方法，也就是__init__方法。</li><li>如果想在超类中用通用的代码构造子类实例，那么可以考虑定义@classmethod方法，并在里面用cls(…)的形式构造具体的子类对象。</li><li>通过类方法多态机制，我们能够以通用的形式构造并拼接具体的子类对象。</li></ul><h3 id="通过super初始化超类">通过super初始化超类</h3><ul><li>Python有标准的方法解析顺序（MRO）规则，可以用来判定超类之间的初始化顺序，并解决菱形继承问题。</li><li>可以通过Python内置的super函数正确触发超类的__init__逻辑。一般情况下，不需要给这个函数指定参数。</li></ul><h3 id="考虑用mix-in类来表示可组合的功能">考虑用mix-in类来表示可组合的功能</h3><ul><li>超类最好能写成不带实例属性与__init__方法的min-in类，以避免由多重继承所引发的一些问题。</li><li>如果子类要定制（或者说修改）mix-in所提供的功能，那么可以自己的代码里面覆盖相关的实例方法。</li><li>根据需求，mix-in可以只提供实例方法，也可以只提供类方法，还可以同时提供这两种方法.</li><li>把每个mix-in所提供的简单功能组合起来，可以实现比较复杂的功能。</li></ul><h3 id="优先考虑用public属性表示应受保护的数据，不要用private属性表示">优先考虑用public属性表示应受保护的数据，不要用private属性表示</h3><ul><li>Python编译器无法绝对禁止外界访问private属性。</li><li>从一开始就应该考虑允许其他类能继承这个类，并利用其中的内部API与属性去实现更多功能，而不是把它们藏起来。</li><li>把需要保护的数据设计成protected字段，并用文档加以解释，而不要通过private属性限制访问。</li><li>只有在子类不受控制且名称有可能与超类冲突时，才可以考虑给超类设计private属性。</li></ul><h3 id="自定义的容器类型应该从collections-abc继承">自定义的容器类型应该从collections.abc继承</h3><ul><li>如果要编写的新类比较简单，那么可以直接从Python的容器类型（例如list或dict）里面继承。</li><li>如果想让定制的容器类型能像标准的Python容器那样使用，那么有可能要编写许多特殊方法。</li><li>可以从collections.abc模块里的抽象基类之中派生自己的容器类型，这样可以让容器自动具备相关的功能，同时又可以保证没有把实现这些功能所必备的方法给漏掉。</li></ul><h2 id="元类与属性">元类与属性</h2><h3 id="用纯属性与修饰器取代旧式的setter与getter方法">用纯属性与修饰器取代旧式的setter与getter方法</h3><ul><li>给新类定义接口时，应该从简单的public属性写起，避免定义setter与getter方法。</li><li>如果在访问属性时确实有必要做特殊的处理，那就通过@property来定义获取属性与设置属性的方法。</li><li>实现@property方法时，应该遵循最小惊讶原则，不要引发奇怪的副作用。</li><li>@property方法必须执行得很快。复杂或缓慢的任务，尤其是设计I/O或者会引发副作用的那些任务，还是用普通的方法来实现比较好。</li></ul><h3 id="考虑用-property实现新的属性访问逻辑，不要急着重构原有的代码">考虑用@property实现新的属性访问逻辑，不要急着重构原有的代码</h3><ul><li>可以利用@property给已有的实例属性增加新的功能。</li><li>可以利用@property逐渐改善数据模型而不影响已经写好的代码。</li><li>如果发现@property使用太过频繁，那可能就该考虑重构这个类了，同时按照旧办法使用这个类的那些代码可能也要重构。</li></ul><h3 id="用描述符来改写需要复用的-property方法">用描述符来改写需要复用的@property方法</h3><ul><li>如果像复用@property方法所实现的行为与验证逻辑，则可以考虑自己定义描述符类。</li><li>为了防止内存泄漏，可以在描述符中用WeakKeyDictionary取代普通的字典。</li><li>不要太纠结于__getattribute__是怎么通过描述符协议来获取并设置属性的。</li></ul><h3 id="针对惰性属性使用-getattr-、getattribute、-setattr-方法">针对惰性属性使用__getattr__、<strong>getattribute</strong>、__setattr__方法</h3><ul><li>如果想用自己的防护死（例如惰性地或者按需地）加载并保存对象属性，那么可以在该对象所属的类里实现__getattr__与__setattr__特殊方法。</li><li>__getattr__只会在属性缺失时触发，而__getattribute__则在每次访问属性时都要触发。</li><li>在实现__getattribute__与__setattr__的过程中，如果要使用本对象的普通属性，那么应该通过super()（也就是object类）来使用，而不要直接使用，以避免无限递归。</li></ul><h3 id="用-init-subclass-验证子类写得是否正确">用__init_subclass__验证子类写得是否正确</h3><ul><li>如果某个类时根据元类所定义的，那么当系统把该类的class语句体全部处理完之后，就会将这个类的写法告诉元类的__new__方法。</li><li>可以利用元类在类创建完成前检视或修改开发者根据这个元类所定义的其他类，但这种机制通常显得有点笨重。</li><li>__init_subclass__能够用来检查子类定义得是否合理，如果不合理，那么可以提前报错，让程序无法创建出这种子类的对象。</li><li>在分层的或者涉及多重继承的类体系里面，一定别忘了在你写的这些类的 __init_subclass__内通过 super() 来调用超类的 __init_subclass__方法，以便按照正确的顺序触发各类的验证逻辑。</li></ul><h3 id="用-init-subclass-记录现有的子类">用 __init_subclass__记录现有的子类</h3><ul><li>类注册（Class registration）是个相当有用的模式，可以用来构建模块式的Python程序。</li><li>我们可以通过基类的元类把用户从这个基类派生出来的子类自动注册给系统。</li><li>利用元类实现类注册可以防止由于用户忘记注册而导致程序出现问题。</li><li>优先考虑通过__init_subclass__实现自动注册，而不要用标准的元类机制来实现，因为__init_subclass__更清晰，更便于初学者理解。</li></ul><h3 id="用-set-name-给类属性加注解">用__set_name__给类属性加注解</h3><ul><li>我们可以通过元类把利用这个元类所定义的其他类拦截下来，从而在程序开始使用那些类之前，先对其中定义的属性做出修改。</li><li>描述符与元类搭配起来，可以形成一套强大的机制，让我们既能采用声明式的写法来定义行为，又能在程序运行时检视这个行为的具体执行情况。</li><li>你可以给描述符定义__set_name__方法，让系统把使用这个描述符做属性的那个类似以及它在类里的属性通过方法的参数告诉你。</li><li>用描述符直接操纵每个实例的属性字典，要比把所有实例的属性都放到一份字典里更好，因为后者要求我们必须使用weakref内置模块之中的特殊字典来记录每个实例的属性值以防止内存泄漏。</li></ul><h3 id="优先考虑通过类修饰器来提供可组合的扩充功能，不要使用元类">优先考虑通过类修饰器来提供可组合的扩充功能，不要使用元类</h3><ul><li>类修饰器起始就是个函数，只不过它可以通过参数获知自己所修饰的类，从而重建或调整这个类并返回修改结果。</li><li>如果要给类中的每个方法或属性都施加一套逻辑，而且还想着尽量少写一些例行代码，那么类修饰器是个很值得考虑的方案。</li><li>元类之间很难组合，而类修饰器则比较灵活，它们可以施加在同一个类上，并且不会发生冲突。</li></ul><h2 id="并发与并行">并发与并行</h2><h3 id="用subprocess管理子进程">用subprocess管理子进程</h3><ul><li>subprocess模块可以运行子进程并管理它们的输入流与输出流。</li><li>子进程能够跟Python解释器所在的进程并行，从而充分利用各CPU核心。</li><li>要开启子进程，最简单的办法就是调用run函数，另外也可以通过Popen类实现类似Unix管道的高级用法。</li><li>调用communicate方法时可以指定timeout参数，让我们有机会把陷入死锁或已经卡住的子进程关掉。</li></ul><h3 id="可以用线程执行阻塞式I-O，但不要用它做并行计算">可以用线程执行阻塞式I/O，但不要用它做并行计算</h3><ul><li>即便计算机具备多核CPU，Python线程也无法真正实现并行，因为它们会受到全局解释器锁（GIL）牵制。</li><li>虽然Python的多线程机制受GIL影响，但还是非常有用的，因为我们很容易就能通过多线程模拟同时执行多项任务的效果。</li><li>多条Python线程可以并行地执行多个系统调用，这样就能让程序在执行阻塞式的I/O任务时，继续做其他运算。</li></ul><h3 id="利用Lock防止多个线程争用同一份数据">利用Lock防止多个线程争用同一份数据</h3><ul><li>虽然Python有全局解释器锁，但开发者还是得设法避免线程之间发生数据争用。</li><li>把未经互斥锁保护的数据开放给多个线程去同时修改，可能导致这份数据的结构遭到破坏。</li><li>可以利用threading内置模块之中的Lock类确保程序中的固定关系不会在多线程环境下受到干扰。</li></ul><h3 id="用Queue来协调各线程之间的工作进度">用Queue来协调各线程之间的工作进度</h3><ul><li>管道非常适合用来安排多阶段的任务，让我们能够把每一阶段都交给各自的线程去执行，这尤其适合用在I/O密集型的程序里面。</li><li>构造这种并行的管道时，有很多问题需要注意，例如怎样防止线程频繁地查询队列状态，怎样通知线程尽快结束操作，以及怎样防止管道出现拥堵等。</li><li>我们可以利用Queue类所具有的功能来构造健壮的管道系统，因为这个类提供了阻塞式的入队（put）和出队（get）操作，而且可以限定缓冲区的大小，还能够通过task_done与join来确保所有元素都已处理完毕。</li></ul><h3 id="学会判断什么场合必须做并发">学会判断什么场合必须做并发</h3><ul><li>程序范围变大、需求变复杂之后，经常要用多条路径平行地处理任务。</li><li>fan-out与fan-in是最常见的两种并发协调（concurrency coordination）模式，前者用来生成一批新的并发单元，后者用来等待现有的并发单元全部完工。</li><li>Python提供了很多种实现fan-out与fan-in的方案。</li></ul><h3 id="不要在每次fan-out时都新建一批Thread实例">不要在每次fan-out时都新建一批Thread实例</h3><ul><li>每次都手工创建一批线程，是有很多缺点的，例如：创建并运行大量线程时的开销比较大，每条线程的内存占用量比较多，而且还必须采用Lock等机制来协调这些线程。</li><li>线程本身并不会把执行过程中遇到的异常抛给启动线程或者等待该线程完工的那个人，所以这种异常很难调试。</li></ul><h3 id="学会正确地重构代码，以便用Queue做并发">学会正确地重构代码，以便用Queue做并发</h3><ul><li>把队列（Queue）与一定数量的工作线程搭配起来，可以高效地实现fan-out（分派）与fan-in（归集）。</li><li>为了改用队列方案处理I/O，我们重构了很多代码，如果管道要分成好几个环节，那么要修改的地方会很多。</li><li>利用队列并行地处理I/O任务量有限，我们可以考虑用Python内置的某些功能与模块打造更好的方案。</li></ul><h3 id="如果必须用线程做并发，那就考虑通过ThreadPoolExecutor实现">如果必须用线程做并发，那就考虑通过ThreadPoolExecutor实现</h3><ul><li>利用ThreadPoolExecutor，我们只需要稍微调整一下代码，就能够并行地执行简单的I/O操作，这种方案省去了每次fan-out（分派）任务时启动线程的那些开销。</li><li>虽然ThreadPoolExecutor不想直接启动线程的方案那样，需要消耗大量内存，但它的I/O并行能力也是有限的。因为它能够使用的最大线程数需要提前通过max_workers参数指定。</li></ul><h3 id="用协程实现高并发I-O">用协程实现高并发I/O</h3><ul><li>协程时采用async关键字所定义的函数。如果你想执行这个协程，但并不要钱立刻就获得执行结果，而是稍后再来获取，那么可以通过await关键字表达这个意思。</li><li>协程能够制造出一种效果，让人以为程序里有成千上万个函数都在同一时刻高效地运行着。</li><li>协程可以用fan-out与fan-in模式实现并行的I/O操作，而且能够克服用线程做I/O时的缺陷。</li></ul><h3 id="学会用asyncio改写那些通过线程实现的I-O">学会用asyncio改写那些通过线程实现的I/O</h3><ul><li>Python提供了异步版本的for循环、with语句、生成器与推导机制，而且还有很多辅助的库函数，让我们能够顺利地迁移到协程方案。</li><li>我们很容易就能利用内置的asyncio模块来改写代码，让程序不要再通过线程执行阻塞式的I/O，而是改用协程来执行异步I/O。</li></ul><h3 id="结合线程与协程，将代码顺利迁移到asyncio">结合线程与协程，将代码顺利迁移到asyncio</h3><ul><li>asyncio模块的事件循环提供了一个返回awaitable对象的run_in_executor方法，它能够使协程把同步函数放在线程池执行期（ThreadPoolExecutor）里面执行，让我们可以顺利地将采用线程方案所实现的项目，从上至下地迁移到asyncio方案。</li><li>asyncio模块的事件循环还提供了一个可以再同步代码里面调用的run_until_complete方法，用来运行协程并等待其结束。它的功能跟asyncio.run_coroutine_threadsafe类似，只是后者面对的时跨线程的场合，而前者是为同一个线程设计的。这些都有助于将采用线程方案所实现的项目从下至上地迁移到asyncio方案。</li></ul><h3 id="让asyncio的事件循环保持畅通，以便进一步提升程序的响应能力">让asyncio的事件循环保持畅通，以便进一步提升程序的响应能力</h3><ul><li>把系统调用（包括阻塞式的I/O以及启动线程等操作）放在协程里面执行，会降低程序的响应能力，增加延迟感。</li><li>调用async.run时，可以把debug参数设为True，这样能够知道哪些协程降低了事件循环的反应速度。</li></ul><h3 id="考虑用concurrent-futures实现真正的并行计算">考虑用concurrent.futures实现真正的并行计算</h3><ul><li>把需要耗费大量CPU资源的计算任务改用C扩展模块来写，或许能够有效提高程序的运行速度，同时又让程序里的其他代码依然能够利用Python语言自身的特性。但是，这样做的开销比较大，而且容易引入bug。</li><li>Python自带的multiprocessing模块提供了许多强大的工具，让我们只需要耗费很少的精力，就可以把某些类型的任务平行地放在多个CPU核心上面处理。</li><li>要想发挥出multiprocessing模块的优势，最好是通过concurrent.futures模块及其ProcessPoolExecutor类来编写代码，因为这样做比较简单。</li><li>只有在其他方案全都无效的情况下，才可以考虑直接使用multiprocessing里面的高级功能（那些功能用起来相当复杂）。</li></ul><h2 id="稳定与性能">稳定与性能</h2><h3 id="合理利用try-except-else-finally结构种的每个代码块">合理利用try/except/else/finally结构种的每个代码块</h3><ul><li>try/finaly形式的复合语句可以确保，无论try块是否抛出异常，finally块都会得到运行。</li><li>如果某段代码应该再前一段代码顺利执行之后加以运行，那么可以把它放到else块里面，而不要把这两段代码全都写在try块之中。这样可以让try块更加专注，同时也能够跟except块形成明确对照；except块写的时try块没有顺利执行时所要运行的代码。</li><li>如果你要在某段代码顺利执行之后多做一些处理，然后再清理资源，那么通常可以考虑把这三段代码分别放在try、else与finally块里。</li></ul><h3 id="考虑用contextlib和with语句来改写可复用的try-finally代码">考虑用contextlib和with语句来改写可复用的try/finally代码</h3><ul><li>可以把try/finally逻辑风撞到情境管理器里面，这样就能通过with结构反复运用这套逻辑，而不需要每次用到的适合，都手工打一遍代码。</li><li>Python内置的contextlib模块提供了contextmanager修饰器，让我们可以很方便地修饰某个函数，从而制作出相对应的情境管理器，舍得这个函数能够运用再with语句里面。</li><li>情境管理器通过yield语句所产生的值，可以由with语句之中位于as右侧的那个变量所接收，这样的话，我们就可以通过该变量与当前情境相交互了。</li></ul><h3 id="用datetime模块处理本地事件，不要用time模块">用datetime模块处理本地事件，不要用time模块</h3><ul><li>不要用time模块再不同时区之间转换。</li><li>把Python内置的datetime模块与开发者社群提供的pytz模块结合起来，可以在不同时区之间可靠地转换。</li><li>在操纵事件数据的过程种，总是应该使用UTC时间，只有到了最后一步，才需要把它转回当地时间以便显示出来。</li></ul><h3 id="用copyreg实现可靠的pickle操作">用copyreg实现可靠的pickle操作</h3><ul><li>Python内置的pickle模块，只适合用来再彼此信任的程序之间传递数据，以实现对象的序列化与反序列化功能。</li><li>如果对象所在的这个类发生了变化（例如增加或删除了某些属性），那么程序在还原旧版数据的时候，可能会出现错误。</li><li>把内置的copyreg模块与pickle模块搭配起来使用，可以让新版的程序兼容旧版的序列化数据。</li></ul><h3 id="在需要准确计算的场合，用decimal表示相应的数值">在需要准确计算的场合，用decimal表示相应的数值</h3><ul><li>每一种数值几乎都可以用Python内置的某个类型，或者内置模块之中的某个类表示出来。</li><li>在精度要求较高且需要控制舍入方式的场合（例如在计算费用的时候），可以考虑使用Decimal类。</li><li>用小数构造Decimal时，如果想保证取值准确，那么一定要把这个数放在str字符串里面传递，而不要直接传过去，那样可能有误差。</li></ul><h3 id="先分析性能，然后再优化">先分析性能，然后再优化</h3><ul><li>优化Python程序之前，一定要先分析它的性能，因为导致程序速度缓慢的真正原因未必与我们想的一样。</li><li>应该优先考虑用cProfile模块来分析性能，而不要用profile模块，因为前者得到的分析结果更加准确。</li><li>把需要接收性能测试的主函数传给Profile对象的runcall方法，就可以专门分析出这个体系下面所有函数的调用情况了。</li><li>可以通过Stats对象筛选出我们关心的那些分析结果，从而更加为专注地思考如何优化程序性能。</li></ul><h3 id="优先考虑用deque实现生产者-消费者队列">优先考虑用deque实现生产者-消费者队列</h3><ul><li>list类型可以用来实现FIFO队列，生产者可以通过append方法向队列添加元素。但这种方案有个问题，就是消费者在用 pop(0) 从队列中获取元素时，所花的时间会随着队列长度，呈平方式增长。</li><li>跟list不同，内置collections模块种的deque类，无论时通过append添加元素，还是通过popleft获取元素，所花的时间都只跟队列长度呈现性关系，而非平方关系，这使得它非常适合于FIFO队列。</li></ul><h3 id="考虑用bisect搜索已排序的序列">考虑用bisect搜索已排序的序列</h3><ul><li>用index方法在已经排好顺序的列表之中查找某个值，花费的时间与列表长度成正比，通过for循环单纯地做比较以寻找目标值，所花的时间也是如此。</li><li>Python内置的bisect模块里面有个bisect_left函数，只需要花费对数级别的时间就可以在有序列表中搜寻某个值，这要比其他方法快好几个数量级。</li></ul><h3 id="学会使用heapq制作优先级队列">学会使用heapq制作优先级队列</h3><ul><li>优先级队列让我们能够按照重要程度来处理元素，而不是必须按照先进先出的顺序处理。</li><li>如果直接用相关的列表操作来模拟优先级队列，那么程序的性能会随着队列长度的增大这大幅下降，因为这样做的复杂程度是平方级别，而不是线性级别。</li><li>通过Python内置的heapq模块所提供的函数，我们完全可以实现基于堆的优先级队列，从而高效地处理大量数据。</li><li>要使用heapq模块，我们必须让元素所在的类型支持自然排序，这可以通过对类套用@functools.total_ordering修饰器并定义__lt__方法来实现。</li></ul><h3 id="考虑用memoryview与bytearray来实现无须拷贝的bytes操作">考虑用memoryview与bytearray来实现无须拷贝的bytes操作</h3><ul><li>Python内置的memoryview类型提供了一套无须执行拷贝的（也就是零拷贝）操作接口，让我们可以对支持缓冲协议的Python对象制作切片，并通过这种切片高速地完成读取与写入。</li><li>Python内置的bytearray类型是一种与bytes相似但内容能够改变的类型，我们可以通过socket.reccv_from这样的函数，以无需拷贝的方式（也就是零拷贝的方式）读取数据。</li><li>我们可以用memoryview来封装bytearray，从而用收到的数据覆盖底层缓冲里面的任意区段，同时又无需执行拷贝操作。</li></ul><h2 id="测试与调试">测试与调试</h2><h3 id="通过repr字符串输出调试信息">通过repr字符串输出调试信息</h3><ul><li>把内置类型的值传给print，会打印出便于认读的那种字符串，但是其中不会包含类型信息。</li><li>把内置类型的值传给repr，会得到一个能够表示该值的可打印字符串，将这个repr字符串传给内置的eval函数能够得到原值。</li><li>在格式化字符串里用%s处理相关的值，就跟把这个值传给str函数一样，都能得到一个便于认读的那种字符串。如果用%r来处理，那么得到的就是repr字符串。在f-string中，也可以用值来取代其中有待替换的那一部分，并产生便于认读的那种字符串，但如果待替换的部分加了!r后缀，那么替换出来的就是repr字符串。</li><li>给类定义__repr__特殊方法，可以让print函数把该类实例的可打印表现形式展现出来，在实现这个方法时，还可以提供更为详尽的调试信息。</li></ul><h3 id="在TestCase子类里验证相关的行为">在TestCase子类里验证相关的行为</h3><ul><li>Python内置的unittest模块里有个TestCase类，我们可以定义它的子类，并在其中编写多个test方法，以便分别验证想要测试的每一种行为。TestCase子类的这些test方法名称都必须以test这个词开头。</li><li>TestCase类还提供了许多辅助方法，例如，可以在test方法中通过assertEqual辅助方法来确认两个值相等，而不采用内置的assert语句。</li><li>可以用subTest辅助方法做数据驱动测试，这样就不用针对每项子测试重复编写相关的代码与验证逻辑了。</li></ul><h3 id="把测试前、后的准备与清理逻辑写在setUp、tearDown、setUpModule、tearDownModule中，以防用例之间互相干扰">把测试前、后的准备与清理逻辑写在setUp、tearDown、setUpModule、tearDownModule中，以防用例之间互相干扰</h3><ul><li>单元测试验证的是每项功能本身是否正常，集成测试验证的是模块之间能否正确交互，这两种测试都很重要。</li><li>把测试用例的准备与清理工作分别放在setUp与tearDown方法中，可以避免用例之间相互干扰，使它们都能从一套干净的环境开始执行。</li><li>集成测试的准备与清理工作可以放在模块级别的setUpModule与tearDownModule函数里，系统在测试该模块与其中所有TestCase子类的过程中，只会把这两个函数各自运行一遍。</li></ul><h3 id="用Mock来模拟受测试代码所依赖的复杂函数">用Mock来模拟受测试代码所依赖的复杂函数</h3><ul><li>unittest.mock模块中的Mock类能够模拟某个接口的行为，我们可以用它替换受测试函数所要调用的接口，因为那些接口可能不太容易在测试的过程种配置。</li><li>如果用mock把手册代码所依赖的函数替换掉了，那么在测试的时候，不仅要验证受测代码的行为，而且还要验证它有没有正确地调用这些mock，这可以通过Mock.assert_called_once_with等一系列方法实现。</li><li>要想把受测函数所调用的其他函数用mock逻辑替换掉，一种办法是给受测函数设计只能以关键字来指定的参数；另一种办法是通过unittest.mock.patch系列的方法暂时隐藏那些函数。</li></ul><h3 id="把受测代码所依赖的系统封装起来，以便于模拟和测试">把受测代码所依赖的系统封装起来，以便于模拟和测试</h3><ul><li>在写单元测试的时候，如果总是要反复使用许多代码来注入模拟的逻辑，那么可以考虑把受测函数所要用到的逻辑封装到类中，因为封装之后更容易注入。</li><li>Python内置的unitest.mock模块里有个Mock类，它能模拟类的实例，这种Mock对象具备与原类中的方法相对应的属性。如果在它上面调用某个方法，就会触发相应的属性。</li><li>如果想把程序完整的测一遍，那么可以重构代码，在原类直接使用复杂系统的地方引入辅助函数，让程序通过这些函数来获取它要用的系统，这样我们就可以通过辅助函数注入模拟逻辑。</li></ul><h3 id="考虑用pdb做交互调试">考虑用pdb做交互调试</h3><ul><li>在程序里某个兴趣点直接调用Python内置的breakpoint函数就可以触发交互调试器。</li><li>Python的交互调试界面（即pdb界面）也是一套完整的Python执行环境，在它里面我们可以检查正在运行的程序处于什么状态，并予以修改。</li><li>我们可以在pdb界面里用相关的命令精确地控制程序的执行方式，这样就能做到一边检查状态，一边推进程序了。</li><li>pdb模块还能够在程序出现错误的时候检查该程序的状态，这可以通过 <code>python -m pdb -c continue &lt;program path&gt;</code> 命令实现，也可以在普通的Python解释器界面运行受测程序，等到出现问题，再用<code>import pdb; pdb.pm()</code>切换至调试界面。</li></ul><h3 id="用tracemalloc来掌握内存的使用与泄漏情况">用tracemalloc来掌握内存的使用与泄漏情况</h3><ul><li>不借助相关的工具，我们可能很难了解Python程序是怎样使用内存的，以及其中有些内存又是如何泄漏的。</li><li>gc模块可以帮助我们了解垃圾回收器追踪到了哪些对象，但它并不能告诉我们那些对象是如何分配的。</li><li>Python内置的tracemalloc模块提供了一套强大的工具，可以帮助我们更好地了解内存的使用情况，并找到这些内存分别由哪一行代码所分配。</li></ul><h2 id="协作开发">协作开发</h2><h3 id="学会寻找由其他Python开发者所构建的模块">学会寻找由其他Python开发者所构建的模块</h3><ul><li>Python Package Index（PyPI） 含有许多常用的软件包，这些都是由广大Python开发者构建并维护的。</li><li>可以用pip命令行工具从PyPI里面安装软件包。</li><li>大多数PyPI模块都是自由及开源软件。</li></ul><h3 id="用虚拟环境隔离项目，并重建依赖关系">用虚拟环境隔离项目，并重建依赖关系</h3><ul><li>我们可以在每个虚拟环境里面，分别用pip命令安装它所需要的软件包，这样的话，同一台电脑中就可以存在许多互不冲突的环境了。</li><li><code>python3 -m venv</code> 命令可以创建虚拟环境，<code>source bin/activate与deactivate</code>命令分别可以启动与禁用该环境。</li><li><code>python3 -m pip freeze &gt; requirements.txt</code> 命令可以把当前环境所依赖的软件包保存到文件之中，之后可以通过 <code>python3 -m pip install -r requirements.txt</code> 在另一套环境里面重新安装这些包。</li></ul><h3 id="每一个函数、类与模块都要写docstring">每一个函数、类与模块都要写docstring</h3><ul><li>每个模块、类、方法与函数都应该编写docstring文档，并且要与实现代码保持同步。</li><li>模块的docstring要介绍本模块的内容，还要指出用户必须了解的关键类与重要函数。</li><li>类的docstring要写在class语句的正下方，描述本类的行为与重要的属性，还要指出子类应该如何正确地继承这个类。</li><li>函数与方法的docstring要写在def语句的正下方，描述本函数的每个参数、函数的返回值，可能抛出的异常以及其他相关的行为</li><li>如果某些信息已经通过类型注解表达过了，那就不要在docstring里面重复。</li></ul><h3 id="用包来安排模块，以提供稳固的API">用包来安排模块，以提供稳固的API</h3><ul><li>Python的包是一种包含其他模块的模块。这种结构让我们可以把代码划分成多个互不冲突的名称空间，即便两个实体同名，也能用它们所属的模块加以区分。</li><li>如果要构建的包比较简单，那就把其中每个模块所对应的源文件都直接放在本包的目录下，并给目录里面创建一份__init__.py文件。这样的话，这些源文件所表示的模块就会成为本包的子模块。这个目录里还可以创建子目录，以构建其他包。</li><li>如果想限制外界通过引入该模块能够访问到哪些API，那么可以把这些API的名称写在__all__这个特殊的属性里面。</li><li>如果不想让外界看到某些内容，那么可以在包目录中的__init__.py文件里面故意不引入这些内容，或者给这些只供本包内部使用的内容名称前面添加下划线。</li><li>假如这个包只在某个团队或某个项目内部使用，那恐怕就没必要专门通过__all__来指定外界能够访问到的API了。</li></ul><h3 id="考虑用模块级别的代码配置不同的环境">考虑用模块级别的代码配置不同的环境</h3><ul><li>程序通常需要部署到许多种环境里面，无论在哪一种环境之中运行程序，都必须先准备好相关的资源，并做出适当的配置。</li><li>可以像编写普通的Python语句那样，直接在模块作用域书写配置逻辑，以定制该模块的内容，从而针对不同的环境做出适当的部署。</li><li>还可以根据其他一些外部因素来调整模块的内容，例如通过sys或os模块查询与操作系统相关的信息，并据此定制该模块。</li></ul><h3 id="为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常">为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常</h3><ul><li>给模块定义根异常，可以让使用这个模块的API用户将它们自己的代码与这个模块所提供的API隔开，以便分别处理其中的错误。</li><li>API用户在处理完API所属模块由可能抛出的具体异常后，可以写一个针对模块根异常的except块，如ugochengxu进入这个块，那就说明他使用API的方式可能有问题，例如可能忘记处理某种本来应该处理的具体异常。</li><li>API用户还可以再写一个except块以捕获整个Python体系之中的根异常，如果程序进入了那个块，那说明所调用的API可能实现得有问题。</li><li>在模块的根异常下，可以设立几个门类，让具体的异常不要直接集成总的根异常，而是继承各自门类种的那个分根异常，这样的话，使用这个模块的开发者，就可以只关注这几个门类，即便你修改了某个门类至下的具体异常，也不会影响到他们已经写好的那些代码。</li></ul><h3 id="用适当的方式打破循环依赖关系">用适当的方式打破循环依赖关系</h3><ul><li>如果两个模块都要在开头引入对方，那就会形成循环依赖，这有可能导致程序在启动的时候崩溃。</li><li>要想达阔依赖循环，最好的办法是把这两个模块都要用到的那些代码重构到整个依赖体系的最底层。</li><li>如果不想大幅度重构代码，也不想让代码变得太复杂，那么最简单的方案是通过动态引入来消除循环依赖关系，但尽量避免使用。</li></ul><h3 id="重构时考虑通过warnings提醒开发者API已经发生变化">重构时考虑通过warnings提醒开发者API已经发生变化</h3><ul><li>设计新版API的时候，可以通过warnings模块把已经过时的用法通知到调用者，让他们看到消息后尽快改用新的方法，以防程序在我们彻底放弃旧版API之后崩溃。</li><li>在命令行界面执行Python解释器的时候，可以开启-W error选项，从而将警告视为错误。这在执行自动测试的过程种特别有用，因为这样可以及时发现受测程序所依赖的API是否已经推出了新的版本。</li><li>如果程序要部署到生产环境，那么可以通过logging模块将警告信息重定向到日志系统，把程序在运行过程中遇到的警告纳入现有的错误报告机制中。</li><li>如果你设计的API会发出警告，那么应该为此编写测试，确保下游开发者在使用API的过程中，能够在适当的时机收到正确的警告信息。</li></ul><h3 id="考虑通过typing做静态分析，以消除bug">考虑通过typing做静态分析，以消除bug</h3><ul><li>Python提供了内置的typing模块与一套特殊的写法，可以给变量、字段、函数与方法标注类型信息。</li><li>静态类型检查工具可以利用标注的类型信息检查出许多常见的bug，而不用让它们到程序运行的时候再暴露。</li><li>合理地使用注解<ul><li>如果刚开始写代码的时候，就想着如何添加类型注解，那可能会拖慢编程速度。所以我们通常应该先把代码本身写出来，然后编写测试，最好才考虑在必要的地方添加类型信息。</li><li>类型提示信息最能发挥作用的地方，是在项目与项目衔接处。</li><li>如果有些代码比较复杂，或者特别容易出错，那么即便不属于API，也仍然值得添加类型提示信息。但是要注意，没必要给所有的代码都添上类型注解，因为到了一定程度之后，再添加这种信息，就不会给项目带来太大的好处。</li><li>如果有可能的话，应该把静态分析这一环节纳入自动构建流程与测试系统中，以确保提交上去的每份代码都会经受相关的检查。另外，检查类型信息所用的配置方案，应该放在代码库里面维护，以保证其他的合作者使用的也是这套规则。</li><li>每添加一批类型注解，就应该把静态分析工具运行一遍，这样可以及时发现问题并加以解决。假如把整个项目全部注解完之后，再实施类型检查，那么类型分析工具就有可能打印出极多的错误信息，让你不知到应该先处理哪一条才好，有时甚至会让你想要放弃类型注解。</li><li>有许多场合是不需要写类型注解的，如小型程序、临时代码、遗留项目以及原型等</li></ul></li></ul><h2 id="Reference">Reference</h2><p>[1] <a href="https://book.douban.com/subject/35334595/" target="_blank" rel="noopener">Effective Python</a></p>]]></content>
    
    <summary type="html">
    
      “编写高质量Python代码”。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
  </entry>
  
</feed>
