<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>愚苏记</title>
  
  <subtitle>To no avail but try.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://neo1989.net/"/>
  <updated>2023-03-04T15:09:09.912Z</updated>
  <id>https://neo1989.net/</id>
  
  <author>
    <name>Neo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日落收集</title>
    <link href="https://neo1989.net/SeizeTheDay/COLLECTION-sunsets/"/>
    <id>https://neo1989.net/SeizeTheDay/COLLECTION-sunsets/</id>
    <published>2023-03-04T14:34:15.000Z</published>
    <updated>2023-03-04T15:09:09.912Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Mar-4-2023">Mar 4, 2023</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/7d8d79718363def5e1f35fc64c131589.png" alt="苏州·米堆山"></p><h3 id="Jan-30-2023">Jan 30, 2023</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/cb9d279f773c498fb81893d84e3801a1.png" alt="上海·滨江中路"></p><h3 id="Nov-8-2022">Nov 8, 2022</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/e59f7a0911fb45d4f381f2510134cccd.png" alt="上海·自家楼顶"></p><h3 id="Oct-29-2022">Oct 29, 2022</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/480778a07a8ad62f4667758d7b9f1838.png" alt="上海·自家阳台"></p><h3 id="Oct-21-2022">Oct 21, 2022</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/50f92f3ea2d4734ce62370ed9352d1f7.png" alt="苏州·淀山湖"></p><h3 id="Oct-12-2022">Oct 12, 2022</h3><p><img src="//s3.mindex.xyz/blog/Sunsets/ea79b3cb30dbbd25b2a8f50cdc6e787e.png" alt="上海·隔离酒店"></p>]]></content>
    
    <summary type="html">
    
      日落尤其温柔，人间皆是浪漫。
    
    </summary>
    
    
      <category term="SeizeTheDay" scheme="https://neo1989.net/categories/SeizeTheDay/"/>
    
    
  </entry>
  
  <entry>
    <title>A Demo of the CNN LSTM</title>
    <link href="https://neo1989.net/HandMades/HANDMADE-CNN-LSTM-try/"/>
    <id>https://neo1989.net/HandMades/HANDMADE-CNN-LSTM-try/</id>
    <published>2023-02-15T02:00:17.000Z</published>
    <updated>2023-03-02T06:30:46.551Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>The moving square video prediction problem is contrived to demonstrate the CNN LSTM. The problem involves the generation of a sequence of frames. In each image a line is drawn from left to right or right to left. Each frame shows the extension of the line by one pixel. The task is for the model to classify whether the line moved left or right in the sequence of frames.Technically, the problem is a sequence classification problem framed with a many-to-one prediction model.</p></blockquote><p>&quot;Moving Square Video Prediction&quot;是<a href="https://machinelearningmastery.com/lstms-with-python/" target="_blank" rel="noopener">《Long Short-Term Memory Networks With Python》</a> 这本书里的一个示例。我在这里做了一下扩展，将其变成一个多分类问题。</p><h3 id="The-Problem">The Problem</h3><p>问题定义为一个帧序列，从边缘开始每多一帧就增加一个像素点，以展示朝某个方向延伸的一条线（从上到下，从下到上，从左到右，从右到左）。<br>模型的任务就是预测这条线是如何运动的。<br>很明显，这就是一个many-to-one的分类任务。输入帧序列，输出单个标签（<a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="noopener">图片来源</a>）。</p><p><img src="//s3.mindex.xyz/blog/Notes/faf00c2f0f3277b8c0c8e95a7d504552.png" alt="Recurrent Neural Networks"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 代码示例</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint, random, choice</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot</span><br><span class="line"></span><br><span class="line">directions = [<span class="string">"Up"</span>, <span class="string">"Down"</span>, <span class="string">"Left"</span>, <span class="string">"Right"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">next_frame</span><span class="params">(last_step, last_frame, row=None, col=None)</span>:</span></span><br><span class="line">    lower = max(<span class="number">0</span>, last_step<span class="number">-1</span>)</span><br><span class="line">    upper = min(last_frame.shape[<span class="number">0</span>]<span class="number">-1</span>, last_step+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    step = randint(lower, upper)</span><br><span class="line"></span><br><span class="line">    frame = last_frame.copy()</span><br><span class="line">    <span class="keyword">if</span> row <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        frame[row, step] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> col <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        frame[step, col] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> frame, step</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_frames</span><span class="params">(size)</span>:</span></span><br><span class="line">    frames = list()</span><br><span class="line"></span><br><span class="line">    frame = np.zeros((size, size))</span><br><span class="line">    step = randint(<span class="number">0</span>, size<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">    towards = choice(directions)</span><br><span class="line">    <span class="keyword">if</span> towards <span class="keyword">in</span> [<span class="string">"Up"</span>, <span class="string">"Down"</span>]:</span><br><span class="line"></span><br><span class="line">        down = <span class="number">1</span> <span class="keyword">if</span> towards == <span class="string">"Down"</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        row = <span class="number">0</span> <span class="keyword">if</span> down <span class="keyword">else</span> size<span class="number">-1</span></span><br><span class="line">        frame[row, step] = <span class="number">1</span></span><br><span class="line">        frames.append(frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">            row = i <span class="keyword">if</span> down <span class="keyword">else</span> size<span class="number">-1</span>-i</span><br><span class="line">            frame, step = next_frame(step, frame, row=row)</span><br><span class="line">            frames.append(frame)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        right = <span class="number">1</span> <span class="keyword">if</span> towards == <span class="string">"Right"</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">        col = <span class="number">0</span> <span class="keyword">if</span> right <span class="keyword">else</span> size<span class="number">-1</span></span><br><span class="line">        frame[step, col] = <span class="number">1</span></span><br><span class="line">        frames.append(frame)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, size):</span><br><span class="line">            col = i <span class="keyword">if</span> right <span class="keyword">else</span> size<span class="number">-1</span>-i</span><br><span class="line">            frame, step = next_frame(step, frame, col=col)</span><br><span class="line">            frames.append(frame)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> frames, towards</span><br><span class="line"></span><br><span class="line">size = <span class="number">50</span></span><br><span class="line"></span><br><span class="line">frames, towards = build_frames(size)</span><br><span class="line"></span><br><span class="line">print(<span class="string">f"Towards: <span class="subst">&#123;towards&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">pyplot.figure(figsize=[<span class="number">8</span>, <span class="number">8</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(size):</span><br><span class="line">    pyplot.subplot(size // <span class="number">10</span>, <span class="number">10</span>, i+<span class="number">1</span>)</span><br><span class="line">    pyplot.imshow(frames[i], cmap=<span class="string">'Greys'</span>)</span><br><span class="line">    ax = pyplot.gca()</span><br><span class="line">    ax.get_xaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line">    ax.get_yaxis().set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">pyplot.show()</span><br></pre></td></tr></table></figure><p><img src="//s3.mindex.xyz/blog/Notes/973e4cf02597baebd977e10eca8a6ce9.png" alt="显示运动方向为向上 (从左上到右下逐帧)"></p><h3 id="CNN-LSTM">CNN LSTM</h3><p>使用CNN层对输入数据进行特征提取, 使用LSTM来做序列预测。<br>这种架构还被用于语音识别和自然语言处理问题，其中CNN被用作音频和文本输入数据上的特征提取器，以供LSTM使用。<br>此架构适用于以下问题：</p><ul><li>在其输入中具有空间结构，例如 2D 结构或图像中的像素或句子，段落或文档中的单词的一维结构。</li><li>在其输入中具有时间结构，诸如视频中的图像的顺序或文本中的单词，或者需要生成具有时间结构的输出，诸如文本描述中的单词。</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/e018c5595051507361a05e2ecb6aa01d.png" alt="卷积神经网络长短期记忆网络架构"></p><h3 id="generate-examples">generate_examples</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> LabelEncoder, OneHotEncoder</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># label encode</span></span><br><span class="line">label_encoder = LabelEncoder()</span><br><span class="line">label_encoded = label_encoder.fit_transform(directions)</span><br><span class="line">label_encoded = label_encoded.reshape(len(directions), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># one hot encode</span></span><br><span class="line">onehot_encoder = OneHotEncoder(sparse=<span class="literal">False</span>)</span><br><span class="line">onehot_encoder.fit(label_encoded)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_examples</span><span class="params">(size, n_patterns)</span>:</span></span><br><span class="line">    X, y = list(), list()</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n_patterns):</span><br><span class="line">        frames, towards = build_frames(size)</span><br><span class="line">        X.append(frames)</span><br><span class="line">        y.append(towards)</span><br><span class="line">    X = np.array(X).reshape(n_patterns, size, size, size, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    label_encoded = label_encoder.transform(np.array(y))</span><br><span class="line">    y = onehot_encoder.transform(label_encoded.reshape(len(label_encoded), <span class="number">1</span>)) </span><br><span class="line">    <span class="keyword">return</span> X, y</span><br></pre></td></tr></table></figure><h3 id="CNN-Model">CNN Model</h3><p>The Conv2D will interpret snapshots of the image (e.g. small squares) and the pooling layers will consolidate or abstract the interpretation.<br>We will define a Conv2D as an input layer with 2 filters and a 2 × 2 kernel to pass across the input images. The use of 2 filters was found with some experimentation and it is convention to use small kernel sizes. The Conv2D will output 2 49 × 49 pixel impressions of the input.</p><p>Convolutional layers are often immediately followed by a pooling layer. Here we use a MaxPooling2D pooling layer with a pool size of 2 × 2, which will in effect halve the size of each filter output from the previous layer, in turn outputting two 24 × 24 maps.</p><p>The pooling layer is followed by a Flatten layer to transform the [24,24,2] 3D output from the MaxPooling2D layer into a one-dimensional 1,152 element vector…</p><p>We want to apply the CNN model to each input image and pass on the output of each input image to the LSTM as a single time step.<br>We can achieve this by wrapping the entire CNN input model (one layer or more) in a TimeDistributed layer.</p><p>Next, we can define the LSTM elements of the model. We will use a single LSTM layer with 50 memory cells, configured after a little trial and error. The use of a TimeDistributed wrapper around the whole CNN model means that the LSTM will see 50 time steps, with each time step presenting a 1,152 element vector as input.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Conv2D</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> MaxPooling2D</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> LSTM</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Flatten</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> TimeDistributed</span><br><span class="line"></span><br><span class="line">size = <span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># define the model</span></span><br><span class="line">model = Sequential()</span><br><span class="line">model.add(TimeDistributed(Conv2D(<span class="number">2</span>, (<span class="number">2</span>, <span class="number">2</span>), activation=<span class="string">'relu'</span>), input_shape=(<span class="literal">None</span>, size, size, <span class="number">1</span>)))</span><br><span class="line">model.add(TimeDistributed(MaxPooling2D(pool_size=(<span class="number">2</span>, <span class="number">2</span>))))</span><br><span class="line">model.add(TimeDistributed(Flatten()))</span><br><span class="line">model.add(LSTM(<span class="number">50</span>))</span><br><span class="line">model.add(Dense(len(directions), activation=<span class="string">'softmax'</span>))</span><br><span class="line">model.compile(loss=<span class="string">'binary_crossentropy'</span>, optimizer=<span class="string">'adam'</span>, metrics=[<span class="string">'acc'</span>])</span><br><span class="line"></span><br><span class="line">model.summary()</span><br></pre></td></tr></table></figure><p><img src="//s3.mindex.xyz/blog/Notes/22c2c8bfed7763a934fe6044eefac0e8.png" alt="Model Summary"></p><h3 id="fit-and-evaluate-the-model">fit and evaluate the model</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># fit model</span></span><br><span class="line">X, y = generate_examples(size, <span class="number">5000</span>)</span><br><span class="line">model.fit(X, y, batch_size=<span class="number">32</span>, epochs=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># evaluate model</span></span><br><span class="line">X, y = generate_examples(size, <span class="number">100</span>)</span><br><span class="line">loss, acc = model.evaluate(X, y, verbose=<span class="number">0</span>)</span><br><span class="line">print(<span class="string">f"loss: <span class="subst">&#123;loss:<span class="number">.10</span>f&#125;</span> acc: <span class="subst">&#123;acc:<span class="number">.10</span>f&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><p><img src="//s3.mindex.xyz/blog/Notes/f09f8a2296dd060ce612753e82a28c1f.png" alt="fit &amp; evaluate"></p><h3 id="prediction">prediction</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># prediction on new data</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    X, y = generate_examples(size, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    yhat = model.predict(X, verbose=<span class="number">0</span>)</span><br><span class="line">    print(<span class="string">f"predict_i: <span class="subst">&#123;i&#125;</span>"</span>)</span><br><span class="line">    print(label_encoder.inverse_transform([np.argmax(y[<span class="number">0</span>, :])]), y)</span><br><span class="line">    print(label_encoder.inverse_transform(np.array([np.argmax(yhat[<span class="number">0</span>, :])])), yhat)</span><br></pre></td></tr></table></figure><p><img src="//s3.mindex.xyz/blog/Notes/f757cfdf47d2ecf0da2a4fe6c9a09e38.png" alt="predictions"></p><h3 id="Further-Reading">Further Reading</h3><ul><li><a href="https://keras.io/api" target="_blank" rel="noopener">Keras API.</a></li><li><a href="https://arxiv.org/abs/1411.4389" target="_blank" rel="noopener">Long-term Recurrent Convolutional Networks for Visual Recognition and Description, 2015.</a></li><li><a href="https://arxiv.org/abs/1411.4555" target="_blank" rel="noopener">Show and Tell: A Neural Image Caption Generator, 2015.</a></li><li><a href="https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/43455.pdf" target="_blank" rel="noopener">Convolutional, Long Short-Term Memory, fully connected Deep Neural Networks, 2015.</a></li><li><a href="https://arxiv.org/abs/1508.06615" target="_blank" rel="noopener">Character-Aware Neural Language Models, 2015.</a></li><li><a href="https://arxiv.org/abs/1506.04214" target="_blank" rel="noopener">Convolutional LSTM Network: A Machine Learning Approach for Precipitation Nowcasting, 2015.</a></li></ul>]]></content>
    
    <summary type="html">
    
      “只要学不死，就往死里学。”
    
    </summary>
    
    
      <category term="HandMades" scheme="https://neo1989.net/categories/HandMades/"/>
    
    
      <category term="DL" scheme="https://neo1989.net/tags/DL/"/>
    
  </entry>
  
  <entry>
    <title>《为什么没人早点告诉我》</title>
    <link href="https://neo1989.net/Notes/NOTE-why-has-nobody-told-me-this-before/"/>
    <id>https://neo1989.net/Notes/NOTE-why-has-nobody-told-me-this-before/</id>
    <published>2023-02-13T01:59:49.000Z</published>
    <updated>2023-02-14T01:28:06.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="就是开心不起来怎么办">就是开心不起来怎么办</h3><h4 id="如何看待情绪低落">如何看待情绪低落</h4><ul><li>情绪有起伏波动是狠正常的，没有人能一直开兴。但我们不能被情绪控制，而应该去做一些有帮助的事情。</li><li>情绪低落并不是大脑出了问题，更可能是因为需求没有得到满足。</li><li>我们生活中的每一刻都可以拆解成体验的不同方面。</li><li>这些方面相互影响，向我们展示了我们是如何陷入情绪低落（甚至是抑郁）的恶性循环的。</li><li>我们的情绪是通过那些我们能影响的事情构建的。</li><li>情绪没有开关，我们也无法选择情绪，但我们可以利用可控的东西来改变自己的感受。</li><li>使用十字概念化这个工具（如下图所示）来培养觉察能力，注意哪些因素会影响我们的情绪，让我们深陷其中。</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/87e1ba72e2112f5c0b54a8843a4b41a7.png" alt="纠结于消极的想法很可能会让人情绪低落，而情绪低落又会催生出更多消极的想法。这张图很好地说明了我们是如何陷入情绪低落的恶性循环，同时也告诉我们，如何才能走出困境。"></p><h4 id="当心情绪陷阱">当心情绪陷阱</h4><ul><li>思维偏差是不可避免的，但对其负面影响，我们并不是无能为力。</li><li>我们会自然而然地寻找证据来证实自己的看法，并坚定地相信它，尽管有很多其他证据表明这种看法并不正确。</li><li>情绪低落是由什么引起的，都会让我们将注意力集中在威胁与消极因素上。</li><li>如果我们持续关注这些因素，并把它们当作事实，那么这种负面偏见就会中庸到我们身上，加剧情绪低落。</li><li>对抗这种恶性循环的策略就是要弄明白，感受并不能作为证据，它不能证明你的想法就是事实。</li><li>另一种策略是保持好奇、探究的态度。</li><li>通过了解常见的思维偏差类型，和这些想法保持距离，注意它们可能会在什么时候出现，时刻记住它们只是偏见，不是事实。</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/ee25c3fe40343a79901e40c4edefbebe.png" alt="思维偏差的种类及实例"></p><h4 id="怎么做才有用">怎么做才有用</h4><ul><li>我们无法控制突然出现在脑海中的想法，但我们可以控制注意力的聚焦点。</li><li>试图不去想某件事，只会让你想得更多。</li><li>允许所有想法的存在，但要确定哪些想法是值得投入时间和精力的，这对我们的情感体验有很大的影响。</li><li>正念练习与感恩练习能够训练我们转移注意力的能力。</li><li>当我们专注与一个问题的时候，也要关注我们前进的方向，以及我们想要如何感受，如何行动。</li><li>想法不是事实，想法只是大脑给出的意见，帮助我们理解这个世界。</li><li>一个想法对我们能有多大影响，取决于我们在多大程度上相信它是事实。</li><li>要从想法中汲取力量，就需要后退异步，与它保持一定的距离（元认知策略：注意到你的脑海中出现了哪些想法，并观察它们给你带来的感受的过程。），看清它的真实面目。</li></ul><h4 id="如何把糟糕的一天变成美好的一天">如何把糟糕的一天变成美好的一天</h4><ul><li>我们应该专注于做出好的决定，而不是完美的决定。以“足够好”为标准，会引导你做出真正的改变。完美主义会导致你瞻前顾后，难以做出选择，而要想改善情绪，你必须做出决定，采取行动。</li><li>改变可以从小事做起，要持之以恒。</li><li>别人情绪低落时，我们通常会表现得友好、体贴，因为我们知道这正是它们所需要的。所以当我们努力调节情绪和心理状态时，也应该练习自我关怀。</li><li>明白了这些，你就能以此为出发点，找到自己想要的方向，并专注于脚下的路。</li></ul><h4 id="防御，让你不被打倒的力量">防御，让你不被打倒的力量</h4><ul><li>守护心理健康的“守门员”为身心健康打下了基础。如果你每天都能照顾好它们，它们一定会给你丰厚的回报。</li><li>如果你今天只想给自己安排一件事，那就去运动吧。选择你喜欢的运动，这样更容易坚持。</li><li>睡眠与心理健康是相互作用的。高质量的睡眠对心理健康有益，改变心理状态也会促进睡眠。</li><li>你给大脑充电的方式会影响你的感受。研究表明，传统的<a href="https://zh.wikipedia.org/zh-hans/%E5%9C%B0%E4%B8%AD%E6%B5%B7%E9%A3%B2%E9%A3%9F" target="_blank" rel="noopener">地中海饮食</a>、<a href="https://zh.wikipedia.org/zh-hans/%E6%97%A5%E6%9C%AC%E6%96%99%E7%90%86" target="_blank" rel="noopener">日本饮食</a>与<a href="https://zh.wikipedia.org/zh-hans/%E6%8C%AA%E5%A8%81%E9%A3%B2%E9%A3%259https://zh.wikipedia.org/zh-hans/%E6%8C%AA%E5%A8%81%E9%A3%B2%E9%A3%9FF" target="_blank" rel="noopener">挪威饮食</a>对心理健康有益。</li><li>人与人的连接是强化复原力的有力工具。人际关系会改变你的身心状态。</li></ul><h3 id="做事提不起精神，没有动力怎么办">做事提不起精神，没有动力怎么办</h3><h4 id="理解驱动力">理解驱动力</h4><ul><li>驱动力并不是与生俱来的。</li><li>那种充满动力，想要去做某事的感觉不会一直存在，所以你不能依赖它。</li><li>要掌控你的驱动力，就是培养这样一种能力：无论你有多么不想做，你也会自动去做那些对你最重要的事。</li><li>拖延症通常是为了逃避压力和不适感。</li><li>快感缺失指的是我们现在无法从过去喜欢做的事中找到乐趣，通常和情绪低落、抑郁症有关。</li><li>如果有些事对你很重要，同时又对你的健康有益，那么现在就去做，不要等到你想做的时候才行动。</li></ul><h4 id="如何培养动机感">如何培养动机感</h4><ul><li>虽然我们无法控制动机感，但我们可以做一些事情来让自己更多地体验到动机感。</li><li>要培养动机感，得先让身体动起来。哪怕是少量的运动，也比完全不运动好，能让你充满动力。</li><li>与目标保持连接有助于持续激发驱动力。</li><li>从微小而持续的行动开始。</li><li>在压力环境中学会休息，补充能量，能最大程度地锻炼意志力。</li><li>羞耻感并不像你想的那样，能够让你产生驱动力。你要做的是改变你与失败的关系。</li></ul><h4 id="不想做一件事时，怎样才能让自己去做呢">不想做一件事时，怎样才能让自己去做呢</h4><ul><li>驱动力不是永远存在的。</li><li>我们可以练习与冲动相反的行为，我们要按照自己的价值观做事，而不是根据当下的感受。</li><li>只要重复的次数足够多，一个新的行为就能成为习惯。</li><li>要想实现远大的目标，在前进的道路上就必须休息、充电，就像优秀的运动员那样，这非常重要。</li><li>在实现目标的过程中，不断给自己小小的奖励。</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/31cfde9c9f710898c3d6388cf1fd70f3.png" alt="做出改变与维持现状的利弊"></p><h4 id="重大的人生改变，应该从哪里开始">重大的人生改变，应该从哪里开始</h4><ul><li>我们有时候并不清楚应该改变什么以及如何去改变。</li><li>没有对自我的理解，就无法改变。</li><li>彻底了解你的问题所在，才能更容易确定下一步应该怎么做。</li><li>事情发生后，先反思一下。</li><li>准备好诚实地面对：你是如何导致问题的出现，又是如何让自己陷入困境的。</li><li>心理治疗的过程能为你提供支持，如果你没机会看心理医生，也可以从记日记开始。</li></ul><h3 id="陷入痛苦情绪怎么办">陷入痛苦情绪怎么办</h3><h4 id="让情绪全部消失">让情绪全部消失</h4><ul><li>情绪既不是敌人，也不是朋友。</li><li>我们对自己的情绪状态的影响力笔我们以为的要大的很多。</li><li>抗拒情绪只会带来更多问题，我们不如接纳情绪，顺其自然。</li><li>情绪不是事实，只是一个可能的视角。</li><li>如果你现在有痛苦的情绪，保持好奇心，提出问题——情绪能告诉你什么？</li></ul><h4 id="如何处理情绪">如何处理情绪</h4><ul><li>感受不能代表你，你也不能等同于你的感受。</li><li>情绪的感受就是经由你身体的体验。</li><li>每种情绪都能给你提供信息，但这些信息并不全面。</li><li>情绪的作用就是告诉你，你需要什么。</li><li>当你感受到情绪时，就给它起个名字。情绪不仅包括快乐或悲伤，还应该有更细致的分类方式。</li><li>我们应该接纳情绪，而不是抗拒情绪。要学会自我安抚。</li></ul><h4 id="如何利用语言的力量">如何利用语言的力量</h4><ul><li>我们所使用的语言极大地影响这我们对世界的体验。</li><li>描述自己感受的词汇越多越好。</li><li>想不出合适的词语时，可以参考感受圆盘。</li><li>注意别人是如何用词的，你可以通过读书、看电影等多种凡是来扩大自己的情绪词汇量。</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/df5eae13d31c1027bd7bc01863922a4a.png" alt="在感受圆盘中找到能描述自己感受的词汇"></p><h4 id="当你关心的人陷入痛苦时">当你关心的人陷入痛苦时</h4><ul><li>当别人出现心理问题时，我们想去帮助他，但又觉得不知所措、力不从心，这是很正常的。</li><li>看到别人遭受痛苦，你想支持他，又怕自己说错话，这回让你很有压力，但一定不要因此回避他。</li><li>强有力的支持并不意味着要解决所有问题。</li><li>要照顾好自己，别让自己心力交瘁。维护自己的利益，设定清晰的界限。</li><li>永远不要低估倾听的力量。</li></ul><h3 id="无法走出悲伤怎么办">无法走出悲伤怎么办</h3><h4 id="理解悲伤">理解悲伤</h4><ul><li>那些对我们来说意义重大的事物的结束，都会引发悲伤——这种结束不一定是死亡。</li><li>悲伤是人类情感体验中很正常、自然的一部分。</li><li>痛苦可以是情绪上的，也可以是身体上的。</li><li>有帮助的事情并不会让痛苦小事，也不会迫使你放手。</li><li>完全回避悲伤可能会导致更深层次的问题。</li></ul><h4 id="悲伤的阶段">悲伤的阶段</h4><ul><li>否认能帮助我们承受住悲伤带来的痛苦。否认消退后，新的情绪会付出水面。</li><li>如果你无法控制愤怒的情绪，可以去做运动，利用生理唤醒，让身体暂时恢复平静。</li><li>反复思考“假如…现在会怎样”，很容易把自己引入自责的陷阱。</li><li>抑郁是失去亲人后的正常反应。</li><li>接受并不意味这你喜欢或认可现状。</li></ul><h4 id="哀悼的任务">哀悼的任务</h4><ul><li>治愈悲伤的第一步是允许自己感受痛苦。</li><li>我们需要时间来适应亲人已不复存在的生活。</li><li>我们需要找到一种方法，即使亲人不在了，也能继续和他们保持连接。</li><li>接受新的现实，我们才能继续去做那些对我们很重要的事。无论你有什么样的感受，都是正常的。</li><li>不要低估每一小步的作用，稳步前进。</li></ul><h4 id="力量的支柱">力量的支柱</h4><ul><li>时间、努力与坚持能帮合租你重建失去亲人后的生活。</li><li>通过新的方式与逝去的人保持连接，比如去你们一起去过的、有特殊意义的地方，或者去墓地悼念。</li><li>在整个过程中要尽可能地倾听自己的需求。</li><li>表达悲伤的方式无所谓对错。</li><li>不要规定自己必须多长时间走出悲伤。</li></ul><h3 id="低自尊人格，经常自我怀疑怎么办">低自尊人格，经常自我怀疑怎么办</h3><h4 id="如何看待别人的批评与否定">如何看待别人的批评与否定</h4><ul><li>学习正确地看待批评与否定，这是一项重要的生活技能。</li><li>我们天生就在乎别人对我们的看法，说“我不在乎任何人的想法”的人都不是真心的。</li><li>取悦别人绝不是表面上的与人为善，而是在任何情况下都把别人的需求置于自己的需求之上，甚至不惜损害自己的健康和幸福。</li><li>要理解为什么有些人总是吹毛求疵，这对你很有帮助。</li><li>你可以培养自尊感与羞耻感复原力，这能改变你的人生。</li></ul><h4 id="建立信心的关键">建立信心的关键</h4><ul><li>一个人只有在缺乏自信的情况下才会增加自信。</li><li>想要建立自信，就要走出舒适区。每天重复这样做，你的自信心会与日自增。</li><li>自信会根据情境而改变，当情境发生变化时，你要相信自己能克服畏惧，从而增强自信。</li><li>你不需要把自己置于最恶劣的环境中，可以从小的改变开始。</li><li>在建立自信的过程中，要做好自己的教练，而不是最苛刻的批评者。</li><li>先有勇气，再有自信。</li></ul><h4 id="你的错误不能代表你这个人">你的错误不能代表你这个人</h4><ul><li>大多数自我怀疑都与我们和失败的关系有关。</li><li>别人如何看待你的失败并不能说明你的个性，也不代表你作为人的价值。</li><li>失败带来的痛苦会驱使我们麻痹自己，自我封闭。就算你一开始没有觉察到自己的感受，你也可以觉察自己是通过哪些行为来屏蔽情绪的。</li><li>做自己的教练，把失败变成学习的机会，你才能不断进步，朝着你觉得最重要的方向努力。</li><li>失败会引发巨大的情绪反应，所以不要着急。</li></ul><h4 id="对自己更“狠”一些">对自己更“狠”一些</h4><ul><li>有一种误解，认为自我接纳会让人变得懒惰、自满、缺乏动力。</li><li>研究表明，那些能学着自我接纳、自我关怀的人不太可能惧怕失败，他们也更愿意再次尝试。</li><li>自我接纳不是被动地接受失败。</li><li>自我关怀也包括选择那条更难走但对你更有利的路。</li></ul><h3 id="极度焦虑，整天忧心忡忡怎么办">极度焦虑，整天忧心忡忡怎么办</h3><h4 id="消除焦虑">消除焦虑</h4><ul><li>人们希望消除焦虑是可以理解的，因为焦虑会令人不适。</li><li>要战胜恐惧，首先必须愿意面对它。</li><li>逃避只能短期缓解焦虑，长期来看，它只会加重焦虑。</li><li>我们为了控制和消除恐惧而做出的努力，正支配着我们的一举一动。</li><li>威胁应对系统会快速行动，你还来不及仔细思考，它就拉响了警报。</li></ul><h4 id="哪些做法会加重焦虑">哪些做法会加重焦虑</h4><ul><li>人在焦虑时最自然而然的反应就是逃避。</li><li>但逃避不会让焦虑消失。</li><li>仅仅告诉大脑某些东西是安全的还不够，你必须亲身体验，才能真正相信。</li><li>你需要一遍一遍重复这种行为，大脑才会被说服。</li><li>你做的最多的失去会成为你的舒适区。</li><li><strong>要想减轻对某件事的焦虑，就反复做这件事</strong>。</li></ul><h4 id="如何平复当下的焦虑">如何平复当下的焦虑</h4><ul><li>焦虑时，呼吸会变得急促、短浅。</li><li>想要让身体平静下来，请慢慢地深呼吸。</li><li>试着让呼气时间比吸气时间更长，呼气比吸气更有力。</li><li>要给它一些时间，焦虑反应会开始消退。</li></ul><h4 id="如何处理焦虑的想法">如何处理焦虑的想法</h4><ul><li>发现偏差并确定它是哪种类型的，这样才能与焦虑的想法保持距离。</li><li>记住，即使你还是会持续关注焦虑的想法，但你可以控制关注的焦点。</li><li>善意能减轻威胁反应，无论是来自他人的善意，还是我们对自己的善意。</li><li>将威胁重新定义为挑战，能让我们充满勇气。</li><li>行动要与价值观一致，你做决定应该根据什么对你最重要，而不是处于恐惧。</li></ul><h4 id="对不可避免的事情的恐惧">对不可避免的事情的恐惧</h4><ul><li>我们都惧怕死亡，包括它的已知和未知。</li><li>对于有些人来说，接近死亡会让他们成长，也会带来积极的生活转变。</li><li>接受死亡并不意味着放弃生命，而是恰恰相反。</li><li>接受死亡才能让我们赋予生命意义。</li></ul><h3 id="压力大到濒临崩溃怎么办">压力大到濒临崩溃怎么办</h3><h4 id="压力和焦虑有什么不同吗">压力和焦虑有什么不同吗</h4><ul><li>人们常把“压力”和“焦虑”这两个词混用</li><li>当我们的生理状态能够与外部需求相匹配时，即便有压力，我们也会把它解读为积极的感受。</li><li>当我们的大脑在为我们要做的事做准备时，我们就会感到压力。</li><li>大脑会释放能量，以提高警觉性，让我们对环境做出反应。</li><li>我们常把焦虑理解为基于恐惧而做出反应，实际上它是为了满足你的需求而产生的一种压力反应。</li></ul><h4 id="为什么减压不是唯一的答案">为什么减压不是唯一的答案</h4><ul><li>压力并不总是敌人，它也是最有价值的工具。</li><li>要学着在承受压力后充实身心，与试图消除压力相比，这个做法更实际。</li><li>压力能帮助你表现得更出色，也能驱使你做最重要的事，但我们不能一直处于压力状态。</li><li>适度的压力会让生活充满乐趣和挑战，但压力太大会让人无法感受到生活的美好。</li></ul><h4 id="当有益的压力变得有害">当有益的压力变得有害</h4><ul><li>短期的压力反应能激发出最好的状态。</li><li>长期压力就像在高速公路上开车挂二挡，用不了多长时间，就会出事故。</li><li>倦怠不仅仅是工作造成的。</li><li>没有万能的灵丹妙药。对其他人保持平衡有用的方法对你也许没有作用。</li><li>如果你出现倦怠的迹象，你要倾听它们并及时回应，要学着满足自己的需求。</li></ul><h4 id="把压力变成动力">把压力变成动力</h4><ul><li>改变一些简单的行为模式，比如呼吸模式，能改变你的压力水平。</li><li>科学表明，冥想对大脑和我们处理问题的方式有显著影响。</li><li>与他人建立连接能帮助我们从压力中恢复。社交隔离会让人身心俱疲，承受巨大压力。</li><li>以做出贡献为目标，而不是把竞争当成目标，这样在面对压力时，我们才有动力和毅力。</li><li>寻找能让自己产生敬畏之心的体验，以改变视角。</li></ul><h4 id="如何处理必须面对的压力">如何处理必须面对的压力</h4><ul><li>我们对压力的看法会影响我们在压力状态下的表现。</li><li>把压力看作一种财富，可以帮助你实现目标，你不需要花太多精力去摆脱压力，而是要专注于你被要求做到的事。</li><li>关注应该做什么，而不是不该做什么。</li><li>调整你的关注点可以改变压力水平。</li><li>改变你与失败的关系，培养羞耻感复原力，能帮助你应对高压环境。</li></ul><h3 id="觉得人生没有意义怎么办">觉得人生没有意义怎么办</h3><h4 id="关于“我只想要幸福”的问题">关于“我只想要幸福”的问题</h4><ul><li>我们经常被灌输的观念史，幸福才是常态，一个人要是觉得不幸福，那他肯定是有心理问题的。</li><li>有时我们会觉得不幸福，这恰恰是因为我们是人，而且，人生本就艰难。</li><li>让生命有价值的人或是带给我们的不仅仅是幸福感，也混杂了爱、快乐、恐惧、羞愧和伤害。</li><li>要弄清楚自己的价值观，因为它能引导我们去设定人生目标，而实现目标的过程是有意义、有价值的。</li><li>要把价值观放在第一位，因为它能帮助我们熬过人生的痛苦时刻，让我们知道自己走在正确的路上。</li></ul><h4 id="找到最重要的事">找到最重要的事</h4><ul><li>你可以通过一些简单的练习来弄清楚自己现阶段的价值观。</li><li>价值观会随着时间的推移而改变，我们的生活与价值观的一致程度也会改变，因此，有必要经常审视自己的价值观。</li><li>我们可以根据价值观进行大的目标设定，并确立日常的小目标。</li><li>重点不在于你希望会发生什么，而在于你想成为什么样的人，你想做出什么样的贡献，以及无论发生什么，你都会如何面对生活。</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/5ee2743c032d16c193da31c6c6daae4b.png" alt="价值观——请圈出对你而言最重要、最有意义的价值观"><br><img src="//s3.mindex.xyz/blog/Notes/ba2d9900c52c6ccd737d32a3680d4b23.png" alt="这张表格中的示例能说明价值观与目标的区别，应该如何让目标与价值观一致，并转化为日常行为。"></p><h4 id="如何创造有意义的人生">如何创造有意义的人生</h4><ul><li>在下定决心要做出改变时，我们往往会给自己设立一个宏大的、激进的新目标。</li><li>只有一个目标并不足以保证我们能做出改变，更不能保证长久的改变。</li><li>花时间思考并想象你要成为怎样的人，并把这些想法转化为具体的、可持续的行动，这样你会觉得自己的努力更有意义。</li><li>将你行动的初衷与身份认同练习起来，这样最初的目标实现后，新的行为习惯也会持续下去。</li></ul><h4 id="关系">关系</h4><ul><li>当我们谈到幸福生活时，关系要比金钱、名誉、社会阶层、基因以及所有我们被告知要尽力争取的东西都要重要。</li><li>我们的关系以及我们在关系中感受到的幸福程度与我们的整体健康密不可分，关系是幸福和健康的核心。</li><li>改善自我有助于改善关系，而改善关系又有助于改善自我。</li><li>童年时期所形成的依恋关系通常会体现在成年后的关系中。</li></ul><h4 id="何时该寻求帮助">何时该寻求帮助</h4><ul><li>只要你关心自己的心理健康，你随时可以去寻求帮助。</li><li>如果你不确定自己需要多少帮助，专业人士可以帮助你做出决策。</li><li>在理想的世界，无论是谁，只要需要，就能得到专业的心理治疗。但理想的世界并不存在。</li><li>如果没有条件获得专业服务，那就抓住一切机会去了解关于心理疗愈的只是，并向你信任的人寻求支持。</li></ul>]]></content>
    
    <summary type="html">
    
      人生中的事分两类，你能控制的，你不能控制的。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="Health" scheme="https://neo1989.net/tags/Health/"/>
    
  </entry>
  
  <entry>
    <title>人格障碍</title>
    <link href="https://neo1989.net/Notes/NOTE-personality-disorder/"/>
    <id>https://neo1989.net/Notes/NOTE-personality-disorder/</id>
    <published>2023-01-31T04:24:53.000Z</published>
    <updated>2023-01-31T05:16:25.479Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A类人格障碍">A类人格障碍</h3><p>表现为古怪的思想或行为。</p><h4 id="偏执型">偏执型</h4><ul><li>对他人的动机普遍表现出不信任和怀疑</li><li>毫无根据地认为他人试图伤害或欺骗自己</li><li>毫无根据地对他人的忠诚或诚信产生怀疑</li><li>由于无端地担心他人会利用获知的信息对付您，而不愿向他人倾诉</li><li>将无恶意言论或无威胁性情况视为人身侮辱或攻击</li><li>对察觉到的侮辱或轻蔑表现出愤怒或敌对反应</li><li>有怨恨倾向</li><li>毫无根据地反复怀疑配偶或性伴侣不忠</li></ul><h4 id="类精神分裂型">类精神分裂型</h4><ul><li>对社会或人际关系缺乏兴趣，喜欢独处</li><li>情感表达范围有限</li><li>在大多数活动中都无法获得乐趣</li><li>无法察觉社交暗示</li><li>看起来对别人很冷淡或漠不关心</li><li>几乎没有兴趣与他人发生性关系</li></ul><h4 id="精神分裂型">精神分裂型</h4><ul><li>穿着奇特、思想奇怪、有奇异的信念、言语怪异或行为怪癖</li><li>具有奇怪的感知经验，例如听到有声音在轻声呼唤自己的名字</li><li>表现出情绪平淡或不是当的情绪反应</li><li>社交焦虑、缺乏密切关系或对密切关系感到不适</li><li>表现出对他人冷淡」不当或怀疑的反应</li><li>“奇幻思维” —— 相信能用自己的思想影响身边的人和事</li><li>相信某些偶然时间具有仅对自己有意义的隐藏信息</li></ul><h3 id="B类人格障碍">B类人格障碍</h3><p>表现为戏剧性、过度情绪化或不可预测的思想或行为</p><h4 id="反社会型">反社会型</h4><ul><li>忽视他人的需求或感受</li><li>习惯撒谎、偷窃、使用别名和哄骗他人</li><li>反复违法</li><li>屡次侵犯他人的权利</li><li>经常有攻击和暴力行为</li><li>忽视自己或他人的安全</li><li>冲动行为</li><li>一贯不负责任</li><li>对自己的行为毫无悔意</li></ul><h4 id="边缘型">边缘型</h4><ul><li>表现出冲动和危险行为，例如不安全性行为、赌博或暴饮暴食</li><li>自我形象不稳定或脆弱</li><li>关系不稳定且紧张</li><li>心情起伏不定，往往是对人际压力的反应</li><li>自杀行为或自残威胁</li><li>强烈恐惧孤独或被抛弃</li><li>持续的空虚感</li><li>频繁且强烈地表现出愤怒</li><li>压力引起的妄想症，时有时无</li></ul><h4 id="表演型">表演型</h4><ul><li>不断寻求关注</li><li>用过度情绪化、戏剧化或性挑逗行为引起注意</li><li>固执己见，但几乎没有事实或细节支持</li><li>容易受他人影响</li><li>头脑简单，情绪变化太快</li><li>过度关注外表</li><li>过度乐观估计与他人的关系</li></ul><h4 id="自恋型">自恋型</h4><ul><li>认为自己很特别，且比他人更重要</li><li>对权力、成功和吸引力抱有幻想</li><li>不能认识到他人的需求和感受</li><li>对自己的成就或才能夸大其词</li><li>期望得到不断的赞美和欣赏</li><li>傲慢自大</li><li>不合理地期望得到利益和好处，经常利用他人</li><li>嫉妒他人，或认为被他人嫉妒</li></ul><h3 id="C类人格障碍">C类人格障碍</h3><p>表现为焦虑和恐惧的思想或行为</p><h4 id="回避型">回避型</h4><ul><li>对批评或拒绝太过敏感</li><li>感觉能力不足、自卑或缺乏吸引力</li><li>回避需要人际交往的工作活动</li><li>在社交上压抑、胆怯和孤立，不愿意参加新的活动或与陌生人见面</li><li>在社交场合和人际关系中极为害羞</li><li>害怕不被认可、尴尬或受到嘲笑</li></ul><h4 id="依赖型">依赖型</h4><ul><li>过度依赖他人，感觉自己需要被照顾</li><li>对他人表现出顺从或粘人的行为</li><li>害怕独自一人时不得不照顾自己</li><li>缺乏自信，即使做出很小的决定也需要别人的过度建议和肯定</li><li>因缺乏自信而难以独自开始或完成项目</li><li>难以与他人持不同意见，担心不被认可</li><li>即使有其他选择，也会容忍粗暴或虐待行为</li><li>当一段亲密关系结束时，迫切需要开始一段新的关系</li></ul><h4 id="强迫型">强迫型</h4><p>强迫型人格障碍不同于强迫症。</p><ul><li>对于细节、秩序和规则的先占观念</li><li>极端的完美主义，当未能达到完美时，例如因为没有达到自己的严格标准而无法完成一个项目，会导致身体机能障碍和痛苦</li><li>渴望控制他人、任务和局势，却无法委派任务</li><li>对工作或项目过度投入。从而忽视朋友和娱乐活动</li><li>无法丢弃破损或毫无价值的东西</li><li>刻板而固执</li><li>在道德、伦理或价值观方面过于死板</li><li>在控制预算和花钱方面很严格且吝啬</li></ul>]]></content>
    
    <summary type="html">
    
      如果您有任何一种人格障碍的体征和症状，请咨询您的医生、其他初级保健专家或心理健康专家。如果不加以治疗，人格障碍会给您的生活带来严重问题，并且情况可能变得越来越糟。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="Health" scheme="https://neo1989.net/tags/Health/"/>
    
  </entry>
  
  <entry>
    <title>Building a cool chatbot</title>
    <link href="https://neo1989.net/HandMades/HANDMADE-build-a-cool-chatbot-step-by-step/"/>
    <id>https://neo1989.net/HandMades/HANDMADE-build-a-cool-chatbot-step-by-step/</id>
    <published>2022-12-06T08:43:27.000Z</published>
    <updated>2023-01-06T08:11:24.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Concepts">Concepts</h2><p><strong>Natural Language Processing (NLP)</strong> is a field of Artificial Intelligence that enables computers to analyze and understand the human language.</p><p><strong>Natural Language Understanding (NLU)</strong> is a subset of a bigger picture of NLP, just like machine learning, deep learning, NLP, and data mining are a subset of a bigger picture of Artificial Intelligence (AI), which is an umbrella term for any computer program that does something smart.</p><p><strong><a href="https://spacy.io/" target="_blank" rel="noopener">spaCy</a></strong> is an open-source software library for advanced NLP, written in Python and Cython. It provides intuitive APIs to access its methods trained by deep learning models.</p><h2 id="Cornerstones">Cornerstones</h2><p>Before we actually dive into spaCy and code snippets, make sure we have the necessary setup ready.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/chatBot &amp;&amp; <span class="built_in">cd</span> ~/chatBot</span><br><span class="line">pyenv virtualenv 3.8.5 chatBot</span><br><span class="line">pyenv <span class="built_in">local</span> chatBot</span><br><span class="line">pip install spacy==3.4.3</span><br></pre></td></tr></table></figure><p><a href="https://spacy.io/models" target="_blank" rel="noopener">spaCy models</a> are just like any other machine learning or deep learning models. A model is a yield of an algorithm or, say, an object that is created after training data using a machine learning algorithm. spaCy has lots of such models that can be placed directly in our program by downloading it just like any other Python package.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m spacy download zh_core_web_lg</span><br><span class="line">python -m spacy download en_core_web_lg</span><br></pre></td></tr></table></figure><h3 id="POS-Tagging">POS Tagging</h3><p>Part-of-speech (POS) tagging is a process where you read some text and assign parts of speech to each word or token, such noun, verb, adjective, etc.<br>POS tagging becomes extremely important when you want to identify some entity in a given sentence. The first step is to do POS tagging and see what our text contains.<br>Let’s get our hands dirty with some of the examples of real POS tagging.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'zh_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">'明天的天气如何？'</span>)</span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    print(token.text, token.pos_)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">明天 NOUN</span><br><span class="line">的 PART</span><br><span class="line">天气 NOUN</span><br><span class="line">如何 VERB</span><br><span class="line">？ PUNCT</span><br></pre></td></tr></table></figure><h3 id="Stemming-and-Lemmatization">Stemming and Lemmatization</h3><p><strong>Stemming</strong> is the process of reducing inflected words to their word stem, base form.<br>A stemming algorithm reduces the words “saying” to the root word “say”, whereas “presumable” becomes “presum”. As you can see, this may or may not always be 100% correct.<br><strong>Lemmatization</strong> is closely related to <strong>stemming</strong>, but lemmatization is the algorithmic process of determining the lemma of a word based on its intended meaning.<br>spaCy doesn’t have any in-built stemmer, as lemmatization is considered more correct and productive. (spaCy 没有内置的词干提取器，因为词形还原被认为更加准确和有效。)<br>Difference between Stemming and lemmatization:</p><ul><li><strong>Stemming</strong> does the job in a crude, heuristic way that chops off the ends of words, assuming that the remaining word is what we are actually looking for, but it often includes the removal of derivational affixes.</li><li><strong>Lemmatization</strong> tries to do the job more elegantly with the use of a vocabulary and morphological analysis of words. It tries its best to remove inflectional endings only and return the dictionary form of a word, konwn as the lemma.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.stem.porter <span class="keyword">import</span> PorterStemmer</span><br><span class="line">stemmer = PorterStemmer()</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> [<span class="string">'went'</span>, <span class="string">'goes'</span>]:</span><br><span class="line">    print(w, stemmer.stem(w))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">went went</span><br><span class="line">goes goe</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'en_core_web_lg'</span>)</span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> nlp(<span class="string">'went goes'</span>):</span><br><span class="line">    print(token.text, token.lemma_)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">went go</span><br><span class="line">goes go</span><br></pre></td></tr></table></figure><p>Since you are pretty much aware what a stemming or lemmatization does in NLP, you should be able to understand that whenever you come across a situation where you need the root form of the word, you need to do lemmatization there. For example, it is often used in building search engines. You must have wondered how Google gives you the articles in search results that you meant to get even when the search text was not properly formulated.<br>This is where one makes use of lemmatization.<br>Imageine you search with the text, “When will the next season of Game of Thrones be releasing?”<br>Now, suppose the search engine does simple document word frequency matching to give you search results. In this case, the aforementioned query probably won’t match an article with a caption “Game of Thrones next season release date”.<br>If we do the lemmatization of the orginal question before going to matchh the input with the documents, then we may get better results.</p><h3 id="Named-Entity-Recognition">Named-Entity Recognition</h3><p><strong>NER</strong>, also known by other names like <strong>entity identification</strong> or <strong>entity extraction</strong>, is a process of finding and classifying <a href="https://en.wikipedia.org/wiki/Named_entity" target="_blank" rel="noopener">named entities</a> existing in the given text into pre-defined categories.<br>The NER task is hugely dependent on the knowledge base used to train the NE extraction algorithm, so it may or may not work depending upon the provided dataset it was trained on.<br>spaCy comes with a very fast entiry recognition model that is capable of identifying entity phrases from a given document. Entities can be of different types, such as person, location, organization, dates, numerals, etc. These entities can be accessed through .ents property of the doc object.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'zh_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">"欧盟拟向东南亚投资100亿欧元"</span>)</span><br><span class="line"><span class="keyword">for</span> ent <span class="keyword">in</span> doc.ents:</span><br><span class="line">    print(ent.text, ent.label_)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">欧盟 ORG</span><br><span class="line">东南亚 LOC</span><br><span class="line"><span class="number">100</span>亿欧元 MONEY</span><br></pre></td></tr></table></figure><h3 id="Stop-Words">Stop Words</h3><p>Stop words are high-frequency words like a, an, the, to and also that we sometimes want to filter out of a document before further processing. Stop words usually have little lexical content and do not hold much of meaning.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy.lang.zh.stop_words <span class="keyword">import</span> STOP_WORDS</span><br><span class="line">print(list(STOP_WORDS)[:<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">[<span class="string">'岂止'</span>, <span class="string">'当即'</span>, <span class="string">'纵'</span>, <span class="string">'▲'</span>, <span class="string">'几经'</span>, <span class="string">'上来'</span>, <span class="string">'什麽'</span>, <span class="string">'假使'</span>, <span class="string">'×'</span>, <span class="string">'『'</span>]</span><br></pre></td></tr></table></figure><p>Tosee if a word is a stop word or not, you can use the nlp object of spaCy. We can use the nlp object’s is_stop attribute.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nlp.vocab[<span class="string">"的"</span>].is_stop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="Dependency-Parsing">Dependency Parsing</h3><p>Dependency parsing is one of the more beautiful and powerful features of spaCy that is fast and accurate. The parser can also be used for sentence boundary detection and lets you iterate over base noun phrases, or “chunks”.<br>This feature of spaCy gives you a parsed tree that explains the parent-child relationship between the words or phrases and is indenpendent of the order in which words occur.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'en_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">"Book me a flight from Bangalore to Goa"</span>)</span><br><span class="line">print(doc[<span class="number">5</span>], list(doc[<span class="number">5</span>].ancestors))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">Bangalore [<span class="keyword">from</span>, flight, Book]</span><br></pre></td></tr></table></figure><p>Ancestors are the rightmost token of this token’s syntactic descendants.<br>To check if a doc object item is an ancestor of another <em>doc</em> object item programmactically, we can do the following:<br><code>doc[3].is_ancestor(doc[5])</code><br>The above returns <code>True</code> because doc[3] (i.e., flight) is an ancestor of doc[5] (i.e., Bangalore).</p><p>Children are immediate syntactic dependents of the token. We can see the children of a word by using children attribute just like we used ancestors.<br><code> list(doc[3].children)</code> will output <code>[a, from, to]</code></p><p>Dependency parsing is one the most important parts when building chatbots from scratch. It becomes far more important when youn want to figure out the meaning of a text input from your user to your chatbot. There can be cases when you haven’t trained your chatbots, but still you don’t want to lose your customer or reply like a dumb machine.<br>In these cases, dependency parsing really helps to find the relation and explain a bit more about what the user may be asking for.<br>If we were to list things for which dependency parsing helps, some might be:</p><ul><li>It helps in finding relationships between words of grammatically correct sentences.</li><li>It can be used for sentence boundary detection.</li><li>It is quite useful to find out if the user is talking about more than one context simulationeously.<br>You need to write your own custom NLP to understand the context of the user or your chatbot and, based on that, identify the possible grammatical mistakes a user can meke.</li></ul><p>All in all, you must b ready for such scenarious where a user will input garbage values or grammatically incorrect sentences. You can’t handle all such scenarios at once, but you can keep improve you chatboot by adding custom NLP code or by limiting user input by design.</p><h3 id="Noun-Chunks">Noun Chunks</h3><p>Noun chunks or NP-chunking are basically “base noun phrases”. We can say they are flat phrases that have anoun as their head. You can think of noun chunks as a noun with the words describing the noun.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'en_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">"Boston Dynamics is gearing up to produce thousands of robot dogs"</span>)</span><br><span class="line">print(list(doc.noun_chunks))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">[Boston Dynamics, thousands, robot dogs]</span><br></pre></td></tr></table></figure><p><strong>The ‘noun_chunks’ syntax iterator is not implemented for language 'zh’</strong></p><h3 id="Finding-Similarity">Finding Similarity</h3><p>Finding similarity between two words is a use-case you will find most of the time working with NLP. Sometimes it becomes fairly important to find if two words are similar. While building chatbots you will often come to situations where you don’t have to just find similar-lokking words but also how closely related two words are logically.<br>spaCy uses high-quality word vectors to find similarity between two words using <strong>GloVe algorithm</strong> (Global Vectors for Word Representation).<br>GloVe is an unsupervised learning algorithm for obtaining vector representations for words. GloVe algorithm uses aggregated global word-word co-occurrence statistics from a corpus to train the model.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'zh_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">"美团小贷注册资本增至75亿元"</span>)</span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">     print(token.text, token.vector[:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Output #</span><br><span class="line">美团 [<span class="number">-0.78366</span>  <span class="number">0.31008</span> <span class="number">-1.0793</span>  <span class="number">-0.87563</span>  <span class="number">0.56224</span>]</span><br><span class="line">小贷 [ <span class="number">1.0563</span>  <span class="number">-2.695</span>   <span class="number">-0.44203</span>  <span class="number">0.98277</span> <span class="number">-4.8158</span> ]</span><br><span class="line">注册 [ <span class="number">3.4941</span> <span class="number">-2.8909</span> <span class="number">-4.572</span>  <span class="number">-2.0436</span> <span class="number">-1.9986</span>]</span><br><span class="line">资本 [ <span class="number">3.8849</span>  <span class="number">0.3031</span> <span class="number">-2.382</span>   <span class="number">2.8471</span> <span class="number">-2.7938</span>]</span><br><span class="line">增至 [ <span class="number">1.469</span>   <span class="number">1.0054</span>  <span class="number">5.4963</span>  <span class="number">1.8396</span> <span class="number">-3.7624</span>]</span><br><span class="line"><span class="number">75</span>亿 [ <span class="number">0.3056</span>   <span class="number">0.69498</span>  <span class="number">1.4444</span>   <span class="number">0.91454</span> <span class="number">-0.97031</span>]</span><br><span class="line">元 [ <span class="number">2.8509</span>  <span class="number">-0.53181</span> <span class="number">-2.646</span>   <span class="number">-0.5862</span>  <span class="number">-4.0398</span> ]</span><br></pre></td></tr></table></figure><p>Seeing this output, it doesn’t make much sense and meaning. From an application’s perspective, what matters the most is how similar the vectors of different words are – that is, the word’s meaning itself.<br>In order to find similarity between two words in spaCy, we can do the following.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'en_core_web_lg'</span>)</span><br><span class="line"><span class="builtin-name">print</span>(nlp(<span class="string">"car"</span>).similarity(nlp(<span class="string">"truck"</span>)))</span><br><span class="line"><span class="builtin-name">print</span>(nlp(<span class="string">"car"</span>).similarity(nlp(<span class="string">"plane"</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">0.7760473774094219</span><br><span class="line">0.4592993678544094</span><br></pre></td></tr></table></figure><p>The word ‘car’ is more related and similar to the word ‘truck’ than the word ‘plane’.<br>We can also get the similarity between sentences.</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> spacy</span><br><span class="line"><span class="attr">nlp</span> = spacy.load('en_core_web_lg')</span><br><span class="line"><span class="attr">str1</span> = nlp(<span class="string">"When will next season of Game of Thrones be releasing?"</span>)</span><br><span class="line"><span class="attr">str2</span> = nlp(<span class="string">"Game of Thrones next season release date?"</span>)</span><br><span class="line">print(str1.similarity(str2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line"><span class="number">0.8226084934378249</span></span><br></pre></td></tr></table></figure><p>As we can see in this example, the similarity between both of the sentences is about 82%, which is good enough to say that both of the sentences are quite similar, which is true. This can help us save a lot of time for writing custom code when build chatbots.</p><h3 id="Tokenization">Tokenization</h3><p>Tokenization is one of the simple yet basic concepts of NLP where we split a text into meaningful segments. spaCy first tokenizes the text (i.e., segments it into words and then punctuation and other things). A question might come to your mind: Why can’t I just use the built-in split method of Python language and do the tokenization? Python’s split method is just a raw method to split the sentence into tokens given a sepatator. It doesn’t take any meaning into account, whereas tokenization tries to preserve the meaning as well.</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'zh_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">"告诉我处女座今天的运势"</span>)</span><br><span class="line">for tk <span class="keyword">in</span> doc:</span><br><span class="line">    print(tk.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Output #</span><br><span class="line">告诉</span><br><span class="line">我</span><br><span class="line">处女座</span><br><span class="line">今天</span><br><span class="line">的</span><br><span class="line">运势</span><br></pre></td></tr></table></figure><p>If you are not satisfied with spaCy’s tokenization, you can use its <em>add_special_case</em> method to add your own rules before relying completely on spaCy’s tokenization method.</p><h3 id="Regular-Expressions">Regular Expressions</h3><p>You must already know about regular expressions and their usage.<br>Text analysis and processing is a big subject in itself. Sometimes words play together in a way that makes it extremely difficult for machines to understand and get trained upon.<br>Regular expression can come handy for some fallback for a machine learning model. It has the power of pattern-matching, which can ensure that the data we are processing is correct or incorrect. Most of the early chatbots were hugely dependent on pattern-matching.<br>Given the power of machine learning these days, regular expression and pattern-matching has taken a back step, but make sure you brush up a bit about it as it may be needed at any time to parse specific details from words, sentences, or text documents.</p><h2 id="The-Hard-Way">The Hard Way</h2><p>“Building Chatbots the Hard Way” is not to hard to learn. It’s the hard way of building chatbots to have full control over your own chatbots. If you want to build everything yourself, then you take the hard route. The harder route is hard when you go through it but beautiful and clear when you look back.</p><blockquote><p>It is a rough road that leads to the heights of etness. – Lucius Annaeus Seneca</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install rasa==<span class="number">3.4</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><h3 id="构建Rasa机器人的步骤">构建Rasa机器人的步骤</h3><ul><li>初始化项目</li><li>准备NLU训练数据</li><li>准备故事story</li><li>定义领域domain</li><li>定义规则rule</li><li>定义动作action</li><li>配置config</li><li>训练模型</li><li>测试机器人</li><li>发布机器人</li></ul><h3 id="Building-a-Simple-Horoscope-Bot">Building a Simple Horoscope Bot</h3><p>Let’s decide the scope of this chatbot and see what it does and can do.</p><ul><li>The Horoscope Bot should be able to understand greetings and reply with a greeting.</li><li>The bot should be able to understand if there user is asking for horoscope.</li><li>The bot should be able to ask the horoscope sign of the user if the user doesn’t provide it.</li><li>The bot should learn from existing responses to formulate a new response.<br>It is pretty simple what our bot is supposed to do here.</li></ul><p>Possible intents</p><ul><li>Greeting Intent: User starting with a greeting</li><li>Get Horoscope Intent: User asking for horoscope</li><li>User’s Horoscope Intent: User telling the horoscope sign</li></ul><p>We’ll try to build the bot that does the basic task of giving a horoscope.<br>Let’s create a possible conversation script between our chatbot and the user.</p><pre><code>User: HelloBot: 你好，有什么能帮到你？User: 看一下今年的运势Bot: 想查哪个星座的运势?User: 双鱼的Bot: 由于天王星的逆行，可能会打乱双鱼座的节奏，所以双鱼座本年要懂得韬光养晦，要努力的去沉淀自己...</code></pre><p>This conversation is just to have a fair idea of how our chatbot conversation is going to look.<br>We can have our chatbot model itself trained to prepare a valid response instead of writing a bunch of <code>if ... else</code> statements.</p><h4 id="Initializing-the-bot">Initializing the bot</h4><p>Let’s init our bot.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/chatBot</span><br><span class="line">rasa init --no-prompt</span><br></pre></td></tr></table></figure><h4 id="Preparing-data">Preparing data</h4><p>First, prepare the <strong>nlu</strong> data. (nlu负责意图提取和实体提取)<br>The following is what my <strong><code>nlu.yml</code></strong> under <strong>data</strong> folder looks like:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">nlu:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">greet</span></span><br><span class="line">    <span class="attr">examples:</span> <span class="string">|</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hello</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">goodbye</span></span><br><span class="line">    <span class="attr">examples:</span> <span class="string">|</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bye</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">goodbye</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">    <span class="attr">examples:</span> <span class="string">|</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">查一下[今天](date_time)的运势</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">看一下[狮子座](horoscope_sign)如何</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">info_date_time</span></span><br><span class="line">    <span class="attr">examples:</span> <span class="string">|</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">[今日](date_time)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">[明天](date_time)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">info_horoscope_sign</span></span><br><span class="line">    <span class="attr">examples:</span> <span class="string">|</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">[白羊](horoscope_sign)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">[金牛](horoscope_sign)</span></span><br></pre></td></tr></table></figure><p>Then, prepare the <strong>stories</strong> data (Rasa是通过学习story的方式来学习对话管理知识).<br>The following is what my <strong><code>stories.yml</code></strong> under <strong>data</strong> folder looks like:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stories:</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">story:</span> <span class="string">greet</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">greet</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">utter_greet</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">story:</span> <span class="string">say</span> <span class="string">goodbye</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">goodbye</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">utter_goodbye</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">story:</span> <span class="string">get</span> <span class="string">horoscope</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">or:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">      <span class="attr">entities:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">horoscope_sign:</span> <span class="string">双鱼</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">      <span class="attr">entities:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">date_time:</span> <span class="string">今天</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">      <span class="attr">entities:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">horoscope_sign:</span> <span class="string">双鱼</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">date_time:</span> <span class="string">今天</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">horoscope_form</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="string">horoscope_form</span></span><br></pre></td></tr></table></figure><p>Then, prepare the <strong>domain</strong> data (domain定义了chatbot需要知道的所有信息，包括intent, entity, slot, action, form, response).<br>The following is what my <strong><code>domain.yml</code></strong> under project root looks like:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">intents:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">greet</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">goodbye</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get_horoscope</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">info_date_time</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">info_horoscope_sign</span></span><br><span class="line"></span><br><span class="line"><span class="attr">entities:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">date_time</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">horoscope_sign</span></span><br><span class="line"></span><br><span class="line"><span class="attr">slots:</span></span><br><span class="line">  <span class="attr">date_time:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">text</span></span><br><span class="line">    <span class="attr">influence_conversation:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">mappings:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">entity:</span> <span class="string">date_time</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">from_entity</span></span><br><span class="line">        <span class="attr">conditions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="string">horoscope_form</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">horoscope_sign:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">text</span></span><br><span class="line">    <span class="attr">influence_conversation:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">mappings:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">entity:</span> <span class="string">horoscope_sign</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">from_entity</span></span><br><span class="line">        <span class="attr">conditions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="string">horoscope_form</span></span><br><span class="line"><span class="attr">responses:</span></span><br><span class="line">  <span class="attr">utter_greet:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">text:</span> <span class="string">"你好，有什么能帮到你？"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">utter_goodbye:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">text:</span> <span class="string">"再见"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">utter_ask_horoscope_sign:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">text:</span> <span class="string">"想查哪个星座的运势?"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">utter_ask_date_time:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">text:</span> <span class="string">"想查今天、明天、本周、本月还是今年的运势？"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">utter_greet</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">utter_goodbye</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">utter_ask_horoscope_sign</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">utter_ask_date_time</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">action_get_horoscope</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">action_default_fallback</span></span><br><span class="line"></span><br><span class="line"><span class="attr">forms:</span></span><br><span class="line">  <span class="attr">horoscope_form:</span></span><br><span class="line">    <span class="attr">ignored_intents:</span> <span class="string">[]</span></span><br><span class="line">    <span class="attr">required_slots:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">date_time</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">horoscope_sign</span></span><br><span class="line"></span><br><span class="line"><span class="attr">session_config:</span></span><br><span class="line">  <span class="attr">session_expiration_time:</span> <span class="number">60</span></span><br><span class="line">  <span class="attr">carry_over_slots_to_new_session:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Then, prepare the <strong>rule</strong> (rule负责将问题分类映射到对应的动作上).<br>The following is what my <strong><code>rules.yml</code></strong> under <strong>data</strong> folder looks like:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">rule:</span> <span class="string">activate</span> <span class="string">horoscope</span> <span class="string">form</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">horoscope_form</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="string">horoscope_form</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">rule:</span> <span class="string">submit</span> <span class="string">form</span></span><br><span class="line">    <span class="attr">condition:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="string">horoscope_form</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">horoscope_form</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="literal">null</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">slot_was_set:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">requested_slot:</span> <span class="literal">null</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">action_get_horoscope</span></span><br></pre></td></tr></table></figure><p>Then, prepare the <strong>action</strong> (action接收用户输入和对话状态信息，按照业务逻辑进行处理，并输出改变对话状态的事件和回复用户的消息).<br>The following is what my <strong><code>actions.py</code></strong> under <strong>actions</strong> folder looks like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionGetHoroscope</span><span class="params">(Action)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span> -&gt; Text:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"action_get_horoscope"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, dispatcher: CollectingDispatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">            tracker: Tracker,</span></span></span><br><span class="line"><span class="function"><span class="params">            domain: Dict[Text, Any])</span> -&gt; List[Dict[Text, Any]]:</span></span><br><span class="line"></span><br><span class="line">        date_time = tracker.get_slot(<span class="string">"date_time"</span>)</span><br><span class="line">        horoscope_sign = tracker.get_slot(<span class="string">"horoscope_sign"</span>)</span><br><span class="line"></span><br><span class="line">        dispatcher.utter_message(</span><br><span class="line">            text=json_object.get(horoscope_sign, &#123;&#125;) \</span><br><span class="line">                            .get(date_time, <span class="string">"抱歉，我目前无法找到您的运势"</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionDefaultFallback</span><span class="params">(Action)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span> -&gt; Text:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"action_default_fallback"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        dispatcher: CollectingDispatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">        tracker: Tracker,</span></span></span><br><span class="line"><span class="function"><span class="params">        domain: Dict[Text, Any],</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> -&gt; List[Dict[Text, Any]]:</span></span><br><span class="line">        dispatcher.utter_message(text=<span class="string">"我不明白您说的内容，请换个说法。"</span>)</span><br><span class="line">        <span class="keyword">return</span> [UserUtteranceReverted(), ]</span><br></pre></td></tr></table></figure><p>Then, prepare the <strong>config</strong>.<br>The following is what my <strong>config.yml</strong> under project root looks like:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">recipe:</span> <span class="string">default.v1</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh</span></span><br><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SpacyNLP</span></span><br><span class="line">    <span class="attr">model:</span> <span class="string">zh_core_web_lg</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SpacyTokenizer</span></span><br><span class="line">    <span class="attr">intent_tokenization_flag:</span> <span class="literal">False</span></span><br><span class="line">    <span class="attr">intent_split_symbol:</span> <span class="string">"_"</span></span><br><span class="line">    <span class="attr">token_pattern:</span> <span class="string">None</span></span><br><span class="line">  <span class="comment"># - name: WhitespaceTokenizer</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RegexFeaturizer</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LexicalSyntacticFeaturizer</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CountVectorsFeaturizer</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CountVectorsFeaturizer</span></span><br><span class="line">    <span class="attr">analyzer:</span> <span class="string">char_wb</span></span><br><span class="line">    <span class="attr">min_ngram:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">max_ngram:</span> <span class="number">4</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DIETClassifier</span></span><br><span class="line">    <span class="attr">epochs:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">constrain_similarities:</span> <span class="literal">true</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">EntitySynonymMapper</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ResponseSelector</span></span><br><span class="line">    <span class="attr">epochs:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">constrain_similarities:</span> <span class="literal">true</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">FallbackClassifier</span></span><br><span class="line">    <span class="attr">threshold:</span> <span class="number">0.3</span></span><br><span class="line">    <span class="attr">ambiguity_threshold:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">policies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MemoizationPolicy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TEDPolicy</span></span><br><span class="line">    <span class="attr">max_history:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">epochs:</span> <span class="number">200</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RulePolicy</span></span><br><span class="line">    <span class="attr">core_fallback_threshold:</span> <span class="number">0.5</span></span><br><span class="line">    <span class="attr">core_fallback_action_name:</span> <span class="string">action_default_fallback</span></span><br><span class="line">    <span class="attr">enable_fallback_prediction:</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="Training">Training</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rasa train</span><br></pre></td></tr></table></figure><h4 id="Test">Test</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rasa <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>Ok, if everything goes well, we’ve got a simple chatbot out there.</p><h4 id="Run">Run</h4><p>Run an action server.</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rasa <span class="built_in">run</span> actions <span class="comment">--actions actions.actions</span></span><br></pre></td></tr></table></figure><p>Run a shell</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rasa <span class="keyword">shell</span></span><br></pre></td></tr></table></figure><p>Let’s play with it in that shell.</p><p><img src="http://s3.mindex.xyz/blog/HandMades/5f12e717d8eb6d73616a80621a19ef31.png" alt="Test Case"></p><p>Try it out for yourself.</p><h2 id="References">References</h2><ul><li><a href="https://www.amazon.com/Building-Chatbots-Python-Language-Processing/dp/1484240952/" target="_blank" rel="noopener">Building Chatbots with Python</a></li><li><a href="https://www.amazon.cn/dp/B09T353ZJF" target="_blank" rel="noopener">RASA实战</a></li><li><a href="https://github.com/neo1989/chatbot" target="_blank" rel="noopener">chatbot-github</a></li></ul>]]></content>
    
    <summary type="html">
    
      Learn from what you&#39;ve done.
    
    </summary>
    
    
      <category term="HandMades" scheme="https://neo1989.net/categories/HandMades/"/>
    
    
      <category term="NLP" scheme="https://neo1989.net/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>《AI 3.0》</title>
    <link href="https://neo1989.net/Notes/NOTE-AI3.0/"/>
    <id>https://neo1989.net/Notes/NOTE-AI3.0/</id>
    <published>2022-11-01T03:39:11.000Z</published>
    <updated>2023-01-13T03:01:21.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="若想对未来下注，先要厘清人工智能为何仍然无法超越人类智能">若想对未来下注，先要厘清人工智能为何仍然无法超越人类智能</h2><h3 id="智能是个手提箱">智能是个手提箱</h3><p>对于任何谈论人工智能的人来说，定义“人工智能”都是一个挑战。因为人工智能的核型概念——智能，仍然没有明晰的定义。针对蕾丝“智能”及其引申义，如“思想” “认知” “意识” “情感” 这样的词语，明斯基肠燥了 “手提箱式词汇” 这一术语，其意思是：每个词语就像是打包封装了不通含义的手提箱。人工智能就经过了“打包”，在不同的上下文中承担不同的含义。</p><p>大多数人会认同人类是智能的，而尘埃颗粒不是。同样的道理，我们普遍认为人类比虫子更加智能。对于人类智能，智商是在单一尺度上衡量的，但我们也会探讨智能的不同纬度，如情感、语言、空间、逻辑、艺术、社交等。因此，智能的定义可能是二元的（一个物体是或不是智能的）、在一个<a href="https://zh.m.wikipedia.org/zh-hans/%E8%BF%9E%E7%BB%AD%E7%BB%9F" target="_blank" rel="noopener">连续统</a>上（一个物体比另一个物体更智能），或者是多维的（一个人可以具有高语言智能和低情感智能）。确实，“智能”这个词语是一个满载的手提箱，而拉链就在随时可能撑破的边缘上。</p><h3 id="神经网络是现代人工智能的基础">神经网络是现代人工智能的基础</h3><p>20世纪80年代中期，依赖人类创建并反映特定领域专家知识规则的符号人工智能方法——专家系统，越来越暴露出自身的脆弱性：容易出错，且在面对新情况时往往无法进行一般化或适应性的处理。在分析这些系统的局限性时，研究人员发现，便携规则的人类专家实际上或多或少依赖于常识以便明智地行动。这种常识通常难以通过程序化的规则或逻辑推理来获取，而这种常识的缺乏严重限制了符号人工智能方法的广泛应用。简而言之，在经历了过度承诺、巨额的资金支持和媒体炒作的一轮周期之后，符号人工智能又将面临另一个人工智能的寒冬。</p><p>根据联结主义的支持者观点，智能的关键在于构建一个合适的计算结构以及系统从数据或现实世界的行为中进行学习的能力，这是受到了大脑的启发。突然之间，神经网络又流行起来。</p><h3 id="强弱人工智能之争">强弱人工智能之争</h3><p>尽管深度学习近年来取得了很大成功，但和迄今为止所有的人工智能实例一样，这些程序仍然只是所谓的“狭义”或“弱”人工智能的例子。此处的“狭义”和“弱”是用来形容哪些仅能执行一些狭义任务或一组相关任务的系统。AlphaGo可能是世界上最好的围棋玩家，但除此之外什么也做不了，它甚至不会玩跳棋、井字棋等游戏。谷歌翻译可以把英文的影评翻译成中文，但它无法告诉你影评者是否喜欢这部电影，更不用说让它自己来观看和评论电影了。</p><p>“狭义”和“弱”人工智能往往是与“强” “人类水平” “通用” 或 “全面” 人工智能（有时候也称作AGI，即通用人工智能）对比而言的，后者即那种我们在电影中常看到的，可做我们人类所能做的几乎所有的使其，甚至更多事情的智能。通用人工智能是人工智能领域研究最初的目标，但至今还没有创建出任何能够在通用意义上被称为“智能”的人工智能程序。该领域最近的一项研究表明：“一堆狭义智能永远也不会堆砌成一种通用人工智能。通用人工智能的实现不在于单个能力的数量，而在于这些能力间的整合。“</p><h2 id="视觉识别：始终是“看”起来容易“做”起来难">视觉识别：始终是“看”起来容易“做”起来难</h2><h3 id="从大脑识别到ConvNets识别">从大脑识别到ConvNets识别</h3><p><strong>大脑识别模式：</strong> 当人的眼镜聚焦于一个场景是，眼睛接收到的是有场景中的物体发出或其表面反射的不同波长的光，这些光线激活了视网膜上的细胞，本质上说是激活了眼睛后面的一个神经元网格。这些神经元通过位于眼睛后面的纤长的视觉神经来交流彼此的激活信息并将其传入大脑，最终激活位于大脑后部视皮层的神经元。视皮层大致是由一系列按层排列的神经元组成，就像婚礼蛋糕那样一层一层堆在一起，每一层的神经元都将其激活信息传递给下一层的神经元。</p><p><strong>ConvNets识别模式：</strong> C哦女N额头上由一些列模拟神经元组成，在这里，我还是将这些模拟神经元称为单元。每层中的单元为下一层的单元提供输入，当一个ConvNets处理一张图像时，每个单元都有一个特定的激活值——根据单元的输入及其连接权重计算所得的真实的数值。ConvNets的输入是一幅图像，即与图像每个像素的颜色和亮度一一对应的一个数值组。它的最终输出是网络对于每种类别（狗或猫）的置信度（0～100%）。我们的目标是让网络学会对输入图像所属的正确类别输出高置信度，对其他类别输出低置信度。这样，网络将了解输入图像的哪些特征对完成这项任务最有帮助。</p><h3 id="机器视觉智能的3个致命短板">机器视觉智能的3个致命短板</h3><p>如今，机器智能在ImageNet上的目标识别能力是否已经超越人类的争论众说纷纭。这一论断是基于人类的错误率约为5%，而机器的错误率接近2%的一个声明，这难道无法证明计算机在这项任务上的表现比人类更好吗？答案是否定的。</p><p>第一，当你读到“一台机器正确地识别了目标”时，你会认为，给定一张篮球的图像，机器会输出“篮球”这一结果；但在ImageNet竞赛中，正确地识别仅意味着正确类别出现在机器给出的前5个输出类别中。如果给机器输入一张篮球的图像，机器按顺序输出的是门球、比基尼、疣猪、篮球和搬家货车，即可被判定是正确识别。</p><p>第二，对于“人类在ImageNet上的识别错误率为5%”这个声明，其中的“人类”一词实际上表述得并不是非常准确，因为这一结果来自被试只有一个实验。</p><p>第三，当一个人说照片中有一条狗时，我们认为这是因为人类在图像中实际上看到了一条狗，但是如果ConvNets“说”图像中有狗时，也许知识图像中有一些其他对象，如网球、飞盘、被叼住的鞋子，这些对象在训练图像中往往与狗有关，而ConvNets在识别这些对象时就会假设图像中有一条狗。这类关联的结果往往会愚弄程序，使其做出误判。</p><h3 id="难以避免的长尾效应">难以避免的长尾效应</h3><p>知名的深度学习专家本吉奥说：“实事求是地讲，我们不可能对世界上的所有食物都进行标注，并一丝不苟地把每一个细节都解释给计算机听。” 这一情况由于长尾效应的存在而进一步恶化：人工智能系统可能要面临各种可能的意外情况，自动驾驶汽车在一天的行驶期间可能会遇到各种假设情况的可能性可以很好地说明这一现象。遇到红色交通灯或停车标志等都是常见的情况，被评定为具有高可能性；中等可能性的情况包括遇到碎玻璃或者风吹过来的塑料袋；不太常见的情况是自动驾驶汽车遇到了被水淹没的道路或者被雪遮挡住的车道标志，等等。</p><p>“长尾”这个术语来自统计学，其中包含的一长串可能性低，但却可能发生的情况被称为一个概率分布的“尾巴”，尾巴上的情况优势被称为“边缘情况”。人工智能在先是世界的大多数领域中都会面对这种长尾效应；现实世界的大部分时间通常是可预测的，但仍有一长串地概率的意外事件发生。如果我们的单纯依靠监督学习来提升人工智能系统对世界的认知，那么就会存在一个问题：尾部的情况并不经常出现在训练数据中，所以当遇到这些意外情况时，系统就会更容易出错。</p><h3 id="“新机器人三定律”">“新机器人三定律”</h3><ol><li><p>有用的人工智能<br>在考虑人工智能在我们社会中的作用时，我们很容易把注意力集中在不利的一面，但是，有必要记住，人工智能系统已经为社会带来了巨大好处，并且它们有潜力发挥更大的作用。</p></li><li><p>可解释的人工智能<br>在人工智能“自动决策制定”的情况下，任何一个影响公民的决策都需要提供其中所涉及的与逻辑有关的有意义信息，并且这些信息需要使用清晰明了的语言，以简洁、透明、易懂和易于访问的形式来沟通和传达，这打开了有关解释问题的闸门。</p></li><li><p>可信的人工智能<br>在赋予计算机“道德智能”方面的进展不能与其他类型智能的进展分开，真正的挑战是创造出能够真正理解它们所面临的场景的机器。换句话说，可信任的道德理性的一个先决条件时通用的尝试，而这，正如我们所见，即使在当今最好的人工智能系统中也是缺失的。</p></li></ol><h2 id="游戏与推理：开发具有更接近人类水平的学习和推理能力的机器">游戏与推理：开发具有更接近人类水平的学习和推理能力的机器</h2><h3 id="强化学习，让AlphoGo名声大噪的幕后推手">强化学习，让AlphoGo名声大噪的幕后推手</h3><p>在最纯粹的形势下，强化学习不需要任何被标记的训练样本。代替它的是一个智能体，既学习程序，在一种特定环境（通常是计算机仿真环境）中执行一些动作，并偶尔从环境中获得奖励，这些间歇出现的奖励是智能体从学习中获得的唯一反馈。</p><p>强化学习的目标是：让智能体自己学习并获得能对即将到来的奖励进行更好的预测的值，前提是智能体在采取相关行动后一直在做正确的选择。正如我们阿奎那道德，习得给定状态下特定动作的值通常需要经过许多次试错。</p><p>尽管计算机程序可能不会对一个吻或一局热情的“你是最棒的”做出反应，但是它可以被设置为能够对与这种赞美等价的奖励做出响应，比如向机器的内存中添加正数，然后算法会高速机器如何从自己的经验中学习。</p><p>强化学习的实践者几乎都会构建机器人和环境的模拟，然后在模拟世界而非在现实世界中执行所有的学习片段，然而，环境愈复杂和不可预测，讲机器人在模拟中学到的技能转移到现实世界的尝试就愈加难以成功。迄今为止强化学习最大的成功不是在机器人领域，而是在那些能够在计算机上进行完美模拟的领域，特别是游戏领域。</p><h3 id="好的游戏，可以从更好的猜测中学习猜测">好的游戏，可以从更好的猜测中学习猜测</h3><p>如果你是那个学习智能体，当前状态下某个动作是对你在选择某一动作并持续选择高价值动作的条件下，本片段结束后你将获得多少奖励的估计，那么，越接近这一片段的结尾，估值就越准确，因为在一个片段的结尾处，你能计算出你将获得的实际讲理！其中的诀窍是：假设网络在当前迭代的输出比上一次迭代的输出更接近于正确值，然后，通过反向传播学习调整网络权重，从而使得当前与先前迭代输出之间的差异最小化。</p><p>理查德·萨顿是这种方法的鼻祖之一，他把该方法称为：从猜测中学习猜测。我把它修改为：从更好的猜测中学习猜测。简而言之，强化学习不是将其输出与人类给定的标签进行比较，而是假设后续迭代给出的值比前面迭代给出的值更好，网络学习的是使其输出在一次迭代到下一次迭代的过程中保持一致。</p><h3 id="像人一样学会迁移">像人一样学会迁移</h3><p>在机器学习领域，迁移学习是一个充满前景的学习方法，它是指一个程序将其所学的关于一项任务的知识进行迁移，以帮助其获得执行不同的相关任务的能力。对于人类来说，迁移学习是自动进行的，比如，学会打乒乓球之后，我们就能讲其中的一些技巧进行迁移来帮助我们学习打羽毛球和网球；知道如何下西洋跳棋，也有助于我们学习国际象棋。</p><p>人类这种从一种任务到另一种任务的能力迁移看起来好不费劲，我们对所学知识进行泛化的能力正式思考的核心部分。因而，我们可以说，迁移学习的另一种表达就是学习本身。</p><p>与人类形成鲜明对比的是，当今人工智能领域中的大多数学习算法在相关的任务之间是不可迁移的。在这一点上，该领域离哈萨比斯所说的通用人工智能仍然有很远的距离。尽管迁移学习是目前机器学习从业者最活跃的研究领域之一，但这方面的研究仍然处于初级阶段。</p><h2 id="自然语言：让计算机理解它所“阅读”的内容">自然语言：让计算机理解它所“阅读”的内容</h2><h3 id="理解语言，理解我们赖以生存的隐喻">理解语言，理解我们赖以生存的隐喻</h3><p>理解语言，特别是理解其中隐含的部分，是人类智能的一个基本部分。图灵把他著名的图灵测试，构造为一场关于语言之生成和理解的比赛，这决非偶然。</p><p>语言常常是充满歧义的，极度依赖语境，而且通常语言沟通的各方需要具备大量共同的背景知识。与人工智能的其他领域一样，自然语言处理相关的研究在最初的几十年集中在符号化的、基于规则的方法上，就是那种给定语法和其他语言规则，并把这些规则应用到输入语句上的方法。这些方法并没有取得很好的效果，看来通过使用一组明确的规则来捕捉语言的微妙是行不通的。自动语音识别是深度学习在自然语言处理中的第一个重大成就，并且我敢说，这是迄今为止人工智能在所有领域中取得的最重要的成就。</p><p>在深度网络开始在计算机视觉和语音识别上“得心应手”后不久，自然语言处理的研究者就开始试着把它们应用于情感分析。</p><h3 id="破解机器翻译，攀登人工智能的天梯">破解机器翻译，攀登人工智能的天梯</h3><p>在线翻译系统可以为人们提供全天候的即时翻译服务，而且通常可以处理100多种不同的语言，但是，其水平仍然远低于优秀的人类翻译员。</p><p>机器翻译的原始方法依赖于人类制定规则的复杂集合，所以，它们相当脆弱，需要面对来自自然语言处理领域所面临的所有挑战。</p><p>从20世纪90年代开始，一种被称为“统计机器翻译”的新方法开始占据主导地位，此方法依赖于从数据而非从人类制定的规则中学习。</p><p>谷歌翻译可能是目前最为广泛使用的自动翻译程序，使用的是一种更加优越的基于深度学习的翻译方法，也就是神经机器翻译。</p><p>深度学习时代的机器翻译所取得的巨大成功是由大数据和快速计算造就的，但这种成功完全是基于对单个句子翻译水平的评估，而非篇幅更长的文章。</p><h3 id="阅读理解的关键不仅在于“提取答案”，还在于“具备常识”">阅读理解的关键不仅在于“提取答案”，还在于“具备常识”</h3><p>《星际迷航》或许给我们许多人都编织了一个梦想：能够向计算机询问任何事情，并且它可以做出准确、简洁和有用的回应。如果你使用过当今任意一款人工智能语音助手，如Siri、Alexa、Cortana、Google Now，你就会知道这个梦想还尚未实现——这些系统并不能理解我们所问的问题的含义。</p><p>虽然计算机目前已经可以准确地转述我们的请求，但我们的终极目标是：让计算机真正理解我们所问的问题的含义。这本质上是一种阅读理解任务，但目前计算机其实并不能完全读懂一个特定文本中字里行间的意思，也无法做到真正的推理，比起阅读理解，计算机能做到的应该叫做“答案提取”。答案提取对机器来说是一项有用的技能，事实上，答案提取也正是Alexa、Siri以及其他数字助理软件所需要做的：将接收道德问题转换为一个搜索引擎查询序列，然后从搜索结果中提取答案。</p><p>“提问-回答”的话题一直是自然语言处理研究的一个重点。若想正确回答这些问题，不仅需要答案提取的技能，还需要具备自然语言处理和常识推理的集成能力，以及一些必要的背景知识。尽管深度学习已近在语音识别、语言翻译、情感分析及自然语言处理的其他领域取得了一些非常显著的进展，但人类水平的语言处理能力仍然是一个遥远的目标。</p><h2 id="常识——人工智能打破意义障碍的关键">常识——人工智能打破意义障碍的关键</h2><h3 id="理解力是一种预测力，而预测力与我们的经历息息相关">理解力是一种预测力，而预测力与我们的经历息息相关</h3><p>我们都拥有心理学家所说的关于世界的重要方面的“心智模型”，这个模型基于的是我们掌握的物理学和生物学上的事实、因果关系和人类行为的知识，并揭示了世界是如何运作的。心智模型不仅能够使你预测在特定情况下可能会发生什么，还能让你想象如果特定事件发生将会引发什么。</p><p>我们通过核心物理知识来理解抽象概念。如果物理意义上的“温暖”概念在心理上被激活，例如，通过手持一杯热咖啡，这也会激活更抽象、隐喻层面上的“温暖”概念。如果我们对概念和情境的理解是使用心智模型来进行模拟的，那么，也许意识以及我们对自我的全部概念，都来自我们构建并模拟自己的心智模型的能力。</p><p>我们拥有的与物理感觉相关的概念可能会激活关于自我的抽象概念，后者通过神经系统的反馈，产生一种对自我的物理感知，你也可以将这里的“自我”称为意识。这种循环因果关系类似侯世达所说的意识的“怪圈”：“符号和物理层面相互作用，并颠倒了因果关系，符号似乎拥有了自由意志，并获得了推动例子运动的自相矛盾的能力。” 我们所谓的感知、分类、识别、泛化和联想都涉及我们对所经历过的情境进行抽象的行为。</p><h3 id="我们是否可以为机器赋予常识">我们是否可以为机器赋予常识</h3><p>在人工智能发展的早期阶段，机器学习和神经网络还尚未在该领域占主导地位，那时候，人工智能研究人员还在人工地对程序执行任务所需要的规则和知识编码，对他们来说，通过“内在构建”的方法来捕捉足够的人类常识以在机器中实现人类水平的只能，看起来是完全合理的。</p><p>当深度学习开始展示其一系列非凡的成功时，不管是人工智能领域的内行还是外行，大家都乐观地认为我们即将实现通用的、人类水平的人工智能了。然而，正如本书中反复强调的那样，随着深度学习系统的应用愈加广泛，其智能正逐渐露出“破绽”。即便是最成功的系统，也无法在其狭窄的专业领域之外进行良好的泛化、形成抽象概念或者学会因果关系。此外，它们经常会犯一些不像是人类会犯的错误，以及在对抗样本上表现出的脆弱性都表明：它们并不真正理解我们教给它们的概念。</p><p>要想令人工智能实现真正的进步，就需要让及其具备常识，但是，很多处于我们潜意识里的知识，我们甚至不知道自己拥有这些知识，或者说常识，却是我们人类所共有的，而且是在任何地方都没有记载的知识。这包括我们在物理学、生物学和心理学上的许多核心直觉知识，这些知识是所有我们关于世界的更广泛的知识的基础。如果你没有有意识地认识到自己知道什么，你就不能成为向一台计算机明确地提供这些知识的专家。</p><h2 id="思考6个关键问题，激发人工智能的终极潜力">思考6个关键问题，激发人工智能的终极潜力</h2><ol><li>自动驾驶汽车还要多久才能普及？</li><li>人工智能会导致人类大规模失业吗？</li><li>计算机能够具有创造性吗？</li><li>我们距离创建通用的人类水平AI还有多远？</li><li>我们应该对人工智能感到多恐惧？</li><li>人工智能中有哪些激动人心的问题还尚未解决？</li></ol><h2 id="Reference">Reference</h2><p>[1] <a href="https://book.douban.com/subject/35351678/" target="_blank" rel="noopener">AI 3.0</a></p>]]></content>
    
    <summary type="html">
    
      “现在的人工智能可以做什么，以及在未来几十年我们能从它们身上期待什么”。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的记忆法</title>
    <link href="https://neo1989.net/CheatSheet/CHEATSHEET-memorization-techniques/"/>
    <id>https://neo1989.net/CheatSheet/CHEATSHEET-memorization-techniques/</id>
    <published>2022-09-23T06:56:52.000Z</published>
    <updated>2023-01-06T08:06:00.132Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">记忆法</th><th style="text-align:center">概述</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">反复出声读</td><td style="text-align:center">反复出声读自己想记的内容</td><td style="text-align:center">无须准备，简单易行</td><td style="text-align:center">过程中一旦出错，就会不小心把错误的内容给记下来。单单使用这种方法无法确定自己究竟有没有记住</td></tr><tr><td style="text-align:center">反复抄写</td><td style="text-align:center">反复抄写自己想记的内容</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">反复读同时抄写</td><td style="text-align:center">上述两种方法的结合</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">留出时间来复习</td><td style="text-align:center">确认一下自己之前记忆的是否牢固</td><td style="text-align:center">防止“一旦记住就再也不管了”的情况</td><td style="text-align:center">很容易忘记去复习</td></tr><tr><td style="text-align:center">记忆唤起</td><td style="text-align:center">遮住正确答案，努力会想，然后立刻确认自己的回答是否正确。多次重复这一过程。单词卡就是该方法的一种应用</td><td style="text-align:center">一旦记忆出现偏差，可以立刻修正。不会出现“自以为记住了但是其实没记住”的情况</td><td style="text-align:center">很难用来记忆那些无法一次性处理的信息，例如比较长的单词和文章</td></tr><tr><td style="text-align:center">SAFMEDS法</td><td style="text-align:center">全称为 Say All Fast Minute EveryDay Suffle，把问题卸载卡片的正面，答案写在卡片的背面，没图打乱卡片顺序后，在一分钟內用最快的速度回答卡片上的问题，并记录自己答对的题数，制作成图表</td><td style="text-align:center">能够一眼看出自己记住了多少内容，有助于提升积极性</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">间隔复习法</td><td style="text-align:center">逐渐拉长复习的间隔</td><td style="text-align:center">比单纯的复习记忆的更牢固</td><td style="text-align:center">需要安排并且记住复习的时间点，比较麻烦</td></tr><tr><td style="text-align:center">DWM(Day-Week-Month)法</td><td style="text-align:center">复习一天前、一周前和一个月前记忆过的内容</td><td style="text-align:center">复习的时间点更好记</td><td style="text-align:center">需要想一想一个月后的复习要如何安排</td></tr><tr><td style="text-align:center">35分钟模拟法</td><td style="text-align:center">以35分钟为一个模块，结合DWM法来复习</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">SRS笔记</td><td style="text-align:center">用一个笔记本来管理间隔复习的时间点和想要记忆的内容</td><td style="text-align:center">同上</td><td style="text-align:center">随着想要记忆的内容不断增加，笔记本会变得越来越厚</td></tr><tr><td style="text-align:center">SRS软件</td><td style="text-align:center">使用Anki、Logseq等SRS软件来记忆</td><td style="text-align:center">App会自动帮我们设定时间，且不会变厚</td><td style="text-align:center">需要电脑或手机</td></tr><tr><td style="text-align:center">短间隔复述法</td><td style="text-align:center">听到或看到想要记忆的内容，反复出声复述，并逐渐拉长复述的间隔时间</td><td style="text-align:center">无须准备，简单易行</td><td style="text-align:center">过程中一旦出错，就会不小心把错误的内容给记下来。单单使用这种方法无法确定自己究竟有没有记住</td></tr><tr><td style="text-align:center">自我测试法</td><td style="text-align:center">自己出一份试卷，然后自己作答</td><td style="text-align:center">一旦记忆出现偏差，可以立刻修正。不会出现“自以为记住了但是其实没记住”的情况</td><td style="text-align:center">出试卷很费功夫</td></tr><tr><td style="text-align:center">反复答题法</td><td style="text-align:center">反复回答简单的问题，达到记忆的目的</td><td style="text-align:center">能够发现自己记错或是记忆不准确的部分，及时修正。适合用力啊提高记忆的精确性和回想的速度</td><td style="text-align:center">容易厌烦。正确率提升后会逐渐失去动力</td></tr><tr><td style="text-align:center">LowFirst</td><td style="text-align:center">按照错误率从高到低的顺序来复习。剔除低错误率的项目以提高复习效率</td><td style="text-align:center">比间隔复习法的效率高</td><td style="text-align:center">计算错误率，安排复习时间的过程比较麻烦</td></tr><tr><td style="text-align:center">影像记忆法</td><td style="text-align:center">在脑中将想记的内容转换成影像来记忆</td><td style="text-align:center">记忆会更容易在脑内扎根</td><td style="text-align:center">不一定适合所有人。对于不熟练的人来说，想象的过程可能会很费时间</td></tr><tr><td style="text-align:center">联想记忆法</td><td style="text-align:center">想一想自己看到这些内容后首先联想到了什么，将二者联系起来记忆</td><td style="text-align:center">利用自己脑内产生的联想来记忆，会更容易一些</td><td style="text-align:center">不一定适合所有人。对于不熟练的人来说，联想的过程可能会很费时间</td></tr><tr><td style="text-align:center">谐音记忆法</td><td style="text-align:center">把想记的内容换成其他发音相似的字，变成不通的意思</td><td style="text-align:center">在记忆数字时使用这种方式，会比直接记忆更有效</td><td style="text-align:center">想谐音会比较麻烦</td></tr><tr><td style="text-align:center">关键词记忆法</td><td style="text-align:center">找到母语中发音比较相似的词，在想象中将二者联系起来</td><td style="text-align:center">在记忆数字和外语单词时是用这种方式，会比直接记忆更有效</td><td style="text-align:center">有时很难从母语中找到发音相似的词</td></tr><tr><td style="text-align:center">利用韵律来记忆</td><td style="text-align:center">-</td><td style="text-align:center">在记忆数字和外语单词时是用这种方式，会比直接记忆更有效</td><td style="text-align:center">对押韵不熟悉的人很难应用</td></tr><tr><td style="text-align:center">自我关联记忆法</td><td style="text-align:center">把想记的内容写到一篇与自己相关的文章中</td><td style="text-align:center">与自己相关的事物记忆起来会更容易</td><td style="text-align:center">写文章比较麻烦</td></tr><tr><td style="text-align:center">故事记忆法</td><td style="text-align:center">把想记的内容编成一个故事</td><td style="text-align:center">故事记忆起来会更容易一些</td><td style="text-align:center">编故事比较麻烦</td></tr><tr><td style="text-align:center">歌词记忆法</td><td style="text-align:center">把想记的内容编成一首歌</td><td style="text-align:center">伴随着旋律去记忆，印象会更深刻</td><td style="text-align:center">编歌词和旋律的过程比较麻烦</td></tr><tr><td style="text-align:center">首字母记忆法</td><td style="text-align:center">把想记的内容的首字母提取出来，串联成一个单词</td><td style="text-align:center">更好记一些，回想起来也更容易</td><td style="text-align:center">首字母组成的新单词有时候会很难拼写</td></tr><tr><td style="text-align:center">记忆桩</td><td style="text-align:center">把已知的事物（记忆桩）和想记的内容在想象中联系起来</td><td style="text-align:center">更好记一些，回想起来也更容易</td><td style="text-align:center">刚开始还不熟练的适合，这个想象的过程会花费不少时间</td></tr><tr><td style="text-align:center">系统化记忆法</td><td style="text-align:center">通过重新归纳整理来记忆</td><td style="text-align:center">经过处理的信息很难忘记，还易于应用</td><td style="text-align:center">由于需要先理解，所以比较花时间</td></tr><tr><td style="text-align:center">类推记忆法</td><td style="text-align:center">通过上下文推测单词的意思，从而达到记忆的目的</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">记忆树</td><td style="text-align:center">以记忆的主题为树干，将相关的内容写到枝叶的位置上</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">凝缩笔记法</td><td style="text-align:center">像打小抄一样，把考试范围內的活字典全部都总结到一张小纸片上</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">康奈尔笔记法</td><td style="text-align:center">把笔记本上的一页分成三栏（正文、标题-评论、摘要），利用评论和摘要来复习</td><td style="text-align:center">同上，加入了复习机制，十分有效</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">互测法</td><td style="text-align:center">两个人分别出一份试卷，然后交换作答</td><td style="text-align:center">比自测法更高效</td><td style="text-align:center">需要一个学习伙伴</td></tr><tr><td style="text-align:center">交互式教学</td><td style="text-align:center">两个人一遍对话，一边使用预测、提问、总结和析疑四种策略来理解文章</td><td style="text-align:center">经过处理的信息很难忘记，还易于应用。在社会性相互作用下，使用过的信息会记得更牢固一些</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">情感关联法</td><td style="text-align:center">将内容与情感联系起来记忆</td><td style="text-align:center">情感越是强烈，与之相关的记忆就越牢固</td><td style="text-align:center">激发感情是一件难事</td></tr><tr><td style="text-align:center">情景记忆法</td><td style="text-align:center">将能够用到这些内容的场景还原出来，在场景下记忆</td><td style="text-align:center">还原的场景与实际场景越相似，回忆起来就越容易</td><td style="text-align:center">如果还原不出相似的场景，那就能难使用这个方法</td></tr><tr><td style="text-align:center">早期学习状态重置法</td><td style="text-align:center">回想第一次学汉子、骑自行车、背乘法口诀时的场景，将自己还原到当时的状态中</td><td style="text-align:center">这样能够重拾记忆力旺盛的心理状态</td><td style="text-align:center">效果具体如何尚不明确</td></tr><tr><td style="text-align:center">极端状态法</td><td style="text-align:center">把自己放到一种极端的状态下</td><td style="text-align:center">当自己所拥有的只是在新的环境完全派不上用场时，为了能够生存，学习效率会大幅提升</td><td style="text-align:center">可能对注意力的集中有危害</td></tr><tr><td style="text-align:center">张贴记忆法</td><td style="text-align:center">把想记的内容贴在自己平时经常会看到的地方</td><td style="text-align:center">把记忆需要付出的努力最小化</td><td style="text-align:center">效率不高，需要做一定的准备</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      理解是最棒的记忆法
    
    </summary>
    
    
      <category term="CheatSheet" scheme="https://neo1989.net/categories/CheatSheet/"/>
    
    
      <category term="SoftSkills" scheme="https://neo1989.net/tags/SoftSkills/"/>
    
  </entry>
  
  <entry>
    <title>Golang小记</title>
    <link href="https://neo1989.net/Notes/NOTE-key-points-for-mastering-golang/"/>
    <id>https://neo1989.net/Notes/NOTE-key-points-for-mastering-golang/</id>
    <published>2022-02-28T08:31:59.000Z</published>
    <updated>2023-03-01T10:50:20.672Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Go的设计哲学">Go的设计哲学</h3><p>Go在语言层面的简单让Go收货了不逊于C++/Java等的表现力的同时，还获得了更好的可读性、更高的开发效率等在软件工程领域更为重要的元素。<br>“高内聚、低耦合”。Go崇尚通过组合的方式将正交的语法元素组这在一起来形成应用程序骨架，接口就是在这一哲学下诞生的语言精华。<br>Go语言提供了内置于语言中的简单并发原语——go（goroutine）、channel和select，大幅降低了开发人员在云计算多核时代编写大规模并发网络服务程序时的心智负担。</p><p>Go工具链:</p><pre><code>构建和运行：go build / go run依赖包查看与获取：go list / go get / go mod xx编辑辅助格式化：go fmt / gofmt文档查看：go doc / godoc单元测试/基准测试/测试覆盖率：go test代码静态分析：go vet性能剖析与跟踪结果查看：go tool pprof / go tool trace升级到新Go版本API的辅助工具：go tool fix报告Go语言bug：go bug</code></pre><h3 id="使用Go命名惯例对标识符进行命名">使用Go命名惯例对标识符进行命名</h3><p>Go语言追求简单一致且利用上下文辅助名字信息传达的命名惯例。</p><h3 id="使用一致的变量的声明形式">使用一致的变量的声明形式</h3><p>如图示，要想做好代码中变量声明的一致性，需要明确要声明的变量是包级变量还是局部变量、是否要延迟初始化、是否接受默认类型、是否为分支控制变量，并结合聚类和就近原则。</p><p><img src="//s3.mindex.xyz/blog/Notes/61917c13d1270327ea4531de658f8058.png" alt="变量声明形式使用决策流程图"></p><h3 id="使用无类型常量简化代码">使用无类型常量简化代码</h3><p>所有常量表达式的求值计算都可以在编译期而不是在运行期完成，这样既可以减少运行时的工作，也能方便编译器进行编译优化。当操作数是常量时，在编译时也能发现一些运行时的错误，例如整数除零、字符串索引越界等。<br>无类型常量是Go语言推荐的实践，它拥有和字面值一样的零或特性，可以直接用于更多的表达式而不需要进行显示类型转换，从而简化了代码编写。此外，按照<a href="https://go.dev/ref/spec" target="_blank" rel="noopener">Go官方语言规范</a>的描述，数值型无类型常量可以提供比基础类型更高精度的算术运算，至少有256bit的运算精度。</p><h3 id="使用iota实现枚举常量">使用iota实现枚举常量</h3><h3 id="尽量定义零值可用的类型">尽量定义零值可用的类型</h3><p>Go语言零值可用的理念给内置类型、标准库的使用者带来很多遍历。不过Go并非所有类型都零值可用的，并且零值可用也有一定的限制，比如：</p><p>在append场景下，零值可用的切片类型不能通过下标形式操作数据:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="keyword">int</span></span><br><span class="line">s[<span class="number">0</span>] = <span class="number">12</span>           <span class="comment">// 报错！</span></span><br><span class="line">s = <span class="built_in">append</span>(s, <span class="number">12</span>)   <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>另外，像map这样的原生类型也没有提供对零值可用的支持：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span></span><br><span class="line">m[<span class="string">"go"</span>] = <span class="number">1</span>         <span class="comment">// 报错！</span></span><br><span class="line"></span><br><span class="line">m1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">int</span>)</span><br><span class="line">m1[<span class="string">"go"</span>] = <span class="number">1</span>        <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>另外零值可用的类型要注意尽量避免值复制：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">mu1 := mu       <span class="comment">// 错误：避免值复制</span></span><br><span class="line">foo(mu)         <span class="comment">// 错误：避免值复制</span></span><br></pre></td></tr></table></figure><p>我们可以通过指针方式传递类似Mutex这样的类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.Mutex</span><br><span class="line">foo(&amp;mu)        <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure><p>保持与Go一致的理念，给自定义的类型一个合理的零值，并尽量保持自定义类型的零值可用，这样我们的Go代码会更加复合Go语言的惯用法。</p><h3 id="使用复合字面值作为初值构造器">使用复合字面值作为初值构造器</h3><p>对于零值不适用的场景，我们要为变量赋予一定的初值。对于复合类型，我们应该首选Go提供的复合字面值作为初值构造器。对于不同复合类型，我们要记住下面几点：</p><ul><li>使用field: value 形式的复合字面值为结构体类型的变量赋初值。</li><li>在为稀疏元素赋值或让编译器推导数组大小的时候，多使用index: value的形式为数组/切片类型变量赋初值。</li><li>使用key: value形式的复合字面值为map类型的变量赋初值。（Go 1.5版本后，复合字面值中的key和value类型均可以省略不写。）</li></ul><h3 id="了解切片实现原理并高效使用">了解切片实现原理并高效使用</h3><p>切片是数组的描述符，在大多数场合替代了数组，并减少了数组指针作为函数参数的使用。<br>append在切片上的运用让切片类型部分支持了“零值可用”的理念，并且append对切片的动态扩容将Gopher从手工管理底层存储的工作中解放出来。<br>在可以预估初元素容量的前提下，使用cap参数创建切片可以提升append的平均操作性能，减少或消除因动态扩容带来的性能损耗。</p><h3 id="了解map实现原理并高效使用">了解map实现原理并高效使用</h3><ul><li>不要依赖map的元素遍历顺序</li><li>map不是线程安全的，不支持并发写</li><li>不要尝试获取map中元素（value）的地址</li><li>尽量使用cap参数创建map，以提升map平均访问性能，减少频繁扩容带来的不必要损耗</li></ul><h3 id="了解string实现原理并高效使用">了解string实现原理并高效使用</h3><p>Go语言内置了string类型，统一了对字符串的抽象，并且为string类型提供提供了强大的内置操作支持，包括基于<code>+/+=</code>的字符串连接操作，基于<code>==、!=、&gt;、&lt;</code>等的比较操作，O(1)复杂度的长度获取操作，对非ASCII字符提供原生支持，对string类型与slice类型的相互转换提供优化等。<br>此外，Go语言还在标准库中提供了strings和strconv包，可以辅助Gopher对string类型数据进行更多高级操作。</p><h3 id="理解Go语言的包导入">理解Go语言的包导入</h3><ul><li>Go编译器在编译过程种必然要使用的是编译单元（一个包）所依赖的包的源码</li><li>Go源码文件头部的包导入语句中import后面的部分是一个路径，路径的最后一个分段是目录名，而不是包名。</li><li>Go编译器的包源码搜索路径由基本搜索路径和包导入路径组成，两者结合在一起后，编译器便可确定一个包的所有依赖包的源码路径的集合，这个集合构成了Go编译器的源码搜索路径空间。</li><li>同一源码文件的依赖包在同一源码搜索路径空间下的包名冲突问题可以由显示指定包名的方式解决。</li></ul><h3 id="理解Go语言表达式的求值顺序">理解Go语言表达式的求值顺序</h3><ul><li>包级别变量声明语句中的表达式求值顺序由变量的声明顺序和初始化依赖关系决定，并且包级变量表达式求值顺序优先级最高。</li><li>表达式操作数中的函数、方法及channel操作按普通求值顺序，即从左到右的次序进行求值。</li><li>赋值语句求值分为两个阶段：先按照普通求值规则对等号左边的下标表达式、指针解引用表达式和等号右边的表达式中的操作数进行求值，然后按从左到右的顺序对变量进行赋值。</li><li>重点关注switch-case和select-case语句中的表达式“惰性求值”规则。</li></ul><h3 id="理解Go语言代码块与作用域">理解Go语言代码块与作用域</h3><h3 id="了解Go语言控制语句惯用法及使用注意事项">了解Go语言控制语句惯用法及使用注意事项</h3><ul><li>使用if语句时遵循“快乐路径”原则</li><li>小心for range的循环变量重用，明确真实参与循环的是range表达式的副本</li><li>明确break和continue执行后的真实“目的地”</li><li>使用fallthrough关键字前，考虑能否用简洁、清晰的case表达式列表替代</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">"快乐路径"</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    当出现错误时，快速返回</span></span><br><span class="line"><span class="comment">    成功逻辑不要嵌入if-else语句中</span></span><br><span class="line"><span class="comment">    “快乐路径”的执行逻辑在代码布局上始终靠左，这样读者可以一眼看到该函数的正常逻辑流程</span></span><br><span class="line"><span class="comment">    “快乐路径”的返回值一般在函数最后一行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// "快乐路径"伪代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">do</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> errorCond1 &#123;</span><br><span class="line">        <span class="comment">// 错误逻辑</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> err1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成功逻辑</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> errorCond2 &#123;</span><br><span class="line">        <span class="comment">// 错误逻辑</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> err2</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成功逻辑</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在init函数中检查包级变量">在init函数中检查包级变量</h3><ul><li>init函数有几个特点：运行时调用、顺序、仅执行一次</li><li>init函数是包出厂前的唯一“质检员”</li><li>记住Go程序的初始化顺序<br><img src="//s3.mindex.xyz/blog/Notes/c9aa6b692a70d019fe7ced19e982ec1d.png" alt="Go程序初始化顺序"></li></ul><h3 id="让自己习惯于函数是“一等公民”">让自己习惯于函数是“一等公民”</h3><ul><li>Go函数可以像变量值那样被赋值给变量、作为参数传递、作为返回值返回和在函数内部创建等</li><li>函数可以像变量那样被显示类型转换</li><li>基于函数特质，了解Go中的几种有用的函数式编程风格，如<a href="https://zh.wikipedia.org/zh/%E6%9F%AF%E9%87%8C%E5%8C%96" target="_blank" rel="noopener">柯里化</a>、函子等</li><li>不要为了复合特定风格而滥用函数特质</li></ul><h3 id="使用defer让函数更简洁、更健壮">使用defer让函数更简洁、更健壮</h3><ul><li>理解defer的运作机制，即deferred函数注册与调度执行</li><li>了解defer的常见用法</li><li>了解关于defer使用的几个关键问题，避免入“坑”</li></ul><h3 id="理解方法的本质以选择正确的receiver类型">理解方法的本质以选择正确的receiver类型</h3><ul><li>Go方法的本质：一个以方法所绑定类型实例为第一个参数的普通函数。。</li><li>Go语法糖使得我们在通过类型实例调用类型方法时无须考虑实例类型与receiver参数类型是否一致，编译器会为我们做自动转换。</li><li>在选择receiver参数类型时要看是否要对类型实例进行修改。如有修改需求，则选择<code>*T</code>；如无修改需求，T类型receiver传值的性能损耗也是考量因素之一。</li></ul><h3 id="方法集合决定接口实现">方法集合决定接口实现</h3><ul><li>方法集合是类型与接口间隐式关系的纽带，只有当类型的方法集合是某接口类型的超集时，我们才说类型实现了某接口</li><li>类型T的方法集合是以T为receiver类型的所有方法的集合，类型<code>*T</code>的方法集合是以<code>*T</code>为receiver类型的所有方法的集合与类型T的方法集合的并集</li><li>了解类型嵌入对接口类型和自定义结构体类型的方法集合的影响</li><li>基于接口类型创建的defined类型与原类型具有相同的方法集合，而基于自定义非接口类型创建的defined类型的方法集合为空</li><li>类型别名与原类型拥有完全相同的方法集合</li></ul><h3 id="了解变长参数函数的妙用">了解变长参数函数的妙用</h3><ul><li>了解变长参数函数的特点和约束</li><li>变长参数可以在有限情况下模拟函数重载、可选参数和默认参数，但要谨慎使用，不要造成混淆</li><li>利用变长参数函数实现功能选项模式</li></ul><h3 id="了解接口类型变量的内部表示">了解接口类型变量的内部表示</h3><ul><li>接口类型变量在运行时表示为eface和iface，eface用于表示空接口类型变量，iface用于表示非空接口类型变量</li><li>当且仅当两个接口类型变量的类型信息（eface.__type / iface.tab.__type）相同，同数据指针（eface.data / iface.data）所指数据相同时，两个接口类型才是相等的</li><li>通过println可以输出接口类型变量的两部分指针变量的值</li><li>可通过复制runtime包eface和iface相关类型源码，自定义输出eface/iface详尽信息的函数</li><li>接口类型变量的装箱操作由Go编译器和运行时共同完成</li></ul><h3 id="尽量定义小接口">尽量定义小接口</h3><ul><li>接口是将对象的行为进行抽象而形成的契约</li><li>Go青睐定义小接口，即方法数量为1~3个、通常为1个的接口 (<a href="//github.com/bigwhite/itfmc" target="_blank" rel="noopener">接口方法数量统计工具</a>)</li><li>小接口抽象程度高，被接纳度高，易于实现和测试，易于复用组合</li><li>先抽象出接口，再拆分为小接口，另外接口的契约职责应尽可能保持单一</li></ul><h3 id="尽量避免使用空接口作为函数参数类型">尽量避免使用空接口作为函数参数类型</h3><h3 id="使用接口作为程序水平组合的连接点">使用接口作为程序水平组合的连接点</h3><ul><li>深入理解Go的组合设计哲学</li><li>垂直组合可实现方法实现和接口定义的重用</li><li>掌握使用接口作为程序水平组合的连接点的几种形式</li></ul><h3 id="使用接口提高代码的可测试性">使用接口提高代码的可测试性</h3><p>适当抽取接口，让接口成为好代码与单元测试之间的桥梁是Go语言的一种最佳实践。</p><h3 id="优先考虑并发设计">优先考虑并发设计</h3><p>并发在程序的设计和实现阶段，并行在程序的执行阶段。</p><h3 id="了解goroutine的调度原理">了解goroutine的调度原理</h3><ul><li>了解goroutine调度器要解决的主要问题</li><li>了解gorutine调度器的调度模型演进</li><li>掌握goroutine调度器当前G-P-M调度模型的运行原理</li><li>掌握gorutine调度器状态查看方法</li><li>学习goroutine调度实例分析方法</li></ul><h3 id="掌握Go并发模型和常见并发模式">掌握Go并发模型和常见并发模式</h3><ul><li>了解基于CSP的并发模型与传统基于共享内存的并发模型的区别</li><li>了解Go为实现CSP模型而提供的并发原语及功能</li><li>掌握常见的并发模型，包括创建模式、多种退出模式、管道模式、超时和取消模式等</li></ul><h3 id="了解channel的妙用">了解channel的妙用</h3><ul><li>了解Go并发原语channel和select的基本语义</li><li>掌握无缓冲channel在信息传递、替代锁同步场景下的应用模式</li><li>掌握带缓冲channel在消息队列、计数信号量场景下的应用模式，了解在特定场景下利用len函数侦测带缓冲channel的状态</li><li>了解nil channel在特定场景下的用途</li><li>掌握select与channel结合使用的一些惯用法及注意事项</li></ul><h3 id="了解sync包的正确用法">了解sync包的正确用法</h3><ul><li>明确sync包中原语应用的适用场景</li><li>sync包内定义的结构体或包含这些类型的结构体在首次使用后禁止复制</li><li>明确sync.RWMutex的使用场景</li><li>掌握条件变量的应用场景和使用方法</li><li>实现单利模式时优先考虑sync.Once</li><li>了解sync.Pool的优点，使用中可能遇到的问题及解决方法</li></ul><h3 id="使用atomic包实现伸缩性更好的并发读取">使用atomic包实现伸缩性更好的并发读取</h3><p>随着并发量提升，使用atomic实现的共享变量的并发读写性能表现更为稳定，尤其是原子读操作，这让atomic与sync包中的原语比起来表现出更好的伸缩性和更高的性能。<br>atomic包更适合一些对性能十分敏感、并发量较大且读多写少的场合。<br>但atomic原子操作可用来同步的范围有较大限制，仅是一个整型变量或自定义类型变量。如果要对一个复杂的临界区数据进行同步，那么首选依旧是sync包中的原语。</p><h3 id="了解错误处理的4种策略">了解错误处理的4种策略</h3><ul><li>尽量使用透明错误处理策略降低错误处理方与错误值构造方之间的耦合</li><li>如果可以通过错误值类型的特征进行错误检视，那么尽量使用错误行为特征检视策略</li><li>在上述两种策略无法实施的情况下，再用“哨兵”策略和错误值类型检视策略</li><li>在Go1.13及后续版本中，尽量用errors.Is和errors.As方法替换原先的错误检视比较语句</li></ul><h3 id="尽量优化反复出现的-if-err-nil">尽量优化反复出现的 <code>if err != nil</code></h3><ul><li>使用显示错误结果和显示的错误检查是Go语言成功的重要因素，也是<code>if err != nil</code>反复出现的根本原因</li><li>了解关于改善Go错误处理的两种观点</li><li>了解减少甚至消除<code>if err != nil</code>代码片段的两个优化方向，即改善视觉呈现与降低复杂度</li><li>掌握错误处理代码优化的四种常见方法，并根据所处场景与约束灵活使用</li></ul><h3 id="不要使用panic进行正常的错误处理">不要使用<code>panic</code>进行正常的错误处理</h3><ul><li>深入理解不要使用panic进行正常错误处理的原因</li><li>Go标准库中panic的常见使用场景</li><li>理解程序发生panic时输出的栈帧信息有助于快速定位bug，找出“元凶”</li></ul><h3 id="理解包内测试与包外测试的差别">理解包内测试与包外测试的差别</h3><h3 id="有层次地组织测试代码">有层次地组织测试代码</h3><h3 id="优先编写表驱动的测试">优先编写表驱动的测试</h3><h3 id="使用testdata管理测试依赖的外部数据文件">使用testdata管理测试依赖的外部数据文件</h3><h3 id="正确运用fake、stub和mock等辅助单元测试">正确运用fake、stub和mock等辅助单元测试</h3><h3 id="使用模糊测试让潜在bug无处遁形">使用模糊测试让潜在bug无处遁形</h3><h3 id="为被测对象建立性能基准">为被测对象建立性能基准</h3><h3 id="使用pprof对程序进行性能剖析">使用pprof对程序进行性能剖析</h3><h3 id="使用expvar输出度量数据，辅助定位性能瓶颈点">使用expvar输出度量数据，辅助定位性能瓶颈点</h3><h3 id="使用Delve调试Go代码">使用Delve调试Go代码</h3><h3 id="Reference">Reference</h3><p><a href="https://www.amazon.cn/dp/B09P57NF34" target="_blank" rel="noopener">Go语言精进1</a><br><a href="https://www.amazon.cn/dp/B09P58GCD6" target="_blank" rel="noopener">Go语言精进2</a></p>]]></content>
    
    <summary type="html">
    
      “只要学不死，就往死里学。”
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
  </entry>
  
  <entry>
    <title>《软件架构师的12项修炼》</title>
    <link href="https://neo1989.net/Notes/NOTE-12-more-essential-skills-for-software-architects/"/>
    <id>https://neo1989.net/Notes/NOTE-12-more-essential-skills-for-software-architects/</id>
    <published>2022-02-08T08:32:37.000Z</published>
    <updated>2023-01-13T02:59:38.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Project-Skills">Project Skills</h2><h3 id="Partnership">Partnership</h3><p>The road to partnerships begins with</p><ul><li>Establishing alignment<ul><li>Finding the right partners</li><li>Finding the thought leaders</li><li>Knowing the influencers</li><li>Establishing trusted advisers</li><li>Leveraging community review</li><li>Aligning a shared vision</li></ul></li><li>Establishing trust<ul><li>Establishing open disclosure</li><li>Avoiding overcommitment</li><li>Learning to occasionally say no</li></ul></li><li>Establishing context<ul><li>Understanding the nature of the partnership</li><li>Being knowledgeable of the business context</li><li>Framing technical decisions with a partnership</li><li>Realizing that technical decisions are political decisions</li><li>Learning to sell with a context</li><li>Having your partners’ backs</li><li>Realizing there is safety in numbers</li></ul></li><li>Establishing collaboration<ul><li>Bringing value to the table</li><li>Being willing to be a mentor and knowing when to seek a mentor</li><li>Recognizing oppourtunities</li><li>Enabling ideation</li></ul></li><li>Establishing relationships<ul><li>Being more than just about business</li><li>Making deposits before you begin withdrawing</li><li>Leveraging external relationships</li><li>Overcoming bad experiences from the past</li><li>Avoiding caustic members of the organization</li></ul></li></ul><h3 id="Discovery">Discovery</h3><p>The road to discovery begins with</p><ul><li>Understanding your customer<ul><li>Partnering with sales, marketing, and new product development</li><li>Visualizing your products from the vantage point of the customer</li><li>Preparing for customer visits</li><li>Meeting with customers</li><li>Recapping information learned from customer visits</li><li>Focusing on capturing the voice of the customer</li><li>Seeking to delight the customer</li></ul></li><li>Understanding the market in which your products compete<ul><li>Learning about your customers’ customers</li><li>Discovering where your customers are willing to spend money</li><li>Keeping an eye on the competition</li><li>Listening for themes across customers</li></ul></li><li>Understanding your business<ul><li>Learning what your business wants to do</li><li>Personalizing your company’s goal</li><li>Developing a business context for decision making</li></ul></li></ul><h3 id="Conceptualization">Conceptualization</h3><p>The road to conceptualization begins with</p><ul><li>Ideation with bussiness partnerships</li><li>Getting involved as early as possible in the process</li><li>Concept formulation<ul><li>Understanding the language of the customer</li><li>Developing domain models</li><li>Understanding the context of the customer</li><li>Committing cautiously when you are the new kid on the block</li><li>Visualizing the concept</li></ul></li><li>Concept reification<ul><li>Developing a minimum viable product</li><li>Experimenting with prototypes</li><li>Establishing assumptions</li><li>Establishing essential capabilities and customer roles</li><li>Reifying with customers</li></ul></li><li>Concept evolution<ul><li>Being a student of history</li><li>Embracing multiple perspectives</li><li>Recognizing adjacent opportunities</li></ul></li></ul><h3 id="Estimation">Estimation</h3><p>The road to estimation begins with</p><ul><li>Understanding the purpose of the estimate being sought</li><li>Understanding the project context</li><li>Understanding the estimating process</li><li>Developing an architectural approach</li><li>Knowing the estimating strategies and principles</li><li>Knowing how to bring it all together</li></ul><h3 id="Management">Management</h3><p>The road to management begins with</p><ul><li>Striving toward technology excellence</li><li>Delivering projects</li><li>Resolving issue</li><li>Partnering with executives</li><li>Managing your time</li><li>Grooming technical talent</li><li>Enhancing your skill set</li></ul><h2 id="Technology-Skills">Technology Skills</h2><h3 id="Platform-development">Platform development</h3><p>The road to platform development begins with</p><ul><li>Managing platform capabilities<ul><li>Defining the set of platform objectives</li><li>Defining the set of platform capabilities</li><li>Focusing on leverageable capabilities</li><li>Developing a strong conceptual model</li><li>Embracing APIs, configuration, and eventing as the keys to the platform</li></ul></li><li>Focusing on the platform ecosystem<ul><li>Konwing the platform users</li><li>Understanding platform ownership</li><li>Understanding platform management</li><li>Driving platform development</li><li>Acknowledging platform costs</li><li>Managing platform quality</li><li>Understanding platform integration</li></ul></li><li>Guiding the platform growth through principles</li></ul><h3 id="Architetectural-Perspective">Architetectural Perspective</h3><p>The road to architectural perspective begins with</p><ul><li>Knowing and understanding architectural principles</li><li>Knowing and understanding key areas of architectural concern</li><li>Creating architectural artifacts to bring clarity to what is being created</li></ul><h3 id="Governance">Governance</h3><p>The road to governance begins with</p><ul><li>Getting management support and sponsorship to do governance activities</li><li>Understanding and embrancing the governance and the underlying principles</li><li>Using governance as a mechanism to help guide both the architecture and its associated systems</li><li>Focusing on creating value for the business, not undue process</li></ul><p>The key is to find the right balance of governance and help mitigate risks, help reduce costs, and help promote leverage for the business.</p><h3 id="Know-how">Know-how</h3><p>The road to konw-how begins with</p><ul><li>Engaging in activities that increase your know-how</li><li>Expanding the basis of your knowledge</li><li>Staying current with the directions of the industry</li><li>Filling in any gaps that are critical to your area of responsibility</li><li>Staying passionate about software</li></ul><p>Software architecture is a great job and requires broad, active know-how to be successful in decision making. The great challenge is to balance the incessant demands on your time with the need to stay relevant. There will always be far more things to do than you can possibly get done. The keys are to</p><ul><li>Focus on what will provide high value to the business</li><li>Avoid major misses that will make executives unhappy</li><li>Follow the areas you are naturally passionate about</li><li>Surround yourself with experts and maintain a strong professional network</li></ul><h2 id="Visionary-Skills">Visionary Skills</h2><h3 id="Techology-Innovation">Techology Innovation</h3><p>The road to technology innovation begins with</p><ul><li>Being aware of the trends</li><li>Aligning with the business</li><li>Engaging in strategic research</li><li>Using innovation principles</li><li>Being a pragmatic technology innovator<br>Watching and following trends can be fun and exciting. They can easily distract you from the job at hand. However, they are also the eyes into the future that may provide opportunity or peril. Architects need to be familiar with the trends that are swirling around them and approach them with caution.<br>Technology innovation is a critical aspect of soft ware architecture. Learning when and where to introduce new and potentially disruptive technologies into the business is essential for business growth and operational stability.</li></ul><h3 id="Strategic-Roadmapping">Strategic Roadmapping</h3><p>The path to roadmapping begins with</p><ul><li>Understanding the elements of roadmapping</li><li>Leveraging the roadmapping strategies</li><li>Understanding the roadmapping principles</li><li>Knowing where roadmaps are best used</li><li>Being observant of new risks</li><li>Socializing the roadmap</li><li>Knowing your role in roadmap development</li><li>Celebrating milestone successes<br>For architects, roadmaps are an essential communication tool for helping to establish a vision of what needs to be accomplished and its approximate sequencing. When the business and architecture are on the same page regarding where a product or platform is going, this partnership can help propel the success of the business.</li></ul><h3 id="Entrepreneurial-Execution">Entrepreneurial Execution</h3><p>The road to entrepreneurial execution begins with</p><ul><li>Understanding the elements of entrepreneurial execution<ul><li>Entrepreneurial spirit</li><li>Calculated risk taking</li><li>Delivering results</li></ul></li><li>Using entrepreneurial execution principles as guidance<ul><li>Affordable Loss Principle</li><li>Lemonade Principle</li><li>Patchwork Quilt Principle</li><li>Bird-in-the-Hand Principle</li><li>Pilot-in-the-Plane Principle</li><li>Seize the moment</li><li>Follow your passion</li><li>Learn to pivot</li><li>Learn by doing and making mistakes</li><li>Seek feedback</li><li>Seek leverage</li></ul></li><li>Architecting with entrepreneurial execution</li></ul>]]></content>
    
    <summary type="html">
    
      The most complicated skill is to be simple.
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="SoftSkills" scheme="https://neo1989.net/tags/SoftSkills/"/>
    
  </entry>
  
  <entry>
    <title>The End Is Not the End, 2021</title>
    <link href="https://neo1989.net/SeizeTheDay/SUMMARY-2021/"/>
    <id>https://neo1989.net/SeizeTheDay/SUMMARY-2021/</id>
    <published>2021-12-31T14:12:00.000Z</published>
    <updated>2022-11-19T03:26:18.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>和喜欢的人，做喜欢的事，过喜欢的生活。</p></blockquote><h3 id="〖-2021-〗">〖 2021! 〗</h3><ul><li>第一次在上海过春节</li><li>三月去了趟甘南，司司不小心得急性肠胃炎</li><li>五月去了汤汕头南澳岛，司司不小心得感染(UTI)</li><li>拍到沪牌，入手Volvo V60</li><li>开始疯狂露营，疯狂收集落日</li><li>刻意<a href="/SeizeTheDay/FFF-weight-management/"><strong>低碳水饮食</strong></a>，狂瘦至62.0KG</li><li>着手幸会app的系统架构及AI端开发</li><li>上手opencv、ffmpeg，构建幸会app上的拍立得拼图及相遇视频自动生成</li><li>幸会app落地</li><li>国庆自驾了一圈西北环线</li><li>第一次乌镇戏剧节，参与《晚饭花》深夜诗歌朗诵，体验一般</li><li>年底连续长跑18次，尝试了一次10KM，似乎可以坚持</li></ul><h3 id="〖-2022-〗">〖 2022? 〗</h3><ul><li>继续深入AI方向</li><li>继续去探索世界</li></ul>]]></content>
    
    <summary type="html">
    
      The summary of 2021 and new year&#39;s resolution.
    
    </summary>
    
    
      <category term="SeizeTheDay" scheme="https://neo1989.net/categories/SeizeTheDay/"/>
    
    
  </entry>
  
  <entry>
    <title>认知偏差</title>
    <link href="https://neo1989.net/Notes/NOTE-cognitive-bias/"/>
    <id>https://neo1989.net/Notes/NOTE-cognitive-bias/</id>
    <published>2021-12-15T06:21:45.000Z</published>
    <updated>2023-01-13T03:01:29.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="决策、信念与行为偏差">决策、信念与行为偏差</h2><p>⚠️  这些偏差多半会影响信念的形成、商业与经济决策，以及其他一般的人类行为它们是可复制与再现的，面临特定情景时，一半可预期人们会有相应的偏差倾向。</p><h3 id="不明确效应-Ambiguity-Effect">不明确效应 Ambiguity Effect</h3><p>我们倾向于避免未知，决策时避开资讯不足的选项，通过添加明确的细节来最大程度地减少歧义，从而提高转化率。</p><h3 id="锚定效应-Anchoring-Effect">锚定效应 Anchoring Effect</h3><p>人类在进行决策时，会过度偏重先前取得的资讯（这称为锚点），即使这个资讯与这项决定无关。在进行决策时，人类倾向于利用此段资讯（锚点），快速做出决定。</p><h3 id="注意力偏差-Attention-Effect">注意力偏差 Attention Effect</h3><p>在检查所有可能的结果时，我们倾向于关注一些看起来合理且熟悉的事物，从而忽略了其他结果。</p><h3 id="获得性启发-Availability-Heuristic">获得性启发 Availability Heuristic</h3><p>我们认为那些迅速跃入脑海的事情比那些不容易想起的事情更为常见和重要。因此，最近发生的、频繁发生的、极端的、被记住的事情比大多数信息更有影响力。</p><h3 id="可获性层叠-Availability-Cascade">可获性层叠 Availability Cascade</h3><p>这个心理效用有一个更简单的描述，叫做三人成虎，也就是一件事越常被公开讨论，人们就越相信这件事情。</p><h3 id="逆火效应-Backfire-Effect">逆火效应 Backfire Effect</h3><p>我们不能轻易改变人们的信念：与根深蒂固的信念相反的证据和论据无济于事，只会巩固信念的地位。</p><h3 id="从众效应-Bandwagon-Effect">从众效应 Bandwagon Effect</h3><p>我们经常会因为大多数人以同一种方式思考，而改变我们自己的想法。</p><h3 id="信念偏差-Belief-Bias">信念偏差 Belief Bias</h3><p>我们更倾向于接受与我们的先验知识相符的论点，而拒绝对该论点的反驳。</p><h3 id="选择支持偏差-Choice-Supporitive-Bias">选择支持偏差 Choice-Supporitive Bias</h3><p>做出决定后，我们倾向于称赞我们选择的选项，然后降级其他选项。</p><h3 id="确认偏差-Confirmation-Bias">确认偏差 Confirmation Bias</h3><p>当人本来就持有某种观点时，对这种观点的感知和注意度会被放大，会选择性地会议或手机关于它的实例。人们对于自己原本就相信的观点会更容易接受，而把反面观点搁置在一旁。</p><h3 id="知识的诅咒-Curse-of-Knowledge">知识的诅咒 Curse of Knowledge</h3><p>当我们是某个领域的专家时，会不知不觉假设其他人和我们具有相同的理解能力，尤其是对于专业术语的使用。</p><h3 id="诱饵效应-Decoy-Effect">诱饵效应 Decoy Effect</h3><p>引入第三个选项来加强旧选项的吸引力。</p><h3 id="差异偏差-Distinction-Bias">差异偏差 Distinction Bias</h3><p>在有比较项存在时，我们对微小的差异变得敏感，而实际上，这些差异并不是很大。</p><h3 id="禀赋效应-Endowment-Effect">禀赋效应 Endowment Effect</h3><p>和没有拥有的物品相比，用户更倾向于保留自己拥有的物品。他们倾向于高估自己拥有的东西，而忽略其客观的市场价值。</p><h3 id="功能固有-Functional-Fixedness">功能固有 Functional Fixedness</h3><p>指个体在解决问题时往往只看到某种事物的通常功能，而看不到其他方面可能有的功能。这是人们长期以来形成的对某些事物的功能或用途的固定看法。</p><h3 id="巴纳姆效应-Barnum-Effect">巴纳姆效应 Barnum Effect</h3><p>也称佛瑞效应。人们会对于他们认为是为自己量身定制的一些人格描述给予高度准确的评价，而这些描述往往十分模糊及普遍，以致能够放诸四海而皆准适用于很多人身上。</p><h3 id="框架效应-Framing-Effect">框架效应 Framing Effect</h3><p>框架效应的意义是，面对同一个的问题，在使用不同的描述后，人们会选择乍听只在较有利或顺耳的描述作为方案。<br>（大多数情况下，正向表达的转化率更高）</p><h3 id="频率错觉-Frequency-Illusion">频率错觉 Frequency Illusion</h3><p>首次引起我们注意后，我们很快就会从很多地方注意到相关信息。<br>（如果某人想买一辆新车，通常会突然发现到处都是这辆车）</p><h3 id="后见之明偏差-Hindsight-Bias">后见之明偏差 Hindsight Bias</h3><p>后视偏见会让人沉迷与“我早就料到了”这种感受当中，无法真正从事件中汲取到有用的经验，也难以用公平的眼光来评判客观事物和他人，主观上也很容易选择性地忽略许多客观事实。</p><h3 id="当下偏差-Current-Moment-Bias">当下偏差 Current Moment Bias</h3><p>又称限时偏差，人们更倾向于获取即时收益，而非未来的更大收益。</p><h3 id="可辨识受害者效应-Identifiable-Victim-Effect">可辨识受害者效应 Identifiable Victim Effect</h3><p>我们倾向于同情一个特定的人而不是匿名的某一个人。</p><h3 id="宜家效应-IKEA-Effect">宜家效应 IKEA Effect</h3><p>宜家效应是指人们倾向于高度评价他们参与创造的产品，消费者对于一个物品付出的劳动（情感）越多，就越容易高估该物品的价值。</p><h3 id="影响力偏差-Impact-Bias">影响力偏差 Impact Bias</h3><p>我们倾向于高估未来情绪状态的持续时间或强度。</p><h3 id="资讯偏差-Information-Bias">资讯偏差 Information Bias</h3><p>因测量误差多导致的一种偏误现象，有时亦称为观察偏误或分组错误。</p><h3 id="沉默成本谬误-Sunk-Cost-Fallacy">沉默成本谬误 Sunk Cost Fallacy</h3><p>我们在某件事上投入越多就越难放弃它。因此，我们往往会继续执行这个走向失败的行动，仅仅是因为我们过去已经在此投入了过多的事件、金钱或精力。</p><h3 id="损失趋避-Loss-Aversion">损失趋避 Loss Aversion</h3><p>指人们面对同样数量的收益和损失时，认为损失更加令他们难以忍受。损失带来的负效用为收益正效用的2至2.5倍。损失厌恶反映了人们的风险偏好并不是一致的，当涉及的是收益时，人们表现为风险厌恶；当涉及的是损失时，人们则表现为风险寻求。</p><h3 id="单纯接触效应-Mere-Exposure-Effect">单纯接触效应 Mere Exposure Effect</h3><p>人们会单纯因为自己熟悉某个事物而产生好感。它表名某一外在刺激，仅仅因为呈现的次数越频繁（使个体能够接触到该刺激的机会越多），个体对该刺激就越喜欢。</p><h3 id="负面偏差-Negativity-Bias">负面偏差 Negativity Bias</h3><p>相比于中性或者积极的事物，具有负面影响的事物对人们的心理影响更大。<br>（通过解决负面体验来说明你的产品价值，如果希望自己的故事能够产生更大的影响，就要尝试多展现情感上负面的内容）</p><h3 id="忽略可能性-Neglect-of-Probability">忽略可能性 Neglect of Probability</h3><p>当我们承受压力时，我们没有想到风险发生的可能性。结果，较小的风险可能被高估或被忽略。</p><h3 id="乐观偏差-Optimism-Bias">乐观偏差 Optimism Bias</h3><p>与别人相比，我们经常高估自己成功的几率。</p><h3 id="鸵鸟效应-Ostrich-Effect">鸵鸟效应 Ostrich Effect</h3><p>我们故意避免负面信息（或与我们的期望不一致的反馈），认为如果我们把头埋在沙子里，它们就会消失。</p><h3 id="规划谬误-Planning-Fallacy">规划谬误 Planning Fallacy</h3><p>我们倾向于低估完成一项任务所需要的事件，通常规划谬误会导致时间超支，成本超支或收益不足。将大型任务分解为较小的部分有助于解决问题。</p><h3 id="对抗心理-Reactance">对抗心理 Reactance</h3><p>当我们感到某人（或某物）试图剥夺或限制我们的选择时，对抗心理就会发生。当他们发生时，我们有一种抵制它并采取相反行动的冲动。<br>（当你与用户“争论”他的选择时要小心，说服对方时必须循循善诱，永远不要与用户直接对抗。）</p><h3 id="自制偏差-Restraint-Bias">自制偏差 Restraint Bias</h3><p>人们经常会高估自己控制冲动行为的能力。<br>（我们都认为“标题党”属于旁门左道，但我们还是容易陷入其中，不是吗？）</p><h3 id="韵律当理由效应-Rhyme-as-Reason-Effect">韵律当理由效应 Rhyme as Reason Effect</h3><p>大部分广告语朗朗上口，非常洗脑。<br>（所以，尽可能的把你的产品文案变得有韵律感，这样更容易说服用户。）</p><h3 id="风险补偿-Risk-Compensation">风险补偿 Risk Compensation</h3><p>当我们感觉到更大的风险时，我们会变得更加谨慎，而当我们收到更多保护时，我们就会没那么多谨慎。所以当我们知道在已经采取了很多安全措施以后，我们更有可能采取冒险的方式行事。<br>（在购买或注册前让用户对产品产生尽可能的安全感）</p><h3 id="选择性知觉-Selective-Perception">选择性知觉 Selective Perception</h3><p>我们对事物的看法很大程度上受到期望的影响，当人们集中注意力时，人们会从环境中过滤掉事物。</p><h3 id="幸存者偏差-Survivorship-Bias">幸存者偏差 Survivorship Bias</h3><p>过度关注幸存下来的人或事物，忽略哪些被筛选掉的人或事物（可能因为无法观察到），从而得出错误的结论。</p><h3 id="零风险偏差-Zero-Risk-Bias">零风险偏差 Zero-Risk Bias</h3><p>我们喜欢确定性，即使它适得其反。在有其他方案可以降低整个风险的情形下，仍倾向于完全消除某一项风险的偏见。一个例子是可以降低个人负责领域的风险，可是代价是整个组织风险的上升。</p><h3 id="感知价值偏差-Perceived-Value-Bias">感知价值偏差 Perceived Value Bias</h3><p>我们根据产品的外观或服务方式来感知其价值。正如人们所说：全部在包装中！</p><h3 id="分析瘫痪-Analysis-Paralysis">分析瘫痪 Analysis Paralysis</h3><p>又称选择超载。当出现太多选择时，我们的大脑就会瘫痪，很难进行选择。<br>（选择太多 = 转换率低）</p><h3 id="稀缺效应-Scarcity-Effect">稀缺效应 Scarcity Effect</h3><p>我们将稀缺物品的价值提高，将高可用性物品的价值降低。 害怕错过（FOMO）是我们更容易收到诱惑和冲动，并促使我们做出轻率的决定。<br>（使用“限时优惠”，“有限数量”等修辞来形容你的产品或服务。）</p><h3 id="流畅性启发-Fluency-Heuristic">流畅性启发 Fluency Heuristic</h3><p>我们认为那些处理速度更快、更流畅、更顺利的事物具有更高的价值。有时不合逻辑的论点在沟通良好的情况下（由有权威和经验的人提出）也可能会赢得胜利。</p><h2 id="社会偏差">社会偏差</h2><p>⚠️  这些偏差大多是由归因偏差导致。</p><h3 id="行动者-观察者偏差-Actor-Observer-Bias">行动者-观察者偏差 Actor-Observer Bias</h3><p>行动者喜欢将他们自己的行为归因于情境性因素，而观察者喜欢将同样的行为归因于行动者稳定的人格素质。</p><h3 id="达克效应-Dunning-Kruger-Effect">达克效应 Dunning-Kruger Effect</h3><p>我们无法认识到我们缺乏能力，并且由于无法分辨能力好与能力差的不同，因而认为大家都一样。</p><h3 id="错误共识效应-False-Consensus-Effect">错误共识效应 False Consensus Effect</h3><p>人们倾向于高估别人对自己的认同程度，想象其他人像我们一样，并分享我们的观点，信念，偏好，价值观和习惯，认为所有人以同样的方式思考。</p><h3 id="基本归因谬误-Fundamental-Attribution-Error">基本归因谬误 Fundamental Attribution Error</h3><p>解释他人行为时，归因于内在特质（一定是他有这样的人格，才做出这样的行为），而非外在情景（也许是情势所迫，或这个场所特有的潜规则）。基本归因谬误是矛盾和问题的常见来源，而且这种认知偏差存在于用户也同样存在于设计师本身。</p><h3 id="晕轮效应-Halo-Effect">晕轮效应 Halo Effect</h3><p>晕轮效应是指使用一个人（或事物）的一种品质来对该人或事物进行整体判断，换句话说，我们对一个人、一个产品、一家公司或一个品牌的最初印象会影响我们对其整体特征的解读。</p><h3 id="群内效应-Ingroup-Effect">群内效应 Ingroup Effect</h3><p>群内偏差常被用来引导用户决策，它是指人们会在认知傻姑娘倾向于自己所属的群体。在体验设计中利用群内偏差的关键点在于打造群体归属感，借由小群体的力量影响用户的决策。</p><h3 id="权威偏见-Authority-Bias">权威偏见 Authority Bias</h3><p>我们认为权威人士给出的建议准确性更高，并且更容易受到该建议的影响（即使事物主题与该任务的权威性无关）</p><h3 id="得寸进尺法-Foot-in-the-Door-Technique">得寸进尺法 Foot-in-the-Door Technique</h3><p>通过先提出一个简单的小请求来说服用户同意一个较大请求的劝说。</p><h2 id="记忆错误与偏差">记忆错误与偏差</h2><p>⚠️  在心理学和认知科学中，记忆偏差是一种认知偏差，导致记忆的强化、弱化（包括能否想起的机会、想起所需的时间，或两者皆有），或者记忆内容的改变。</p><h3 id="谷歌效应-Google-Effect">谷歌效应 Google Effect</h3><p>我们会容易忘记可以从网上轻松找到的信息。</p><h3 id="幽默效应-Humor-Effect">幽默效应 Humor Effect</h3><p>当信息被认为是有趣或幽默时，我们会更好地记住信息。这可以帮助提高产品的转化率，并有助于整体业务的提升。</p><h3 id="真相错觉效应-Illusion-of-Truth-Effect">真相错觉效应 Illusion of Truth Effect</h3><p>重复的事情越多，我们就越相信。</p><h3 id="峰终法则-Peak-End-Rule">峰终法则 Peak-End Rule</h3><p>用户不仅仅根据平均或所有体验的综合来评估体验，取而代之的是，他们的大脑会严重地偏向峰值（高或低）和体验的终点，峰值如果是愉悦的话，通常对应了用户旅程中令人难忘的愉悦感。</p><h3 id="图片优势效应-Picture-Superiority-Effect">图片优势效应 Picture Superiority Effect</h3><p>图片和图像比一千个单词更容易被记住。</p><h3 id="首因效应-Primacy-Effect">首因效应 Primacy Effect</h3><p>又称近时效应、序位效应。列表开头和结尾的项目比中间的项目更容易被用户记住。</p><h3 id="雷斯多夫效应-Von-Restorff-Effect">雷斯多夫效应 Von Restorff Effect</h3><p>当很多信息一起呈现时，醒目的信息和被特变强调的信息会比其他信息更容易被人们记住。</p><h3 id="蔡格尼效应-Zeigarnik-Effect">蔡格尼效应 Zeigarnik Effect</h3><p>进行中的任务会产生特定于任务的张力。当任务完成时，这种压力可以缓解，但是如果任务被终端，它将保持不变，这种张力使相关信息更易于访问和记忆。<br>（显示一个不完整的进度栏，以鼓励用户实现自己的目标）</p><h2 id="统计与几率偏差">统计与几率偏差</h2><p>⚠️  几率性推论是指根据有关几率的资讯推论事情的可能，而几率的估算通常来自统计资料，因此两者密不可分。</p><h3 id="基本比率谬误-Base-Rate-Fallacy">基本比率谬误 Base Rate Fallacy</h3><p>我们倾向于忽略一般信息，而只关注特定案例。</p><h3 id="赌徒谬误-Gambler’s-Fallacy">赌徒谬误 Gambler’s Fallacy</h3><p>我们错误的认为，如果在给定时期内某件时期频繁发生，那么这件事情在将来发生的几率就会很小。</p><h3 id="热手谬误-Hot-Handy-Fallacy">热手谬误 Hot-Handy Fallacy</h3><p>错误地认为经历过成功的人更有可能在其他尝试中进一步获得成功。一般是在某人近来做某事很成功时，认为他未来做同一件事也会成功，而忽略其成功可能只是随机与巧合导致。</p><h3 id="对样本数不敏锐-Insensitivity-to-Sample-Size">对样本数不敏锐 Insensitivity to Sample Size</h3><p>我们经常忽略样本大小并贸然下结论，即使样本数量还未达到足够的统计量。</p><h2 id="实验与研究偏差">实验与研究偏差</h2><p>⚠️  这是一些科学实验与统计研究容易发生的偏差。</p><h3 id="取样偏差-Sampling-Bias">取样偏差 Sampling Bias</h3><p>某些类型的用户被无意中从研究参与者池中提出了。亦可以理解为以偏概全，即以局部事例解释整体原因。</p><h3 id="观察者期望效应-Observer-Expectancy-Effect">观察者期望效应 Observer-Expectancy Effect</h3><p>研究者有时可能会期望出现某种结果，他们无意识地操纵了实验过程，或者错误地解释实验结果，导致研究结果严重歪曲。</p><h3 id="社会期许偏差-Social-Desirability-Bias">社会期许偏差 Social Desirability Bias</h3><p>我们倾向于多表达复合社会期许的事情，而隐瞒那些不符合社会预期的事情。例如在询问是否有不良嗜好、性伴侣数量时，大家会有意无意地隐瞒或淡化实情。</p><h3 id="遗漏变数偏差-Omitted-Variable-Bias">遗漏变数偏差 Omitted-Variable Bias</h3><p>当获得的奖励出乎意料之外，我们获得奖励的喜悦感就会增加。</p><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://zh.wikipedia.org/wiki/%E8%AA%8D%E7%9F%A5%E5%81%8F%E8%AA%A4%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">认知偏差列表</a><br>[2] <a href="https://s75w5y7vut.feishu.cn/docs/doccn3BatnScBJe7wD7K3S5poFf" target="_blank" rel="noopener">认知偏差知识手册</a></p>]]></content>
    
    <summary type="html">
    
      心理学词条。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>低碳水饮食实践</title>
    <link href="https://neo1989.net/SeizeTheDay/FFF-weight-management/"/>
    <id>https://neo1989.net/SeizeTheDay/FFF-weight-management/</id>
    <published>2021-09-05T03:02:34.000Z</published>
    <updated>2022-11-19T03:18:53.352Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="/SeizeTheDay/HEALTH-low-carb-diet/"><strong>低碳水饮食方法论</strong></a></p></blockquote><p><img src="http://s3.mindex.xyz/blog/SeizeTheDay/88a71e64f2b8bac8fc2b4aa5d33c2c5b.png" alt="Congrats!"></p>]]></content>
    
    <summary type="html">
    
      深度实践低碳水饮食
    
    </summary>
    
    
      <category term="SeizeTheDay" scheme="https://neo1989.net/categories/SeizeTheDay/"/>
    
    
      <category term="Health" scheme="https://neo1989.net/tags/Health/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Python》</title>
    <link href="https://neo1989.net/Notes/NOTE-effective-python/"/>
    <id>https://neo1989.net/Notes/NOTE-effective-python/</id>
    <published>2021-08-10T11:00:20.000Z</published>
    <updated>2023-01-13T03:01:36.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="培养Pythonic思维">培养Pythonic思维</h2><h3 id="查询自己使用的Python版本">查询自己使用的Python版本</h3><ul><li>Python3是最新版的Python，而且受到了很好的支持，大家应该用Python3开发项目。</li><li>在操作系统的命令行界面运行Python时，要确认该Python的版本是否跟你要使用的版本相同。</li><li>不要再使用Python2做开发了，该版本已于2022年1月1日停止更新维护。</li></ul><h3 id="遵循PEP8风格指南">遵循PEP8风格指南</h3><ul><li>编写Python代码时，总是应该遵循PEP8风格指南。</li><li>与广大Python开发者同时采用同一套代码风格，可以使项目更利于多人协作。</li><li>采用一致的风格编写代码，代码的后续修改跟容易。</li></ul><h3 id="了解bytes与str的区别">了解bytes与str的区别</h3><ul><li>bytes包含的是由8bits所组成的序列，str包含的是由Unicode码点所组成的序列。</li><li>我们可以编写辅助函数来确保程序收到的字符序列确实是期望要操作的类型（要知道自己想操作的到底是Unicode码点，还是原始的8位值。用UTF-8标准给字符串编码，得到的就是这样的一系列8位值）。</li><li>bytes与str这两种实例不能再某些操作符（如&gt;、==、+、%等）上面混用。</li><li>从文件中读取二进制数据（或者写入二进制数据到文件）时，应该用’rb’ (‘wb’) 这样的二进制模式打开文件。</li><li>如果要从文件中读取（或者写入）的是Unicode数据，那么必须注意系统默认的文件编码方案。若无法肯定，可通过encoding参数明确指定。</li></ul><h3 id="用支持插值的f-string取代C风格的格式字符串与str-format方法">用支持插值的f-string取代C风格的格式字符串与str.format方法</h3><ul><li>采用%操作符把值填充到C风格的格式字符串时会遇到许多问题，而且这种写法比较繁琐。</li><li>str.format方法专门用一套迷你语言来定义它的格式说明符，这套语言给我们提供了一些有用的概念，但是在其他方面，这个方法还是存在与C风格的格式字符串一样的多种缺点，所以我们也应该避免使用它。</li><li>f-string是个简洁而强大的机制，可以直接在格式说明符里嵌入任意Python表达式。</li></ul><h3 id="用辅助函数取代复杂的表达式">用辅助函数取代复杂的表达式</h3><ul><li>Python的语法很容易把复杂的额意思挤到同一行表达式里，这样写很难懂。</li><li>复杂的表达式，尤其是那种需要重复使用的复杂表达式，应该写到辅助函数里面。</li><li>用if/else结构写成的条件表达式，要比用or与and写成的Bollean表达式更好懂。</li></ul><h3 id="把数据结构直接拆分到多个变量里，不要专门通过下表访问">把数据结构直接拆分到多个变量里，不要专门通过下表访问</h3><ul><li>unpacking是一种特殊的Python语法，只需要一行代码，就能把数据结构里面的多个值分别赋给相应的变量。</li><li>unpacking在Python中应用广泛，凡是可迭代的对象都能拆分，无论它里面还有多少层迭代结构。</li><li>尽量通过unpacking来拆解序列之中的数据，而不是通过下标访问，这样可以让代码更简洁、更清晰。</li></ul><h3 id="尽量用enumerate取代range">尽量用enumerate取代range</h3><ul><li>enumerate函数可以用简洁的代码迭代iterator，而且可以指出当前这轮循环的序号。</li><li>不要先通过range指定下标的取值范围，然后用下标去访问序列，而是应该直接用enumerate函数迭代。</li><li>可以通过enumerate的第二个参数指定起始序号（默认为0）。</li></ul><h3 id="用zip函数同时遍历两个迭代器">用zip函数同时遍历两个迭代器</h3><ul><li>内置的zip函数可以同时遍历多个迭代器。</li><li>zip会创建惰性生成器，让它每次只生成一个元组，所以无论输入的数据有多长，它都是一个一个处理的。</li><li>如果提供的迭代器的长度不一致，那么只要其中任何一个迭代完毕，zip就会停止。</li><li>如果想按最长的那个迭代器来遍历，那就改用内置的itertools模块中的zip_logngest函数。</li></ul><h3 id="不要在for与while的循环后面鞋else块">不要在for与while的循环后面鞋else块</h3><ul><li>Python有种特殊的语法，可以把else块紧跟在整个for循环或while循环的后面。</li><li>只有在整个循环没有因为break提前跳出的情况下，else块才会执行。</li><li>把else块紧跟在整个循环后面，会让人不太容易看出这段代码的意思，所以要避免这样写。</li></ul><h3 id="用赋值表达式减少重复代码">用赋值表达式减少重复代码</h3><ul><li>赋值表达式通过海象操作符（:=）给变量赋值，并且让这个值成为这条表达式的结果，于是，我们可以利用这项特性来缩减代码。</li><li>如果赋值表达式是大表达式里的一部分，就得用一对括号把它括起来。</li><li>虽说Python不支持switch/case与do/while，但可以利用赋值表达式清晰地模拟出这种逻辑。</li></ul><h2 id="列表与字典">列表与字典</h2><h3 id="学会对序列做切片">学会对序列做切片</h3><ul><li>切片要尽可能写得简单一些：如果从头开始选取，就省略起始下标0；如果选到序列序列末尾，就省略终止下标。</li><li>切片允许起始下标或终止下标越界，所以很容易就能表达“取开头多少个元素”（如a[:10]） 或 “取末尾多少个元素”（如a[-10:0]）等含义，而不用担心切片是否真有这么多元素。</li><li>把切片放在赋值符号的左侧可以将原列表中这段范围内的元素用赋值符号右侧的元素替换掉，但可能会改变原列表的长度。</li></ul><h3 id="不要在切片里同时指定起止下标与步进">不要在切片里同时指定起止下标与步进</h3><ul><li>同时指定切片的起止下标与步进值理解起来会很困难。</li><li>如果要指定步进值，那就省略起止下标，而且最好采用正数作为步进值，尽量别用负数。</li><li>不要把起始位置，终止位置与步进值全都写在同一个切片操作里。如果必须同时使用这三项指标，那就分两次来做（其中一次隔位选取，另一次做切割），也可以改用itertools内置模块里的islice方法。</li></ul><h3 id="通过带星号的unpacking操作来捕获多个元素，不要用切片">通过带星号的unpacking操作来捕获多个元素，不要用切片</h3><ul><li>拆分数据结构并把其中的数据赋给变量时，可以用带星号的表达式，将结构中无法与普通变量相匹配的内容捕获到一份列表里。</li><li>这种带星号的表达式可以出现在赋值符号左侧的任意位置，它总会形成一份含有零个或多个值的列表。</li><li>在把列表拆解成互相不重叠的多个部分时，这种带星号的unpacking方式比较清晰，而通过下标与切片来实现的方式则容易出错。</li></ul><h3 id="用sort方法的key参数来表示复杂的排序逻辑">用sort方法的key参数来表示复杂的排序逻辑</h3><ul><li>列表的sort方法可以根据自然顺序给其中的字符串、整数、元组等内置类型的元素进行排序。</li><li>普通对象如果通过特殊方法定义了自然顺序，那么也可以用sort方法来排列，但这样的对象并不多见。</li><li>可以把辅助函数传给sort方法的key参数，让sort根据这个函数所返回的值来排列元素顺序，而不是根据元素本身来排列。</li><li>如果排序时要依据的指标有很多项，可以把它们放在一个元组中，让key函数返回这样的元组。对于支持一元减操作符的类型来说，可以单独给这项指标取反，让排序算法在这项指标上按照相反的方向处理。</li><li>如果这些指标不支持一元减操作符，可以多次调用sort方法，并在每次调用时分别指定key函数与reverse参数。最次要的指标放在第一轮处理，然后逐步处理更为重要的指标，首要指标放在最后一轮处理。</li></ul><h3 id="不要过分依赖给字典添加条目时所用的顺序">不要过分依赖给字典添加条目时所用的顺序</h3><ul><li>从Python3.7版开始，我们就可以确信迭代标准的字典时所看到的顺序跟这些键值对插入字典时的顺序一致。</li><li>在Python代码中，我们很容易就能定义跟标准的字典很像但本身并不是dict实例的对象。对于这种类型的对象，不能假设迭代时看到的顺序必定与插入时的顺序相同。</li><li>如果不想把这种跟标准字典很相似的类型也当成标准字典来处理，那么可以考虑这样三种办法。<br>第一，不要依赖插入时的顺序编写代码；<br>第二，在程序运行时明确判断它是不是标准的字典；<br>第三，给代码添加类型注解并做静态分析。</li></ul><h3 id="用get处理键不在字典中的情况，不要使用in与KeyError">用get处理键不在字典中的情况，不要使用in与KeyError</h3><ul><li>有四种办法可以处理键不在字典中的情况：in表达式、KeyError异常、get方法与setdefault方法</li><li>如果跟键相关联的值是像计数器这样的基本类型，那么get方法就是最好的方案；如果是那种构造起来开销比较大，或是容易出异常的类型，那么可以把这个方法与赋值表达式结合起来使用。</li><li>即使看上去最应该使用setdefault方案，也不一定要真的使用setdefault方案，而是可以考虑用defalutdict取代普通的dict。</li></ul><h3 id="用defaultdict处理内部状态中缺失的元素，而不要用setdefault">用defaultdict处理内部状态中缺失的元素，而不要用setdefault</h3><ul><li>如果你管理的字典可能需要添加任意的键，那么应该考虑能否用内置的collections模块中的defaultdict实例来解决问题。</li><li>如果这种键名比较随意的字典是别人传给你的，你无法把它创建成defaultdict，那么应该考虑通过get方法访问其中的键值。然而，在个别情况下，也可以考虑改用setdefault方法，因为那样写更短。</li></ul><h3 id="学会利用-missing-构造依赖键的默认值">学会利用__missing__构造依赖键的默认值</h3><ul><li>如果创建默认值需要较大的开销，或者可能抛出异常，那就不适合用dict类型的setdefault方法实现。</li><li>传给setdefault的函数必须是不需要参数的函数，所以无法创建出需要依赖键名的默认值。</li><li>如果要构造的默认值必须根据键名来确定，那么可以定义自己的dict子类并实现__missing__方法。</li></ul><h2 id="函数">函数</h2><h3 id="不要把函数返回的多个数值拆分到三个以上的变量中">不要把函数返回的多个数值拆分到三个以上的变量中</h3><ul><li>函数可以把多个值合起来通过一个元组返回给调用者，以便利用Python的unpacking机制取拆分。</li><li>对于函数返回的多个值，可以把普通变量没有捕获到的那些值全都捕获到一个带星号的变量里。</li><li>把返回的值拆分到四个或四个以上的变量是很容易出错的，所以最好不要那么写，而是应该通过小类或namedtuple实例完成。</li></ul><h3 id="遇到意外状况时应该抛出异常，不要返回None">遇到意外状况时应该抛出异常，不要返回None</h3><ul><li>用返回值None表示特殊情况是很容易出错的，因为这样的值在条件表达式里面，每办法与0和空白字符串之类的值区分，这些值都想当与False。</li><li>用异常表示特殊的情况，而不要返回None。让调用这个函数的程序根据文档里写得异常情况做出处理。</li><li>通过类型注解可以明确禁止函数返回None，即便在特殊情况下，它也不能返回这个值。</li></ul><h3 id="了解如何在闭包里面使用外围作用域中的变量">了解如何在闭包里面使用外围作用域中的变量</h3><ul><li>闭包函数可以引用定义它们的那个外围作用域之中的变量。</li><li>按照默认的写法，在闭包里面给变量赋值并不会改写外围作用域中的同名变量。</li><li>出特别简单的函数外，尽量少用nonlocal语句。</li></ul><h3 id="用数量可变的位置参数给函数设计清晰的参数列表">用数量可变的位置参数给函数设计清晰的参数列表</h3><ul><li>用def定义函数时，可以通过 *args 的写法让函数接受数量可变的位置参数。</li><li>调用函数时，可以在序列左边加上 * 操作符，把其中的元素当成位置参数传给 *args 所表示的这一部分。</li><li>如果 * 操作符加在生成器前，那么传递参数时，程序有可能因为耗尽内存而崩溃。</li><li>给接受 *args 的函数添加新位置参数，可能导致难以排查的bug。</li></ul><h3 id="用关键字参数来表示可选行为">用关键字参数来表示可选行为</h3><ul><li>函数的参数可以按位置指定，也可以用关键字的形式指定。</li><li>关键字可以让每个参数的作用更加明了，因为在调用函数时只按位置指定参数，可能导致这些参数的含义不够明确。</li><li>应该通过带默认值的关键字参数来扩展函数行为，因为这部会影响原有的函数调用代码。</li><li>可选关键字参数总是应该通过参数名来传递，而不应按位置传递。</li></ul><h3 id="用None和docstring来描述默认值会变得参数">用None和docstring来描述默认值会变得参数</h3><ul><li>参数的默认值只会计算一次，也就是在系统把定义函数的那个模块加载进来的时候。所以，如果默认值将来可能由调用放修改（例如{}， []）或者要随着调用时的情况变化（例如datetime.now()），那么程序就会出现奇怪的效果。</li><li>如果关键字参数的默认值属于这种会发生变化的值，那就应该写成None，并且要在docstring里面描述函数此时的默认行为。</li><li>默认值为None的关键字参数，也可以添加类型注解。</li></ul><h3 id="用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表">用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表</h3><ul><li>Keyword-Only Arguments是一种只能通过关键字指定而不能通过位置指定的参数。这迫使调用者必须指明，这个值是传给哪一个参数的。在函数的参数列表中，这种参数位于 * 符号的右侧。</li><li>Positional-Only Arguments是这样一种参数，它不允许调用者通过关键字来指定，而是要求必须按照位置传递。这可以降低调用代码与参数名称之间的耦合程度。在函数的参数列表中，这些参数位于/符号的左侧。</li><li>在参数列表中，位于 / 与 * 之间的参数，可以按位置指定，也可以用关键字来指定。这也是Python普通参数的默认指定方式。</li></ul><h3 id="用functools-wraps定义函数修饰器">用functools.wraps定义函数修饰器</h3><ul><li>修饰器是Python中的一种写法，能够把一个函数封装在另一个函数里面，这样程序在执行原函数之前与执行完毕之后，就有机会执行其他一些逻辑了。</li><li>修饰器可能会让那些利用instropection机制运作的工具（例如调试器）产生奇怪的行为。</li><li>Python内置的functools模块里有个叫wraps的修饰器，可以帮助我们正确定义自己的修饰器，从而避开相关的问题。</li></ul><h2 id="推导与生成">推导与生成</h2><h3 id="用列表推导取代map与filter">用列表推导取代map与filter</h3><ul><li>列表推导要比内置的map与filter函数清晰，因为它不用另外定义lambda表达式。</li><li>列表推导可以很容易地跳过原列表中的某些数据，加入改用map实现，那么必须搭配filter才能实现。</li><li>字典与集合也可以通过推导来创建。</li></ul><h3 id="控制推导逻辑的子表达式不要超过两个">控制推导逻辑的子表达式不要超过两个</h3><ul><li>推导的适合可以使用多层循环，每层循环可以带有多个条件。</li><li>控制推导逻辑的子表达式不要超过两个，否则代码很难读懂。</li></ul><h3 id="用赋值表达式消除推导中的重复代码">用赋值表达式消除推导中的重复代码</h3><ul><li>编写推导式与生成器表达式时，可以在描述条件的那一部分通过赋值表达式定义变量，并在其他部分复用该变量，可使程序简单易读。</li><li>对于推导式与生成器表达式来说，虽然赋值表达式也可以出现在描述条件的那一部分之外，但最好别这么写。</li></ul><h3 id="不要让函数直接返回列表，应该让它逐个生成列表里的值">不要让函数直接返回列表，应该让它逐个生成列表里的值</h3><ul><li>用生成器来实现比让函数把结果收集到列表里再返回，要更加清晰一些。</li><li>生成器函数所返回的迭代器可以产生一系列值，每次产生的那个值都是由函数体的下一条yield表达式所决定的。</li><li>不管输入的数据量有多大，生成器函数每次都只需要根据其中的一小部分来计算当前这次的输出值。它不用把整个输入值全都读取进来，也不用一次就把所有的输出值全都算好。</li></ul><h3 id="谨慎地迭代函数所收到的参数">谨慎地迭代函数所收到的参数</h3><ul><li>函数和方法如果要把收到的参数遍历很多遍，那就必须特别小心。因为如果这些阐述为迭代器，那么程序可能得不到预期的值，从而出现奇怪的效果。</li><li>Python的迭代器协议确定了容器与迭代器应该怎样跟内置的iter及next函数、for循环及相关的表达式交互。</li><li>要想让自定义的容器类型可以迭代，只需要把__iter__方法实现为生成器即可。</li><li>可以把值传给iter函数，检测它返回的是不是那个值本身。如果是，就说明这是个普通的迭代器，而不是一个可以迭代的容器。另外也可以用内置的isinstance函数判断该值是不是collections.abc.Iteration类的实例。</li></ul><h3 id="考虑用生成器表达式改写数据量较大的列表推导">考虑用生成器表达式改写数据量较大的列表推导</h3><ul><li>通过列表推导来处理大量的输入数据，可能会占用许多内存。</li><li>改用生成器表达式来做，可以避免内存使用量过大的问题，因为这种表达式所形成的迭代器每次只会计算一项结果。</li><li>生成器表达式所形成的迭代器可以当成for语句的子表达式出现在另一个生成器表达式里面。</li><li>把生成器表达式组合起来使用，能够写出执行速度快且占用内存少的代码。</li></ul><h3 id="通过yield-from把多个生成器连起来用">通过yield from把多个生成器连起来用</h3><ul><li>如果要连续使用多个生成器，那么可以通过yield from表达式来风别使用这些生成器，这样做能够免去重复的for结构。</li><li>yield from的性能要胜过那种在for循环里手工编写yield表达式的方案。</li></ul><h3 id="不要用send给生成器注入数据">不要用send给生成器注入数据</h3><ul><li>send方法可以把数据注入生成器，让它成为上一条yield表达式的求值结果，生成器可以把这个结果赋给变量。</li><li>把send方法与yield from表达式搭配起来使用，可能导致奇怪的结果，例如会让程序在本该输出有效值的地方输出None。</li><li>通过迭代器向组合起来的生成器输入数据，要比采用send方法的那种方案好，所以尽量避免使用sendfangfa。</li></ul><h3 id="不要通过throw变换生成器的状态">不要通过throw变换生成器的状态</h3><ul><li>throw方法可以把异常发送到生成器刚执行过的那条yield表达式那里，让这个异常在生成器下次推进时重新抛出。</li><li>通过throw方法注入异常，会让代码变得难懂，因为需要用多成嵌套的模板结构来抛出并捕获这种异常。</li><li>如果确实遇到了这样的特殊情况，那么应该通过类的__iter__方法实现生成器，并且专门提供一个方法，让调用者通过这方法来触发这种特殊的状态变换逻辑。</li></ul><h3 id="考虑用itertools拼装迭代器与生成器">考虑用itertools拼装迭代器与生成器</h3><ul><li>itertools包里面有三套函数可以拼装迭代器与生成器，它们分别能够连接多个迭代器，过滤源迭代器中的元素，以及用源迭代器中的元素合成新元素。</li><li>通过help(itertools)查看文档，了解这些函数所支持的其他参数，以及许多更为高级的函数和实用的代码范例。</li></ul><h2 id="类与接口">类与接口</h2><h3 id="用组合起来的类来实现多层结构，不要用嵌套的内置类型">用组合起来的类来实现多层结构，不要用嵌套的内置类型</h3><ul><li>不要在字典里嵌套字典、长元组，以及用其他内置类型构造的复杂结构。</li><li>namedtuple能够实现出轻量级的容器，以存放不可变的数据，而且将来可以灵活地转化成普通的类。</li><li>如果发现用字典来维护内部状态的那些代码已经越写越复杂了，呢么就应该考虑改用多个类来实现。</li></ul><h3 id="让简单的接口接受函数，而不是类的实例">让简单的接口接受函数，而不是类的实例</h3><ul><li>如果想设计简单的Python接口，让组件之间能够通过接口交互，那么可以考虑让接口接受挂钩函数，而不一定非得定义新类，并要求使用者传入这种类的实例。</li><li>Python的函数与方法都是头等对象，这意味者它们可以像其他类型那样，用在表达式里。</li><li>某个类如果定义了__call__特殊方法，那么它的实例就可以像普通的Python函数那样调用。</li><li>如果想用函数来维护状态，那么可以考虑定义一个带有__call__方法的新类，而不要用有状态的闭包去实现。</li></ul><h3 id="通过-classmethod多态来构造同一体系中的各类对象">通过@classmethod多态来构造同一体系中的各类对象</h3><ul><li>Python只允许每个类有一个构造方法，也就是__init__方法。</li><li>如果想在超类中用通用的代码构造子类实例，那么可以考虑定义@classmethod方法，并在里面用cls(…)的形式构造具体的子类对象。</li><li>通过类方法多态机制，我们能够以通用的形式构造并拼接具体的子类对象。</li></ul><h3 id="通过super初始化超类">通过super初始化超类</h3><ul><li>Python有标准的方法解析顺序（MRO）规则，可以用来判定超类之间的初始化顺序，并解决菱形继承问题。</li><li>可以通过Python内置的super函数正确触发超类的__init__逻辑。一般情况下，不需要给这个函数指定参数。</li></ul><h3 id="考虑用mix-in类来表示可组合的功能">考虑用mix-in类来表示可组合的功能</h3><ul><li>超类最好能写成不带实例属性与__init__方法的min-in类，以避免由多重继承所引发的一些问题。</li><li>如果子类要定制（或者说修改）mix-in所提供的功能，那么可以自己的代码里面覆盖相关的实例方法。</li><li>根据需求，mix-in可以只提供实例方法，也可以只提供类方法，还可以同时提供这两种方法.</li><li>把每个mix-in所提供的简单功能组合起来，可以实现比较复杂的功能。</li></ul><h3 id="优先考虑用public属性表示应受保护的数据，不要用private属性表示">优先考虑用public属性表示应受保护的数据，不要用private属性表示</h3><ul><li>Python编译器无法绝对禁止外界访问private属性。</li><li>从一开始就应该考虑允许其他类能继承这个类，并利用其中的内部API与属性去实现更多功能，而不是把它们藏起来。</li><li>把需要保护的数据设计成protected字段，并用文档加以解释，而不要通过private属性限制访问。</li><li>只有在子类不受控制且名称有可能与超类冲突时，才可以考虑给超类设计private属性。</li></ul><h3 id="自定义的容器类型应该从collections-abc继承">自定义的容器类型应该从collections.abc继承</h3><ul><li>如果要编写的新类比较简单，那么可以直接从Python的容器类型（例如list或dict）里面继承。</li><li>如果想让定制的容器类型能像标准的Python容器那样使用，那么有可能要编写许多特殊方法。</li><li>可以从collections.abc模块里的抽象基类之中派生自己的容器类型，这样可以让容器自动具备相关的功能，同时又可以保证没有把实现这些功能所必备的方法给漏掉。</li></ul><h2 id="元类与属性">元类与属性</h2><h3 id="用纯属性与修饰器取代旧式的setter与getter方法">用纯属性与修饰器取代旧式的setter与getter方法</h3><ul><li>给新类定义接口时，应该从简单的public属性写起，避免定义setter与getter方法。</li><li>如果在访问属性时确实有必要做特殊的处理，那就通过@property来定义获取属性与设置属性的方法。</li><li>实现@property方法时，应该遵循最小惊讶原则，不要引发奇怪的副作用。</li><li>@property方法必须执行得很快。复杂或缓慢的任务，尤其是设计I/O或者会引发副作用的那些任务，还是用普通的方法来实现比较好。</li></ul><h3 id="考虑用-property实现新的属性访问逻辑，不要急着重构原有的代码">考虑用@property实现新的属性访问逻辑，不要急着重构原有的代码</h3><ul><li>可以利用@property给已有的实例属性增加新的功能。</li><li>可以利用@property逐渐改善数据模型而不影响已经写好的代码。</li><li>如果发现@property使用太过频繁，那可能就该考虑重构这个类了，同时按照旧办法使用这个类的那些代码可能也要重构。</li></ul><h3 id="用描述符来改写需要复用的-property方法">用描述符来改写需要复用的@property方法</h3><ul><li>如果像复用@property方法所实现的行为与验证逻辑，则可以考虑自己定义描述符类。</li><li>为了防止内存泄漏，可以在描述符中用WeakKeyDictionary取代普通的字典。</li><li>不要太纠结于__getattribute__是怎么通过描述符协议来获取并设置属性的。</li></ul><h3 id="针对惰性属性使用-getattr-、getattribute、-setattr-方法">针对惰性属性使用__getattr__、<strong>getattribute</strong>、__setattr__方法</h3><ul><li>如果想用自己的防护死（例如惰性地或者按需地）加载并保存对象属性，那么可以在该对象所属的类里实现__getattr__与__setattr__特殊方法。</li><li>__getattr__只会在属性缺失时触发，而__getattribute__则在每次访问属性时都要触发。</li><li>在实现__getattribute__与__setattr__的过程中，如果要使用本对象的普通属性，那么应该通过super()（也就是object类）来使用，而不要直接使用，以避免无限递归。</li></ul><h3 id="用-init-subclass-验证子类写得是否正确">用__init_subclass__验证子类写得是否正确</h3><ul><li>如果某个类时根据元类所定义的，那么当系统把该类的class语句体全部处理完之后，就会将这个类的写法告诉元类的__new__方法。</li><li>可以利用元类在类创建完成前检视或修改开发者根据这个元类所定义的其他类，但这种机制通常显得有点笨重。</li><li>__init_subclass__能够用来检查子类定义得是否合理，如果不合理，那么可以提前报错，让程序无法创建出这种子类的对象。</li><li>在分层的或者涉及多重继承的类体系里面，一定别忘了在你写的这些类的 __init_subclass__内通过 super() 来调用超类的 __init_subclass__方法，以便按照正确的顺序触发各类的验证逻辑。</li></ul><h3 id="用-init-subclass-记录现有的子类">用 __init_subclass__记录现有的子类</h3><ul><li>类注册（Class registration）是个相当有用的模式，可以用来构建模块式的Python程序。</li><li>我们可以通过基类的元类把用户从这个基类派生出来的子类自动注册给系统。</li><li>利用元类实现类注册可以防止由于用户忘记注册而导致程序出现问题。</li><li>优先考虑通过__init_subclass__实现自动注册，而不要用标准的元类机制来实现，因为__init_subclass__更清晰，更便于初学者理解。</li></ul><h3 id="用-set-name-给类属性加注解">用__set_name__给类属性加注解</h3><ul><li>我们可以通过元类把利用这个元类所定义的其他类拦截下来，从而在程序开始使用那些类之前，先对其中定义的属性做出修改。</li><li>描述符与元类搭配起来，可以形成一套强大的机制，让我们既能采用声明式的写法来定义行为，又能在程序运行时检视这个行为的具体执行情况。</li><li>你可以给描述符定义__set_name__方法，让系统把使用这个描述符做属性的那个类似以及它在类里的属性通过方法的参数告诉你。</li><li>用描述符直接操纵每个实例的属性字典，要比把所有实例的属性都放到一份字典里更好，因为后者要求我们必须使用weakref内置模块之中的特殊字典来记录每个实例的属性值以防止内存泄漏。</li></ul><h3 id="优先考虑通过类修饰器来提供可组合的扩充功能，不要使用元类">优先考虑通过类修饰器来提供可组合的扩充功能，不要使用元类</h3><ul><li>类修饰器起始就是个函数，只不过它可以通过参数获知自己所修饰的类，从而重建或调整这个类并返回修改结果。</li><li>如果要给类中的每个方法或属性都施加一套逻辑，而且还想着尽量少写一些例行代码，那么类修饰器是个很值得考虑的方案。</li><li>元类之间很难组合，而类修饰器则比较灵活，它们可以施加在同一个类上，并且不会发生冲突。</li></ul><h2 id="并发与并行">并发与并行</h2><h3 id="用subprocess管理子进程">用subprocess管理子进程</h3><ul><li>subprocess模块可以运行子进程并管理它们的输入流与输出流。</li><li>子进程能够跟Python解释器所在的进程并行，从而充分利用各CPU核心。</li><li>要开启子进程，最简单的办法就是调用run函数，另外也可以通过Popen类实现类似Unix管道的高级用法。</li><li>调用communicate方法时可以指定timeout参数，让我们有机会把陷入死锁或已经卡住的子进程关掉。</li></ul><h3 id="可以用线程执行阻塞式I-O，但不要用它做并行计算">可以用线程执行阻塞式I/O，但不要用它做并行计算</h3><ul><li>即便计算机具备多核CPU，Python线程也无法真正实现并行，因为它们会受到全局解释器锁（GIL）牵制。</li><li>虽然Python的多线程机制受GIL影响，但还是非常有用的，因为我们很容易就能通过多线程模拟同时执行多项任务的效果。</li><li>多条Python线程可以并行地执行多个系统调用，这样就能让程序在执行阻塞式的I/O任务时，继续做其他运算。</li></ul><h3 id="利用Lock防止多个线程争用同一份数据">利用Lock防止多个线程争用同一份数据</h3><ul><li>虽然Python有全局解释器锁，但开发者还是得设法避免线程之间发生数据争用。</li><li>把未经互斥锁保护的数据开放给多个线程去同时修改，可能导致这份数据的结构遭到破坏。</li><li>可以利用threading内置模块之中的Lock类确保程序中的固定关系不会在多线程环境下受到干扰。</li></ul><h3 id="用Queue来协调各线程之间的工作进度">用Queue来协调各线程之间的工作进度</h3><ul><li>管道非常适合用来安排多阶段的任务，让我们能够把每一阶段都交给各自的线程去执行，这尤其适合用在I/O密集型的程序里面。</li><li>构造这种并行的管道时，有很多问题需要注意，例如怎样防止线程频繁地查询队列状态，怎样通知线程尽快结束操作，以及怎样防止管道出现拥堵等。</li><li>我们可以利用Queue类所具有的功能来构造健壮的管道系统，因为这个类提供了阻塞式的入队（put）和出队（get）操作，而且可以限定缓冲区的大小，还能够通过task_done与join来确保所有元素都已处理完毕。</li></ul><h3 id="学会判断什么场合必须做并发">学会判断什么场合必须做并发</h3><ul><li>程序范围变大、需求变复杂之后，经常要用多条路径平行地处理任务。</li><li>fan-out与fan-in是最常见的两种并发协调（concurrency coordination）模式，前者用来生成一批新的并发单元，后者用来等待现有的并发单元全部完工。</li><li>Python提供了很多种实现fan-out与fan-in的方案。</li></ul><h3 id="不要在每次fan-out时都新建一批Thread实例">不要在每次fan-out时都新建一批Thread实例</h3><ul><li>每次都手工创建一批线程，是有很多缺点的，例如：创建并运行大量线程时的开销比较大，每条线程的内存占用量比较多，而且还必须采用Lock等机制来协调这些线程。</li><li>线程本身并不会把执行过程中遇到的异常抛给启动线程或者等待该线程完工的那个人，所以这种异常很难调试。</li></ul><h3 id="学会正确地重构代码，以便用Queue做并发">学会正确地重构代码，以便用Queue做并发</h3><ul><li>把队列（Queue）与一定数量的工作线程搭配起来，可以高效地实现fan-out（分派）与fan-in（归集）。</li><li>为了改用队列方案处理I/O，我们重构了很多代码，如果管道要分成好几个环节，那么要修改的地方会很多。</li><li>利用队列并行地处理I/O任务量有限，我们可以考虑用Python内置的某些功能与模块打造更好的方案。</li></ul><h3 id="如果必须用线程做并发，那就考虑通过ThreadPoolExecutor实现">如果必须用线程做并发，那就考虑通过ThreadPoolExecutor实现</h3><ul><li>利用ThreadPoolExecutor，我们只需要稍微调整一下代码，就能够并行地执行简单的I/O操作，这种方案省去了每次fan-out（分派）任务时启动线程的那些开销。</li><li>虽然ThreadPoolExecutor不想直接启动线程的方案那样，需要消耗大量内存，但它的I/O并行能力也是有限的。因为它能够使用的最大线程数需要提前通过max_workers参数指定。</li></ul><h3 id="用协程实现高并发I-O">用协程实现高并发I/O</h3><ul><li>协程时采用async关键字所定义的函数。如果你想执行这个协程，但并不要钱立刻就获得执行结果，而是稍后再来获取，那么可以通过await关键字表达这个意思。</li><li>协程能够制造出一种效果，让人以为程序里有成千上万个函数都在同一时刻高效地运行着。</li><li>协程可以用fan-out与fan-in模式实现并行的I/O操作，而且能够克服用线程做I/O时的缺陷。</li></ul><h3 id="学会用asyncio改写那些通过线程实现的I-O">学会用asyncio改写那些通过线程实现的I/O</h3><ul><li>Python提供了异步版本的for循环、with语句、生成器与推导机制，而且还有很多辅助的库函数，让我们能够顺利地迁移到协程方案。</li><li>我们很容易就能利用内置的asyncio模块来改写代码，让程序不要再通过线程执行阻塞式的I/O，而是改用协程来执行异步I/O。</li></ul><h3 id="结合线程与协程，将代码顺利迁移到asyncio">结合线程与协程，将代码顺利迁移到asyncio</h3><ul><li>asyncio模块的事件循环提供了一个返回awaitable对象的run_in_executor方法，它能够使协程把同步函数放在线程池执行期（ThreadPoolExecutor）里面执行，让我们可以顺利地将采用线程方案所实现的项目，从上至下地迁移到asyncio方案。</li><li>asyncio模块的事件循环还提供了一个可以再同步代码里面调用的run_until_complete方法，用来运行协程并等待其结束。它的功能跟asyncio.run_coroutine_threadsafe类似，只是后者面对的时跨线程的场合，而前者是为同一个线程设计的。这些都有助于将采用线程方案所实现的项目从下至上地迁移到asyncio方案。</li></ul><h3 id="让asyncio的事件循环保持畅通，以便进一步提升程序的响应能力">让asyncio的事件循环保持畅通，以便进一步提升程序的响应能力</h3><ul><li>把系统调用（包括阻塞式的I/O以及启动线程等操作）放在协程里面执行，会降低程序的响应能力，增加延迟感。</li><li>调用async.run时，可以把debug参数设为True，这样能够知道哪些协程降低了事件循环的反应速度。</li></ul><h3 id="考虑用concurrent-futures实现真正的并行计算">考虑用concurrent.futures实现真正的并行计算</h3><ul><li>把需要耗费大量CPU资源的计算任务改用C扩展模块来写，或许能够有效提高程序的运行速度，同时又让程序里的其他代码依然能够利用Python语言自身的特性。但是，这样做的开销比较大，而且容易引入bug。</li><li>Python自带的multiprocessing模块提供了许多强大的工具，让我们只需要耗费很少的精力，就可以把某些类型的任务平行地放在多个CPU核心上面处理。</li><li>要想发挥出multiprocessing模块的优势，最好是通过concurrent.futures模块及其ProcessPoolExecutor类来编写代码，因为这样做比较简单。</li><li>只有在其他方案全都无效的情况下，才可以考虑直接使用multiprocessing里面的高级功能（那些功能用起来相当复杂）。</li></ul><h2 id="稳定与性能">稳定与性能</h2><h3 id="合理利用try-except-else-finally结构种的每个代码块">合理利用try/except/else/finally结构种的每个代码块</h3><ul><li>try/finaly形式的复合语句可以确保，无论try块是否抛出异常，finally块都会得到运行。</li><li>如果某段代码应该再前一段代码顺利执行之后加以运行，那么可以把它放到else块里面，而不要把这两段代码全都写在try块之中。这样可以让try块更加专注，同时也能够跟except块形成明确对照；except块写的时try块没有顺利执行时所要运行的代码。</li><li>如果你要在某段代码顺利执行之后多做一些处理，然后再清理资源，那么通常可以考虑把这三段代码分别放在try、else与finally块里。</li></ul><h3 id="考虑用contextlib和with语句来改写可复用的try-finally代码">考虑用contextlib和with语句来改写可复用的try/finally代码</h3><ul><li>可以把try/finally逻辑风撞到情境管理器里面，这样就能通过with结构反复运用这套逻辑，而不需要每次用到的适合，都手工打一遍代码。</li><li>Python内置的contextlib模块提供了contextmanager修饰器，让我们可以很方便地修饰某个函数，从而制作出相对应的情境管理器，舍得这个函数能够运用再with语句里面。</li><li>情境管理器通过yield语句所产生的值，可以由with语句之中位于as右侧的那个变量所接收，这样的话，我们就可以通过该变量与当前情境相交互了。</li></ul><h3 id="用datetime模块处理本地事件，不要用time模块">用datetime模块处理本地事件，不要用time模块</h3><ul><li>不要用time模块再不同时区之间转换。</li><li>把Python内置的datetime模块与开发者社群提供的pytz模块结合起来，可以在不同时区之间可靠地转换。</li><li>在操纵事件数据的过程种，总是应该使用UTC时间，只有到了最后一步，才需要把它转回当地时间以便显示出来。</li></ul><h3 id="用copyreg实现可靠的pickle操作">用copyreg实现可靠的pickle操作</h3><ul><li>Python内置的pickle模块，只适合用来再彼此信任的程序之间传递数据，以实现对象的序列化与反序列化功能。</li><li>如果对象所在的这个类发生了变化（例如增加或删除了某些属性），那么程序在还原旧版数据的时候，可能会出现错误。</li><li>把内置的copyreg模块与pickle模块搭配起来使用，可以让新版的程序兼容旧版的序列化数据。</li></ul><h3 id="在需要准确计算的场合，用decimal表示相应的数值">在需要准确计算的场合，用decimal表示相应的数值</h3><ul><li>每一种数值几乎都可以用Python内置的某个类型，或者内置模块之中的某个类表示出来。</li><li>在精度要求较高且需要控制舍入方式的场合（例如在计算费用的时候），可以考虑使用Decimal类。</li><li>用小数构造Decimal时，如果想保证取值准确，那么一定要把这个数放在str字符串里面传递，而不要直接传过去，那样可能有误差。</li></ul><h3 id="先分析性能，然后再优化">先分析性能，然后再优化</h3><ul><li>优化Python程序之前，一定要先分析它的性能，因为导致程序速度缓慢的真正原因未必与我们想的一样。</li><li>应该优先考虑用cProfile模块来分析性能，而不要用profile模块，因为前者得到的分析结果更加准确。</li><li>把需要接收性能测试的主函数传给Profile对象的runcall方法，就可以专门分析出这个体系下面所有函数的调用情况了。</li><li>可以通过Stats对象筛选出我们关心的那些分析结果，从而更加为专注地思考如何优化程序性能。</li></ul><h3 id="优先考虑用deque实现生产者-消费者队列">优先考虑用deque实现生产者-消费者队列</h3><ul><li>list类型可以用来实现FIFO队列，生产者可以通过append方法向队列添加元素。但这种方案有个问题，就是消费者在用 pop(0) 从队列中获取元素时，所花的时间会随着队列长度，呈平方式增长。</li><li>跟list不同，内置collections模块种的deque类，无论时通过append添加元素，还是通过popleft获取元素，所花的时间都只跟队列长度呈现性关系，而非平方关系，这使得它非常适合于FIFO队列。</li></ul><h3 id="考虑用bisect搜索已排序的序列">考虑用bisect搜索已排序的序列</h3><ul><li>用index方法在已经排好顺序的列表之中查找某个值，花费的时间与列表长度成正比，通过for循环单纯地做比较以寻找目标值，所花的时间也是如此。</li><li>Python内置的bisect模块里面有个bisect_left函数，只需要花费对数级别的时间就可以在有序列表中搜寻某个值，这要比其他方法快好几个数量级。</li></ul><h3 id="学会使用heapq制作优先级队列">学会使用heapq制作优先级队列</h3><ul><li>优先级队列让我们能够按照重要程度来处理元素，而不是必须按照先进先出的顺序处理。</li><li>如果直接用相关的列表操作来模拟优先级队列，那么程序的性能会随着队列长度的增大这大幅下降，因为这样做的复杂程度是平方级别，而不是线性级别。</li><li>通过Python内置的heapq模块所提供的函数，我们完全可以实现基于堆的优先级队列，从而高效地处理大量数据。</li><li>要使用heapq模块，我们必须让元素所在的类型支持自然排序，这可以通过对类套用@functools.total_ordering修饰器并定义__lt__方法来实现。</li></ul><h3 id="考虑用memoryview与bytearray来实现无须拷贝的bytes操作">考虑用memoryview与bytearray来实现无须拷贝的bytes操作</h3><ul><li>Python内置的memoryview类型提供了一套无须执行拷贝的（也就是零拷贝）操作接口，让我们可以对支持缓冲协议的Python对象制作切片，并通过这种切片高速地完成读取与写入。</li><li>Python内置的bytearray类型是一种与bytes相似但内容能够改变的类型，我们可以通过socket.reccv_from这样的函数，以无需拷贝的方式（也就是零拷贝的方式）读取数据。</li><li>我们可以用memoryview来封装bytearray，从而用收到的数据覆盖底层缓冲里面的任意区段，同时又无需执行拷贝操作。</li></ul><h2 id="测试与调试">测试与调试</h2><h3 id="通过repr字符串输出调试信息">通过repr字符串输出调试信息</h3><ul><li>把内置类型的值传给print，会打印出便于认读的那种字符串，但是其中不会包含类型信息。</li><li>把内置类型的值传给repr，会得到一个能够表示该值的可打印字符串，将这个repr字符串传给内置的eval函数能够得到原值。</li><li>在格式化字符串里用%s处理相关的值，就跟把这个值传给str函数一样，都能得到一个便于认读的那种字符串。如果用%r来处理，那么得到的就是repr字符串。在f-string中，也可以用值来取代其中有待替换的那一部分，并产生便于认读的那种字符串，但如果待替换的部分加了!r后缀，那么替换出来的就是repr字符串。</li><li>给类定义__repr__特殊方法，可以让print函数把该类实例的可打印表现形式展现出来，在实现这个方法时，还可以提供更为详尽的调试信息。</li></ul><h3 id="在TestCase子类里验证相关的行为">在TestCase子类里验证相关的行为</h3><ul><li>Python内置的unittest模块里有个TestCase类，我们可以定义它的子类，并在其中编写多个test方法，以便分别验证想要测试的每一种行为。TestCase子类的这些test方法名称都必须以test这个词开头。</li><li>TestCase类还提供了许多辅助方法，例如，可以在test方法中通过assertEqual辅助方法来确认两个值相等，而不采用内置的assert语句。</li><li>可以用subTest辅助方法做数据驱动测试，这样就不用针对每项子测试重复编写相关的代码与验证逻辑了。</li></ul><h3 id="把测试前、后的准备与清理逻辑写在setUp、tearDown、setUpModule、tearDownModule中，以防用例之间互相干扰">把测试前、后的准备与清理逻辑写在setUp、tearDown、setUpModule、tearDownModule中，以防用例之间互相干扰</h3><ul><li>单元测试验证的是每项功能本身是否正常，集成测试验证的是模块之间能否正确交互，这两种测试都很重要。</li><li>把测试用例的准备与清理工作分别放在setUp与tearDown方法中，可以避免用例之间相互干扰，使它们都能从一套干净的环境开始执行。</li><li>集成测试的准备与清理工作可以放在模块级别的setUpModule与tearDownModule函数里，系统在测试该模块与其中所有TestCase子类的过程中，只会把这两个函数各自运行一遍。</li></ul><h3 id="用Mock来模拟受测试代码所依赖的复杂函数">用Mock来模拟受测试代码所依赖的复杂函数</h3><ul><li>unittest.mock模块中的Mock类能够模拟某个接口的行为，我们可以用它替换受测试函数所要调用的接口，因为那些接口可能不太容易在测试的过程种配置。</li><li>如果用mock把手册代码所依赖的函数替换掉了，那么在测试的时候，不仅要验证受测代码的行为，而且还要验证它有没有正确地调用这些mock，这可以通过Mock.assert_called_once_with等一系列方法实现。</li><li>要想把受测函数所调用的其他函数用mock逻辑替换掉，一种办法是给受测函数设计只能以关键字来指定的参数；另一种办法是通过unittest.mock.patch系列的方法暂时隐藏那些函数。</li></ul><h3 id="把受测代码所依赖的系统封装起来，以便于模拟和测试">把受测代码所依赖的系统封装起来，以便于模拟和测试</h3><ul><li>在写单元测试的时候，如果总是要反复使用许多代码来注入模拟的逻辑，那么可以考虑把受测函数所要用到的逻辑封装到类中，因为封装之后更容易注入。</li><li>Python内置的unitest.mock模块里有个Mock类，它能模拟类的实例，这种Mock对象具备与原类中的方法相对应的属性。如果在它上面调用某个方法，就会触发相应的属性。</li><li>如果想把程序完整的测一遍，那么可以重构代码，在原类直接使用复杂系统的地方引入辅助函数，让程序通过这些函数来获取它要用的系统，这样我们就可以通过辅助函数注入模拟逻辑。</li></ul><h3 id="考虑用pdb做交互调试">考虑用pdb做交互调试</h3><ul><li>在程序里某个兴趣点直接调用Python内置的breakpoint函数就可以触发交互调试器。</li><li>Python的交互调试界面（即pdb界面）也是一套完整的Python执行环境，在它里面我们可以检查正在运行的程序处于什么状态，并予以修改。</li><li>我们可以在pdb界面里用相关的命令精确地控制程序的执行方式，这样就能做到一边检查状态，一边推进程序了。</li><li>pdb模块还能够在程序出现错误的时候检查该程序的状态，这可以通过 <code>python -m pdb -c continue &lt;program path&gt;</code> 命令实现，也可以在普通的Python解释器界面运行受测程序，等到出现问题，再用<code>import pdb; pdb.pm()</code>切换至调试界面。</li></ul><h3 id="用tracemalloc来掌握内存的使用与泄漏情况">用tracemalloc来掌握内存的使用与泄漏情况</h3><ul><li>不借助相关的工具，我们可能很难了解Python程序是怎样使用内存的，以及其中有些内存又是如何泄漏的。</li><li>gc模块可以帮助我们了解垃圾回收器追踪到了哪些对象，但它并不能告诉我们那些对象是如何分配的。</li><li>Python内置的tracemalloc模块提供了一套强大的工具，可以帮助我们更好地了解内存的使用情况，并找到这些内存分别由哪一行代码所分配。</li></ul><h2 id="协作开发">协作开发</h2><h3 id="学会寻找由其他Python开发者所构建的模块">学会寻找由其他Python开发者所构建的模块</h3><ul><li>Python Package Index（PyPI） 含有许多常用的软件包，这些都是由广大Python开发者构建并维护的。</li><li>可以用pip命令行工具从PyPI里面安装软件包。</li><li>大多数PyPI模块都是自由及开源软件。</li></ul><h3 id="用虚拟环境隔离项目，并重建依赖关系">用虚拟环境隔离项目，并重建依赖关系</h3><ul><li>我们可以在每个虚拟环境里面，分别用pip命令安装它所需要的软件包，这样的话，同一台电脑中就可以存在许多互不冲突的环境了。</li><li><code>python3 -m venv</code> 命令可以创建虚拟环境，<code>source bin/activate与deactivate</code>命令分别可以启动与禁用该环境。</li><li><code>python3 -m pip freeze &gt; requirements.txt</code> 命令可以把当前环境所依赖的软件包保存到文件之中，之后可以通过 <code>python3 -m pip install -r requirements.txt</code> 在另一套环境里面重新安装这些包。</li></ul><h3 id="每一个函数、类与模块都要写docstring">每一个函数、类与模块都要写docstring</h3><ul><li>每个模块、类、方法与函数都应该编写docstring文档，并且要与实现代码保持同步。</li><li>模块的docstring要介绍本模块的内容，还要指出用户必须了解的关键类与重要函数。</li><li>类的docstring要写在class语句的正下方，描述本类的行为与重要的属性，还要指出子类应该如何正确地继承这个类。</li><li>函数与方法的docstring要写在def语句的正下方，描述本函数的每个参数、函数的返回值，可能抛出的异常以及其他相关的行为</li><li>如果某些信息已经通过类型注解表达过了，那就不要在docstring里面重复。</li></ul><h3 id="用包来安排模块，以提供稳固的API">用包来安排模块，以提供稳固的API</h3><ul><li>Python的包是一种包含其他模块的模块。这种结构让我们可以把代码划分成多个互不冲突的名称空间，即便两个实体同名，也能用它们所属的模块加以区分。</li><li>如果要构建的包比较简单，那就把其中每个模块所对应的源文件都直接放在本包的目录下，并给目录里面创建一份__init__.py文件。这样的话，这些源文件所表示的模块就会成为本包的子模块。这个目录里还可以创建子目录，以构建其他包。</li><li>如果想限制外界通过引入该模块能够访问到哪些API，那么可以把这些API的名称写在__all__这个特殊的属性里面。</li><li>如果不想让外界看到某些内容，那么可以在包目录中的__init__.py文件里面故意不引入这些内容，或者给这些只供本包内部使用的内容名称前面添加下划线。</li><li>假如这个包只在某个团队或某个项目内部使用，那恐怕就没必要专门通过__all__来指定外界能够访问到的API了。</li></ul><h3 id="考虑用模块级别的代码配置不同的环境">考虑用模块级别的代码配置不同的环境</h3><ul><li>程序通常需要部署到许多种环境里面，无论在哪一种环境之中运行程序，都必须先准备好相关的资源，并做出适当的配置。</li><li>可以像编写普通的Python语句那样，直接在模块作用域书写配置逻辑，以定制该模块的内容，从而针对不同的环境做出适当的部署。</li><li>还可以根据其他一些外部因素来调整模块的内容，例如通过sys或os模块查询与操作系统相关的信息，并据此定制该模块。</li></ul><h3 id="为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常">为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常</h3><ul><li>给模块定义根异常，可以让使用这个模块的API用户将它们自己的代码与这个模块所提供的API隔开，以便分别处理其中的错误。</li><li>API用户在处理完API所属模块由可能抛出的具体异常后，可以写一个针对模块根异常的except块，如ugochengxu进入这个块，那就说明他使用API的方式可能有问题，例如可能忘记处理某种本来应该处理的具体异常。</li><li>API用户还可以再写一个except块以捕获整个Python体系之中的根异常，如果程序进入了那个块，那说明所调用的API可能实现得有问题。</li><li>在模块的根异常下，可以设立几个门类，让具体的异常不要直接集成总的根异常，而是继承各自门类种的那个分根异常，这样的话，使用这个模块的开发者，就可以只关注这几个门类，即便你修改了某个门类至下的具体异常，也不会影响到他们已经写好的那些代码。</li></ul><h3 id="用适当的方式打破循环依赖关系">用适当的方式打破循环依赖关系</h3><ul><li>如果两个模块都要在开头引入对方，那就会形成循环依赖，这有可能导致程序在启动的时候崩溃。</li><li>要想达阔依赖循环，最好的办法是把这两个模块都要用到的那些代码重构到整个依赖体系的最底层。</li><li>如果不想大幅度重构代码，也不想让代码变得太复杂，那么最简单的方案是通过动态引入来消除循环依赖关系，但尽量避免使用。</li></ul><h3 id="重构时考虑通过warnings提醒开发者API已经发生变化">重构时考虑通过warnings提醒开发者API已经发生变化</h3><ul><li>设计新版API的时候，可以通过warnings模块把已经过时的用法通知到调用者，让他们看到消息后尽快改用新的方法，以防程序在我们彻底放弃旧版API之后崩溃。</li><li>在命令行界面执行Python解释器的时候，可以开启-W error选项，从而将警告视为错误。这在执行自动测试的过程种特别有用，因为这样可以及时发现受测程序所依赖的API是否已经推出了新的版本。</li><li>如果程序要部署到生产环境，那么可以通过logging模块将警告信息重定向到日志系统，把程序在运行过程中遇到的警告纳入现有的错误报告机制中。</li><li>如果你设计的API会发出警告，那么应该为此编写测试，确保下游开发者在使用API的过程中，能够在适当的时机收到正确的警告信息。</li></ul><h3 id="考虑通过typing做静态分析，以消除bug">考虑通过typing做静态分析，以消除bug</h3><ul><li>Python提供了内置的typing模块与一套特殊的写法，可以给变量、字段、函数与方法标注类型信息。</li><li>静态类型检查工具可以利用标注的类型信息检查出许多常见的bug，而不用让它们到程序运行的时候再暴露。</li><li>合理地使用注解<ul><li>如果刚开始写代码的时候，就想着如何添加类型注解，那可能会拖慢编程速度。所以我们通常应该先把代码本身写出来，然后编写测试，最好才考虑在必要的地方添加类型信息。</li><li>类型提示信息最能发挥作用的地方，是在项目与项目衔接处。</li><li>如果有些代码比较复杂，或者特别容易出错，那么即便不属于API，也仍然值得添加类型提示信息。但是要注意，没必要给所有的代码都添上类型注解，因为到了一定程度之后，再添加这种信息，就不会给项目带来太大的好处。</li><li>如果有可能的话，应该把静态分析这一环节纳入自动构建流程与测试系统中，以确保提交上去的每份代码都会经受相关的检查。另外，检查类型信息所用的配置方案，应该放在代码库里面维护，以保证其他的合作者使用的也是这套规则。</li><li>每添加一批类型注解，就应该把静态分析工具运行一遍，这样可以及时发现问题并加以解决。假如把整个项目全部注解完之后，再实施类型检查，那么类型分析工具就有可能打印出极多的错误信息，让你不知到应该先处理哪一条才好，有时甚至会让你想要放弃类型注解。</li><li>有许多场合是不需要写类型注解的，如小型程序、临时代码、遗留项目以及原型等</li></ul></li></ul><h2 id="Reference">Reference</h2><p>[1] <a href="https://book.douban.com/subject/35334595/" target="_blank" rel="noopener">Effective Python</a></p>]]></content>
    
    <summary type="html">
    
      “编写高质量Python代码”。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
  </entry>
  
  <entry>
    <title>低碳水饮食</title>
    <link href="https://neo1989.net/SeizeTheDay/HEALTH-low-carb-diet/"/>
    <id>https://neo1989.net/SeizeTheDay/HEALTH-low-carb-diet/</id>
    <published>2021-05-10T09:35:28.000Z</published>
    <updated>2021-05-10T10:13:05.798Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>想减肥，但又吃惯了传统的高碳低脂饮食，一下子要改成低碳水化合物饮食，很多人不清楚到底该怎么吃？哪些食物能吃，哪些应该尽量避免？</p></blockquote><h2 id="低碳水饮食食材清单">低碳水饮食食材清单</h2><h3 id="能吃的">能吃的</h3><ul><li><p>✅ 任何肉类：牛肉、猪肉、羊肉、家禽、野味等。脂肪和肉皮（鸡皮）都可以随便吃。 如果是草饲的最好。</p></li><li><p>✅ 鱼类和海鲜：包括富含Omega-3脂肪酸的鲑鱼，鲭鱼、沙丁鱼或鲱鱼等脂肪鱼。</p></li><li><p>✅ 蛋类：鸡蛋、鸭蛋、鹅蛋、鹌鹑蛋等，非人工饲养的草饲蛋类（柴鸡蛋）最好。</p></li><li><p>✅ 健康脂肪：椰子油、橄榄油、草饲黄油。</p></li><li><p>✅ 蔬菜：地面上生长的蔬菜，如：西兰花、羽衣甘蓝、菠菜、菜花、卷心菜、白菜、芹菜、芦笋、西葫芦、茄子、黄瓜、西红柿、菌类，以及其他十字花科蔬菜。</p></li><li><p>地下生长的蔬菜一般含有较高碳水化合物，例如土豆、红薯、胡萝卜等，只能偶尔吃一些。</p></li><li><p>✅ 乳制品：动物黄油、奶油（含40%脂肪）、酸奶油（sour cream）、无糖全脂酸奶、奶酪等。</p></li><li><p>要小心普通牛奶，不管是全脂还是脱脂的，其中都含有糖分。</p></li><li><p>✅ 坚果：碳水含量低的坚果可以偶尔当作零食，包括：核桃、巴西坚果、澳洲坚果、榛子、花生、杏仁。</p></li><li><p>✅ 水果：某些浆果类可以适量吃，例如：草莓、黑莓、覆盆子。</p></li><li><p>✅ 黑巧克力：纯度在70%以上的黑巧克力可以偶尔吃。</p></li></ul><h3 id="能喝的">能喝的</h3><ul><li><p>✅ 水：白开水是最好的饮料，加了柠檬汁或黄瓜汁的水也没问题。</p></li><li><p>✅ 茶：绿茶、抹茶，只要是不加糖的都可以。</p></li><li><p>✅ 咖啡：不加糖和奶精的黑咖啡。</p></li></ul><h3 id="尽量避免的">尽量避免的</h3><ul><li><p>❌ 甜食：包括各种糕点、饼干、冰激淋、糖果、果汁、软包装饮料、碳酸饮料、牛奶巧克力等含糖饮食。</p></li><li><p>❌ 淀粉类：精制米、面及其制品，面条、面包、炸薯条、薯片、爆米花等。</p></li><li><p>❌ 酒精饮料：啤酒、白酒。干红葡萄酒可以偶尔少量饮用。</p></li><li><p>❌ 水果：大多数的水果都含有大量的糖分和碳水化合物，不易多吃。</p></li><li><p>❌ 人造黄油、人造奶油：它们含有大量的ω-6脂肪酸，这种脂肪吃多了会引起身体炎症。</p></li><li><p>❌ 加工食品：任何带包装，标签上有很多成分（添加剂）的食物都不应多吃。</p></li></ul><h2 id="学生党和上班族怎么吃？">学生党和上班族怎么吃？</h2><h3 id="食堂">食堂</h3><p>食堂中最不缺的就是碳水，一不留神就吃爆表。</p><ul><li><p>多吃或只吃炒菜：各种青菜，炒肉菜，换着花样吃；</p></li><li><p>多吃蛋白质：瘦肉、鱼肉、蛋类、豆制品；</p></li><li><p>多吃健康脂肪：带皮的猪肉、鸡肉、红烧肉、回锅肉、猪肘子；</p></li><li><p>各种淀粉少的汤：鸡汤、骨头汤、紫菜汤；</p></li><li><p>水果：几颗圣女果、蓝莓、覆盆子、草莓</p></li><li><p>可以适量吃抗性淀粉：比如一小块儿红薯、土豆、胡萝卜、玉米、燕麦粥；</p></li><li><p>避免含淀粉和糖的菜：比如四喜丸子、糖醋排骨、炸鸡翅、裹面的炸鱼等；</p></li><li><p>不吃米、面：包括面条、面包、大米粥、米饭；</p></li><li><p>不吃甜食、不喝含糖饮料；</p></li></ul><h3 id="快餐外卖">快餐外卖</h3><p>很多上班族除了吃食堂以外，还会点外卖，尽管没有办法保证能完全按照自己的心意来做，但仍然可以通过下面这几个方法来尽量吃得健康。</p><ul><li><p>点餐时备注少放油、少放盐、少放糖；</p></li><li><p>自带橄榄油、椰子油、奶酪片、牛油果；</p></li><li><p>多点肉类炒菜、沙拉；</p></li><li><p>不点主食，用菜代替；</p></li><li><p>不买饮料和甜食；</p></li></ul><h3 id="自助餐">自助餐</h3><p>吃自助餐可以自己做主，只选择那些更健康的食物和饮料。</p><p>各种蔬菜、肉类、鱼类、蛋类、奶酪等都可以。</p><p>不吃主食、不喝含糖和酒精饮料，不吃甜食。</p><h2 id="生酮饮食">生酮饮食</h2><p>生酮饮食，是一种“高”脂肪、“中”蛋白质、“低”碳水化合物的饮食方式，目的是让你的身体处于称为酮症的代谢状态，从而燃烧脂肪，而不是碳水化合物。</p><p>生酮饮食最初被用于治疗儿童癫痫，近年来也用来辅助治疗其他神经系统疾病、睡眠障碍、双相情感障碍、自闭症、甚至脑癌。</p><p><strong>75% 脂肪 + 20% 蛋白质 + 5% 碳水</strong></p><p>生酮饮食是一种严格的低碳水饮食，作为短期快速减肥的方法，它的效果很明显，但是<em>长期生酮的安全性目前来说仍没有定论</em>。</p><h3 id="生酮饮食的工作原理">生酮饮食的工作原理</h3><p>正常情况下，碳水化合物经人体吸收后会转化为葡萄糖并被当成能量运送到身体各处，尤其是用于维持大脑的正常运作。</p><p>而生酮饮食中只摄取极少量的碳水化合物，身体得不到足够的糖原来提供能量，肝脏就会将脂肪分解为脂肪酸和酮体。其中，酮体会代替葡萄糖进入血液，运往全身，成为主要的能量来源。</p><p>这个过程中，血液中的血糖含量会迅速下降，酮体水平会升高，身体进入营养性酮症状态。而一旦身体转换为这种新的代谢方式，就会开始燃烧脂肪。</p><p>达到生酮状态需要几天时间，这期间必须严格按照生酮饮食的比例来吃，即：碳水化合物5%，蛋白质20%，健康脂肪75%。</p><h3 id="生酮饮食的不良反应">生酮饮食的不良反应</h3><p>在最初阶段，大多数人都会出现身体不适，因为症状类似于流感和感冒，所以被称为“酮流感”。</p><p>主要表现包括：</p><ul><li>疲倦、乏力</li><li>头晕、头疼</li><li>口臭</li><li>胃部不适</li><li>腹泻或便秘</li><li>脱发</li><li>失眠</li><li>情绪不稳</li><li>酮疹（不多见）</li></ul><p>出现这些症状的原因是身体正在适应新的代谢方式。通常来说，这些不适感会在两三周之内消失。</p><h3 id="生酮饮食能吃什么？">生酮饮食能吃什么？</h3><p>这种饮食方式的特点是，吃大量的健康脂肪，例如：椰子油、牛油果油、橄榄油、草饲黄油等；以及适量的蛋白质，如：鸡蛋、瘦肉、鱼、虾等；碳水化合物主要从低碳水蔬菜、水果和坚果中获得。</p><p>因为脂肪和蛋白质含量更高，因此会明显增加饱足感，同时减少食欲和进食量。</p><h3 id="什么是净碳水（Net-Carbs）">什么是净碳水（Net Carbs）</h3><p>当我们说每天只能吃5%（20-50克）的碳水化合物时，指的是<strong>净碳水</strong>，这是相对于总碳水含量来说的。</p><p>净碳水化合物是食物中总碳水化合物的克数减去其总纤维的克数。因为身体不能消化纤维，所以它不计入碳水摄入量。</p><p><strong>总碳水化合物 – 总纤维 = 净碳水化合物</strong></p><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://lowcarbfasthealth.com/" target="_blank" rel="noopener">低碳坊</a></p>]]></content>
    
    <summary type="html">
    
      健康饮食
    
    </summary>
    
    
      <category term="SeizeTheDay" scheme="https://neo1989.net/categories/SeizeTheDay/"/>
    
    
      <category term="Health" scheme="https://neo1989.net/tags/Health/"/>
    
  </entry>
  
  <entry>
    <title>《超级自控力》</title>
    <link href="https://neo1989.net/Notes/NOTE-super-self-control/"/>
    <id>https://neo1989.net/Notes/NOTE-super-self-control/</id>
    <published>2021-04-21T07:05:36.000Z</published>
    <updated>2023-01-13T03:04:45.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打造远离拖延的环境">打造远离拖延的环境</h2><h3 id="保持办公桌的干净整洁-–-断舍离">保持办公桌的干净整洁 – 断舍离</h3><ul><li>各种书籍、文件分类摆放</li><li>利用一些文具，诸如笔筒、书立、文件夹等</li><li>定时筛选、丢掉废弃纸质文件和其他垃圾</li><li>保留必须物品，其他的全部扔掉或者赠送给有需要的人</li></ul><h3 id="收起那些耽误正事的杂物">收起那些耽误正事的杂物</h3><ul><li>工作时手机关机（静音），必要时用电脑登录社交软件</li><li>卸载非必要APP，同种类型的只留下最好的那个</li><li>如果每天有大量信息需要处理，可以规划好每天固定的时间回复消息</li><li>不断进行心理暗示，不要在无聊的事情上浪费时间</li></ul><h3 id="远离假装努力的积极废人">远离假装努力的积极废人</h3><ul><li>少立flag</li><li>不要用战略上勤奋掩盖战术上的懒惰</li><li>主动远离懒惰、不自律者</li></ul><h3 id="让自己的生活尽量规律化">让自己的生活尽量规律化</h3><blockquote><p>真正规律化的生活是，在特定的时间做特定的事情，不要让一件事情上的焦虑影响另外一件事情的进行。</p></blockquote><ul><li>制定计划，合理分配时间</li><li>给自己留出独立的工作时间，减少干扰因素</li><li>将休闲娱乐与工作学习明确划分开</li><li>设置自我奖励机制，按时作息就奖励自己一个小礼物</li><li>让家人或朋友帮忙监督</li><li>利用好碎片化时间处理未完成的事情</li><li>睡前将手机等电子产品关机并收纳到抽屉里</li></ul><h3 id="及时疏解内在的消极情绪">及时疏解内在的消极情绪</h3><ul><li>倾诉，给压抑的心情一个出口</li><li>进行自我审视，找出消极情绪的根源</li><li>积极寻找帮助，切实解决问题</li><li>通过做自己喜欢的事情来打退消极情绪</li></ul><h3 id="多跟优秀自律的人在一起">多跟优秀自律的人在一起</h3><ul><li>跳出原本的惰性生活状态，主动向优秀的同事、朋友请教</li><li>利用互联网及时了解行业信息</li><li>关注行业中的佼佼者，通过互联网平台汲取经验</li><li>适当参加一些业内成功人士的分享活动</li><li>大胆迈出第一步，主动结识优秀者</li></ul><h2 id="设立有切实意义的目标">设立有切实意义的目标</h2><h3 id="用目标改变虚耗精力的状态">用目标改变虚耗精力的状态</h3><blockquote><p>“目标的坚定是性格中最必要的力量源泉之一，也是成功的利器之一，没有它，天才也会在矛盾屋顶的迷径中，徒劳无功”</p></blockquote><ul><li>你想在哪个领域获得成功</li><li>具体想得到什么样的收获</li><li>为了实现这个目标你要完成哪些事情</li><li>把这个事情分摊下来，每一天需要完成多少</li><li>思考在完成这件事情的过程中可能遇到的阻碍</li><li>你可能会因为什么原因放弃目标</li><li>怎样克服实现目标过程中的困难和阻碍因素</li><li>如果发现目标不恰当该如何调整</li><li>除了当前方案外是否还有plan B</li><li>你需要和谁一起完成这个目标</li></ul><h3 id="掌握指定目标的SMART原则">掌握指定目标的SMART原则</h3><ul><li>S（specific）： 明确性，不能笼统和抽象</li><li>M（measurable）：衡量性，即需要量化</li><li>A（attainable）：可实现性，目标不可过高或过低，要适量</li><li>R（realistic）：相关性，与主要目标要相关</li><li>T（time bound）：时限性，即完成目标的时间期限</li></ul><h3 id="为目标附加Deadline">为目标附加Deadline</h3><ul><li>番茄钟</li><li>设立deadline，不可太过迟缓，也不能操之过急</li></ul><h3 id="把大目标分解成小目标">把大目标分解成小目标</h3><blockquote><p>“每一步都走向一个最终要到达的目标，这并不够，应该每一站都有一个目标，每一步都有自有价值。”</p></blockquote><ul><li>把漫长的征途划分为一段一段，每当你到达一站的时候心理都会充满无尽的欢喜，然后充满激情的冲向下一站。</li></ul><h3 id="每天都要有可实现的目标">每天都要有可实现的目标</h3><blockquote><p>“合抱之木，生于毫末；九层之台，起于垒土；千里之行，始于足下。”</p></blockquote><h3 id="列好实现目标的具体步骤">列好实现目标的具体步骤</h3><ul><li>你想要实现什么样的目标？</li><li>为了实现这个目标你需要花多长时间？</li><li>要想实现这个目标你需要做哪些事情？</li><li>第一步是什么，需要在什么时间完成？</li><li>第二步，第三步，以及后续呢？</li><li>你的早晨、睡前这两个黄金时间如何安排？</li><li>如何完成这些具体的、细小的步骤？</li><li>当你遇到瓶颈的时候要怎么解决，咨询专业人士、上网查询资料或是其他？</li></ul><h3 id="有变动及时调整目标">有变动及时调整目标</h3><blockquote><p>一个正确的目标给人的动力是巨大的，而错误的目标却会把我们引入错误的方向，方向错，步步错。</p></blockquote><ul><li>有变动时，及时调整目标。</li></ul><h2 id="成为高校的行动派">成为高校的行动派</h2><h3 id="改掉习惯性担忧的毛病">改掉习惯性担忧的毛病</h3><blockquote><p>担忧可以归纳为：为已经发生的事情而担忧；为还没有发生的事情而担忧；担忧付出了努力却得不到满意的结果。</p></blockquote><ul><li>给自己心理暗示：担忧是无用的</li><li>找到担忧的原因，即：你面临着什么问题</li><li>思考解决问题的办法</li><li>明白这样一个道理：已经发生的事情，担忧没有用；还未发生的事情尚有时间想办法补救，担忧没有必要；努力了却不一定能成功的事情，做到内心无悔即可。</li><li>从生理上减缓担忧：运动、呼吸新鲜空气、拥有充分的睡眠和健康的饮食。</li><li>珍爱身边的朋友，建立积极的社交关系，可以向朋友诉说自己的担忧和苦恼</li><li>把目光放长远，保持心胸豁达</li><li>以一种平淡随然的态度面对生活</li></ul><h3 id="想做一件事立刻就行动">想做一件事立刻就行动</h3><blockquote><p>“我们一直推迟我们知道最终无法逃避的事情，这样的蠢行是一个普遍的人类弱点，它或多或少都盘踞在每个人的心灵里。”</p></blockquote><ul><li>做出初始行动 （前奏）</li></ul><h3 id="对抗趋乐避苦的懒惰本能">对抗趋乐避苦的懒惰本能</h3><ul><li><p>除了努力、拼命上进之外没有别的选择，为环境所迫，因而在极端的环境下爆发，为了生存只能吃苦磨砺，如果放弃挣扎选择了物质上的舒适，就意味着死亡或溃败。</p></li><li><p>有选择的空间，向前一步可以有更好的生活，向后一步也不至于落到深渊，一分耕耘一分收获。</p></li><li><p>行动力来源于清晰而深刻的认知。</p></li></ul><h3 id="今天的事不要推到明天做">今天的事不要推到明天做</h3><blockquote><p>“一天也不能虚度，要下定决心把可能完成的事情一把抓住然后紧紧抱住，有机会就绝不任其逃走，而且必定要贯彻执行”</p></blockquote><ul><li>把握好“黄金时间段”</li><li>抓住零碎时间</li><li>合理排序，科学工作</li><li>提高专注力</li></ul><h3 id="克服虎头蛇尾的三分钟热度">克服虎头蛇尾的三分钟热度</h3><ul><li>一段时间内只专注一件事</li><li>不断发掘生活的乐趣，避免陷入枯燥和厌倦的状态</li><li>指定循序渐进的计划</li><li>寻找志同道合的伙伴，互相监督、一起同行</li></ul><h3 id="讨厌的事情也得认真做好">讨厌的事情也得认真做好</h3><blockquote><p>很多人之所以拖延，是因为他讨厌某件事情</p></blockquote><ul><li>这件事情重要吗？</li><li>讨厌的原因是什么，是因为不擅长还是因为回报周期太长</li><li>做了这件不喜欢的事情你能收获什么？</li><li>如果不做会有什么样的后果？</li><li>你有选择不做的余地吗？</li><li>如果不做这件事情，你还有别的效益更大化的选择吗？</li><li>你有多长时间来完成这件事情，时间允许你拖延吗？</li><li>怎样才能让这个过程不那么枯燥？</li></ul><h2 id="让时间的价值最大化">让时间的价值最大化</h2><h3 id="把事情按照轻重缓急排序">把事情按照轻重缓急排序</h3><blockquote><p>以“价值”为基础排序。我们做任何事情都脱离不了其价值意义。</p></blockquote><ul><li>重要且紧急的事情</li><li>重要但不紧急的事情</li><li>紧急但不重要的事情</li><li>不紧急也不重要的事情</li></ul><h3 id="用好高效的“黄金时间”">用好高效的“黄金时间”</h3><blockquote><p>“普通人只想如何打发时间，有才能的人则设法利用时间。”</p></blockquote><ul><li>早晨6点（记忆力最佳）</li><li>8-10点（思维最活跃）</li><li>18-20点（最沉着）</li><li>入睡前的时间（加强记忆最好的时间）</li></ul><p>如何定位“黄金时间”</p><ul><li>在备忘录上列出每日事项</li><li>列出自己能够抽出来的所有时间</li><li>找出周围环境最好、最适宜的时间段，即为黄金时间</li><li>把最重要的事情放在“黄金时间”段完成</li><li>其他事项放在其他时间完成</li></ul><p>如何打造“黄金时间”</p><ul><li>自然环境上：以舒适、开阔、安静为重要元素</li><li>生理上：头脑清醒、充满活力、思维清晰的时间段最好</li><li>生活换教室：排除手机等移动设备的干扰，让自己更加专注</li><li>时间段的选取上：尽量选择大段的时间，不至于在执行任务的过程中被打断</li></ul><h3 id="重视不起眼的零碎时间">重视不起眼的零碎时间</h3><ul><li>利用“衔接式”时间</li><li>利用“并列式”时间</li><li>减少零碎时间</li></ul><h3 id="一次用心把事情做好">一次用心把事情做好</h3><blockquote><p>“逐二兔者不得其一”</p></blockquote><ul><li>人的精力有限</li><li>思绪具有连贯性</li><li>一次只做一件事</li></ul><h3 id="拒绝那些让自己分心的事">拒绝那些让自己分心的事</h3><blockquote><p>让我们分心的事情大概有：周围的环境；他人正在做的事情；乱七八糟的思绪；</p></blockquote><ul><li>删繁就简</li><li>摒弃杂念</li></ul><h3 id="无谓的细节无须浪费时间">无谓的细节无须浪费时间</h3><blockquote><p>把时间和精力花费在最重要的地方</p></blockquote><p>什么样的细节是无谓的细节</p><ul><li>日常生活中的细节</li><li>工作中的“次要任务”</li></ul><h3 id="掌握时间管理的二八法则">掌握时间管理的二八法则</h3><blockquote><p>用80%的时间去完成那最关键的20%的事情。</p></blockquote><p>如何确定那重要性为80%的事情?</p><ul><li>寻找效益最大化的事项</li><li>截止日期即将到来的事项</li></ul><h3 id="学会使用高效的番茄工作法">学会使用高效的番茄工作法</h3><p>番茄工作法的好处</p><ul><li>提升注意力，劳逸结合</li><li>减轻焦虑感，加强决心</li><li>改善任务流程，减少干扰因素</li></ul><h2 id="把逃避彻底删掉">把逃避彻底删掉</h2><h3 id="认识到问题与痛苦的价值">认识到问题与痛苦的价值</h3><blockquote><p>正路不一定就是一条平坦的直路，难免有曲折和崎岖坎坷，要绕一些弯，甚至难免会误入歧途。</p></blockquote><ul><li>攻克难题过程中收获的经验</li><li>苦尽甘来的收获</li></ul><h3 id="越是恐惧的事情越要去面对">越是恐惧的事情越要去面对</h3><ul><li>写出你的恐惧</li><li>列出最坏的结果</li><li>指定紧密的工作计划，用行动稀释恐惧</li></ul><h3 id="承认问题是解决问题的开始">承认问题是解决问题的开始</h3><blockquote><p>人们通常不会承认两类事情：不承认自我天赋的缺乏；不承认现实存在的、难以解决的问题。</p></blockquote><ul><li>不要对自己过于苛刻</li><li>让家人或朋友成为你的“参谋师”</li><li>明白一切问题都有解决的办法</li></ul><h3 id="不要总是指望别人替你解决问题">不要总是指望别人替你解决问题</h3><blockquote><p>“不论踩什么样的高跷，没有自己的能力是不行的。”</p></blockquote><ul><li>没有人能永远陪伴在你身边</li><li>人际关系的本质是潜在的价值交换</li></ul><p>什么时候靠自己，什么时候寻求帮助？</p><ul><li>能自己独立完成的任务不必寻求他人的帮助</li><li>自己努力一下就可以做到的事情不必劳烦他人</li><li>同事、朋友之间尽量互帮互助，不要单方面接受而不给与</li><li>在团队工作中公平分配任务</li><li>需要他人协助的事情可以向他人寻求帮助和支持</li></ul><h3 id="认清你给自己找的拖延借口">认清你给自己找的拖延借口</h3><blockquote><p>拖延的借口：问题难以解决，因此搁置；总认为还来得及；内心的恐惧；“我很忙”</p></blockquote><ul><li>眼下最紧急的事情是什么？</li><li>你最想做的事情是什么？</li><li>后一项是非做不可的吗？</li><li>思考“你想做的”和“你应该做的”这两件事会带来什么好处跟坏处？</li><li>哪些事效益最大化，损失最小化的事情？</li></ul><blockquote><p>“最珍贵的是今天，最容易失掉的也是今天。”</p></blockquote><h3 id="对工作保持积极主动的态度">对工作保持积极主动的态度</h3><ul><li>保持规律的作息、健康的饮食</li><li>给自己积极的心理暗示</li><li>常做那些“高能量姿势” （“神奇女校”姿势）</li></ul><h3 id="用“做做看”代替对结果的计较">用“做做看”代替对结果的计较</h3><blockquote><p>“现实是此案，理想是彼岸，中间隔着湍急的合理，行动则是加载川上的桥梁。”</p></blockquote><ul><li>“做”不是一个一成不变的过程</li><li>“做做看”的本质在于突破自我</li><li>珍惜试错的机会的成本</li></ul><h3 id="遇到困难不找借口找方法">遇到困难不找借口找方法</h3><blockquote><p>“人的一切痛苦，本质上都是对自己无能的愤怒。”</p></blockquote><ul><li>我应该怎样解决这个问题，并达到我的目标？</li></ul><h3 id="不求完美但求尽最大的努力">不求完美但求尽最大的努力</h3><blockquote><p>相较于成为一名“完美主义者”，你应该成为一名“现实主义者”。</p></blockquote><ul><li>不存在绝对的完美</li><li>人的欲望是无止境的</li><li>过程比结果更重要</li><li>真实比完美更有力量</li></ul><h3 id="敢于平凡让你更有“底气”">敢于平凡让你更有“底气”</h3><ul><li>平凡不等于平庸</li></ul><h2 id="拆掉思维的壁垒">拆掉思维的壁垒</h2><h3 id="删除“我必须”的思维模式">删除“我必须”的思维模式</h3><ul><li>“我必须”表现出来的是一种不自信，而“我可以”、“我能做到”则是一种自信满满的状态。</li></ul><h3 id="认清自己的长板与短板">认清自己的长板与短板</h3><ul><li>多多尝试新事物，开拓新领域</li><li>采纳他人的合理意见和建议</li></ul><h3 id="绷得太紧时让自己停下来">绷得太紧时让自己停下来</h3><ul><li>身体上的休息</li><li>心理上的缓冲</li></ul><h3 id="别担心达不到完美的结果">别担心达不到完美的结果</h3><ul><li>这种担心是无效担心</li><li>100分纵然完美，80分也可以</li><li>苛求完美会给人带来巨大的压力</li></ul><h3 id="没有尝试之前别给自己设限">没有尝试之前别给自己设限</h3><blockquote><p>还没尝试就设限的人一般处于什么心理：自卑，认为自己不配得到更好的东西；过度重视外在因素的重要性</p></blockquote><ul><li>大胆说出你内心的渴望</li><li>大胆尝试和追求那些你以前不敢奢求的事物</li></ul><h3 id="努力跳出熟悉的心理舒适区">努力跳出熟悉的心理舒适区</h3><ul><li>那些看似“舒适”的状态，往往只是表象</li><li>一时的舒适并不能代表会一直舒适</li></ul><h3 id="防止过分内疚消耗你的精力">防止过分内疚消耗你的精力</h3><ul><li>告别内疚，无须在意他人的眼光</li><li>拖延不好，但只要按部就班做出改变，一定会发生转机</li></ul><h2 id="用自律换得自由">用自律换得自由</h2><h3 id="用延迟满足击退拖延的念头">用延迟满足击退拖延的念头</h3><ul><li>选择做重要且紧急的事情会有什么结果</li><li>选择做短暂又吸引人的事情会有什么结果</li></ul><h3 id="给自己设置一个合理的期望值">给自己设置一个合理的期望值</h3><p>什么是&quot;合理&quot;</p><ul><li>基于现实</li><li>比自己的实际水平稍高一点</li><li>设置你独特的期望值</li></ul><blockquote><p>这一路也行风雨兼程，但请你始终保持可贵的清醒，不要美化过程，不要自怨自艾，一切以客观现实为基础，希望你能成为那个“手可摘星辰”的人。</p></blockquote><h3 id="利用增长的事慢慢建立自信">利用增长的事慢慢建立自信</h3><blockquote><p>“要有信心，然后全力以赴——假如具有这种观念，任何事情十有八九都能成功。”</p></blockquote><ul><li>找到你擅长的事情</li><li>把擅长的事情做到极致</li><li>把擅长的事情和事业相结合</li></ul><h3 id="把自己想象成不拖延的人">把自己想象成不拖延的人</h3><ul><li>“见贤思齐”</li></ul><h3 id="懈怠时开启自我激励模式">懈怠时开启自我激励模式</h3><ul><li>强迫自己回想一遍最初的目标</li><li>看激励人心的影片、听励志音乐</li><li>对自己说：再坚持一会儿</li><li>主动向优秀的人看齐</li></ul><h3 id="借助奖惩措施改变行为模式">借助奖惩措施改变行为模式</h3><ul><li><p>作为“奖励”和“惩罚”的事物要精挑细选<br>作为奖励的事物，应该是你发自内心喜欢的，位于寻常生活只外的东西。<br>作为惩罚的事物，应当是你感性上渴望但理智上应该拒绝的事物。</p></li><li><p>不要为了“拿到奖励”而工作</p></li><li><p>设置奖惩措施，可以从小事做起</p></li></ul><h3 id="多给自己一些积极的暗示">多给自己一些积极的暗示</h3><ul><li><p>心理暗示不同于自我欺骗<br>前者是缺乏自信和勇气<br>后者是无中生有</p></li><li><p>了解一个人是很难的事情，与其向外界寻求肯定，不如向内寻找价值。</p></li></ul><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://www.amazon.cn/dp/B0828N77XX" target="_blank" rel="noopener">超级自控力训练计划</a></p>]]></content>
    
    <summary type="html">
    
      拖延的本质来源于内心的恐惧。这个恐惧有两层含义：任务本身的艰巨性；害怕失败带来的结果。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="SoftSkills" scheme="https://neo1989.net/tags/SoftSkills/"/>
    
  </entry>
  
  <entry>
    <title>《沟通力》</title>
    <link href="https://neo1989.net/Notes/NOTE-ke-fu-zhi-de-gou-tong-li/"/>
    <id>https://neo1989.net/Notes/NOTE-ke-fu-zhi-de-gou-tong-li/</id>
    <published>2021-03-23T15:27:56.000Z</published>
    <updated>2023-01-13T03:02:04.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="沟通力是可以复制的">沟通力是可以复制的</h2><blockquote><p>如果说人类社会是一张网，那么每个人就是网上的结点，而人与人之间必须有线，才能互相连接，否则这些结点就无法形成网，无法成为组织、成为社会。人与人之间的这根“线”就是沟通。</p></blockquote><h3 id="沟通力为什么如此重要">沟通力为什么如此重要</h3><ul><li>提升社会竞争力</li><li>加速事业的成功</li><li>人际关系的润滑剂</li></ul><h3 id="沟通的目标不是“口服”而是“心服”">沟通的目标不是“口服”而是“心服”</h3><ul><li>有明确的沟通目标</li><li>善用语气、语调</li><li>用肢体语言为沟通加分</li></ul><h3 id="信息的准确传递与接收">信息的准确传递与接收</h3><ul><li>能够准确地表达自己的感受</li><li>表达时要直接、精确</li><li>运用深夜电台主持人般的声音 (温柔、缓慢、深沉)</li></ul><h3 id="每个人都能学会的沟通力">每个人都能学会的沟通力</h3><ul><li>学习科学的理论 (真实，完整，时效，同一，目标明确)</li><li>掌握正确的方法</li><li>一定要刻意练习</li></ul><h2 id="沟通的本质是尊重与合作">沟通的本质是尊重与合作</h2><blockquote><p>“尊人者，人尊之。”沟通中如果缺乏尊重，不能平衡自己与对方的需要，总以一种自以为是的方式与对方交流，这样的沟通是很难进行的。只有学会尊重与合作，沟通的过程才会愉快而积极，结果才能如你所愿。</p></blockquote><h3 id="了解自己对恐惧的反应">了解自己对恐惧的反应</h3><ul><li><p>合作为什么越来越难？<br>我们之所以生气、愤怒，其实是内心的恐惧在作祟</p></li><li><p>恐惧的根源<br>我们无法完全掌控局面的时候</p></li></ul><h3 id="从对方的视角看他的经历">从对方的视角看他的经历</h3><ul><li><p>什么是真正的尊重？<br>真正的尊重，应该是从他人的视角去看他们所经历的一切，也就是了解对方的“being”，哲学上称为“存在”。简而言之，就是了解对方此刻存在的状态是什么。</p></li><li><p>懂得尊重自己<br>“我”为什么会这样？“我”的哪些需要没有获得满足？</p></li><li><p>尊重是为了促进共赢</p></li></ul><h3 id="平衡自己与他人的需要">平衡自己与他人的需要</h3><ul><li><p>委屈和讨好<br>对自己的需要不太关注或关注度很低，总是把别人的需要放在第一位。（老好人）</p></li><li><p>控制和强势<br>对他人关注极少、只关注自己的需求。</p></li><li><p>忽视和无助<br>既不关注自己的需要，也不关注别人的需要。（不愿沟通）</p></li><li><p>尊重与合作<br>既关注他人的需要，也不忽视自己的需要。</p></li></ul><h3 id="学会处理情绪和信息">学会处理情绪和信息</h3><ul><li><p>知心大姐式<br>只关注其中的情感和关系。</p></li><li><p>冷面杀手式<br>永远只谈实际问题，从不谈感情。</p></li><li><p>拒绝沟通式<br>既不跟你谈信息，也不跟你谈感情，完全是一副拒绝沟通的模式。</p></li><li><p>沟通专家式<br>既会照顾对方的情感，也很懂得处理实际问题。</p></li></ul><h3 id="沟通之前先明确目标">沟通之前先明确目标</h3><ul><li>怎么才能记住沟通的目标<br>你要为自己创造什么？<br>你要为对方创造什么？<br>你需要为你们的关系创造什么？</li></ul><h3 id="不尊重的沟通方式有哪些">不尊重的沟通方式有哪些</h3><ul><li>喜欢给对方贴标签</li><li>忽视对方的感受</li><li>用威胁的口气说话</li><li>喜欢与别人攀比</li></ul><h2 id="沟通高手都善于掌控情绪">沟通高手都善于掌控情绪</h2><blockquote><p>当我们在沟通中遭遇不愉快，进而产生消极的情绪变化或心理状态时，最重要的是控制这种糟糕的情绪或心理蔓延，别让自己被情绪所左右，否则沟通效率会大打折扣。</p></blockquote><h3 id="停止你的暴力沟通">停止你的暴力沟通</h3><ul><li><p>暴力沟通如何出现的<br>道德评判<br>进行比较<br>回避责任<br>强人所难</p></li><li><p>沟通的公式<br>“我观察到……”<br>“我感觉……”<br>“是因为……”<br>“我请求……”</p></li></ul><h3 id="远离“傻瓜式”沟通">远离“傻瓜式”沟通</h3><ul><li>学会打破大脑中的思维惯性<br>更多地调动大脑前庭和大脑皮层的作用，去克服杏仁核和基底核给我们的沟通带来的情绪影响，远离“傻瓜式”沟通。</li></ul><h3 id="奖惩式沟通的代价">奖惩式沟通的代价</h3><ul><li><p>奖惩式沟通的表现<br>你表现好，我就奖励你；表现不好，我就惩罚你。</p></li><li><p>代价<br>破坏对方的安全感和信任感<br>打压对方的内驱力<br>剥夺了对方与你合作的快乐和愿望<br>让对方学会了用奖励和惩罚获得他想要的东西</p></li></ul><h3 id="沟通中切忌挖苦嘲笑">沟通中切忌挖苦嘲笑</h3><ul><li>明确沟通目的，理性交流</li><li>批评可以直接客观</li></ul><h3 id="不抱怨，把握沟通的尺度">不抱怨，把握沟通的尺度</h3><ul><li>表达感受，提出诉求</li><li>阐述诉求的原因</li><li>向对方提出你的建议</li></ul><h3 id="利用复述和认同感染对方">利用复述和认同感染对方</h3><ul><li><p>重复对方所说的话</p></li><li><p>告诉对方“你说得对”<br>让自己和对方产生一种情绪联结。</p></li></ul><h2 id="沟通要从了解需求开始">沟通要从了解需求开始</h2><blockquote><p>需求是沟通当中的重要因子，凡是沟通中出现的问题，多数是由需求不清晰或需求未能获得满足所致。这里的需求，既包括他人的需求，也包括自我需求。</p></blockquote><h3 id="洞悉对方真正需求，避免情绪积累">洞悉对方真正需求，避免情绪积累</h3><h3 id="人类共通的需求名单">人类共通的需求名单</h3><ul><li>朋友、集体、归属感</li><li>放松、休息、快乐</li><li>关注、理解、倾听</li><li>学习、探索、发现</li><li>选择、自由、自我</li><li>被认可、信任感、安全感</li><li>支持、尊重、爱</li></ul><h3 id="发掘和关注自我需求">发掘和关注自我需求</h3><h3 id="用给予礼物的心态去沟通">用给予礼物的心态去沟通</h3><ul><li>给予是人类的基本需求之一</li><li>你与他人有许多“礼物”可以互相给予</li><li>学会辨识“礼物”</li><li>慷慨地将“礼物”给予他人</li><li>从他人给予的“礼物”中学习和成长</li></ul><h3 id="让对方看到更多的选择空间">让对方看到更多的选择空间</h3><ul><li>具有富足心态的人看到的永远是自己拥有什么，自己还有哪些可选择的空间和可能性。</li><li>匮乏心态的本质就是“没的选”</li></ul><h2 id="营造安全的沟通氛围">营造安全的沟通氛围</h2><blockquote><p>当我们按照惯性思维与别人谈话时，通常会用自己最习惯的方式，但我们的惯性思维很可能让对方感觉不安全。这时候我们就需要打破惯性思维，主动营造一个安全的沟通氛围。</p></blockquote><h3 id="找到共同目的，让对方感受到理解">找到共同目的，让对方感受到理解</h3><ul><li><p>找出对方的真实目的，塑造共同目的<br>先一步做出让步。<br>进一步了解对方的真实目的。<br>塑造共同目的。</p></li><li><p>拓宽视野，塑造长远的共同目的</p></li><li><p>寻找联结，维护安全感，保持目的一致性</p></li></ul><h3 id="利用对比说明，防止冒犯和伤害">利用对比说明，防止冒犯和伤害</h3><ul><li>阐明自己的真实目的</li><li>说明你不想看到的结果</li><li>寻找一个两全其美的方法</li></ul><h3 id="标注对方情感，赢得对方接纳">标注对方情感，赢得对方接纳</h3><ul><li>定位情感：了解对方最关注什么</li><li>标注的常用句式：“看上去”“听起来”“似乎……”</li></ul><h3 id="合理使用道歉和“拔刺”">合理使用道歉和“拔刺”</h3><ul><li>道歉：当对方被激怒的时候</li><li>“拔刺”：当谈话还没正式开始的时候</li></ul><h3 id="气氛不对时先关注情绪再关注内容">气氛不对时先关注情绪再关注内容</h3><ul><li><p>学会做一个双核的对话人<br>一个核负责管理氛围、情绪，另一个核负责管理信息、内容。</p></li><li><p>通过心律共鸣营造气场</p></li><li><p>调整气场的几个高能量姿势<br>学学神奇女侠<br>练练瑜伽</p></li></ul><h2 id="用长颈鹿式沟通破解沟通困境">用长颈鹿式沟通破解沟通困境</h2><blockquote><p>长颈鹿有三个特点：高、反应慢、心脏大，这三个特点可以巧妙地运用到我们的沟通当中。心大，遇事不计较；反应慢，从不觉得什么事都会对自己有伤害；再加上它站得高，看得远，不会对眼前的小事斤斤计较。</p></blockquote><h3 id="长颈鹿式沟通的优势">长颈鹿式沟通的优势</h3><ul><li><p>高<br>站得高，可以看得远</p></li><li><p>反应慢<br>具备钝感力的人，大多会从容面对生活中的挫折和伤痛，也会坚定朝着自己的方向前进。</p></li><li><p>心脏大<br>不往心里去。</p></li></ul><h3 id="什么是长颈鹿式沟通">什么是长颈鹿式沟通</h3><ul><li><p>观察：只讲事实，不加入评判<br>把你看到和听到的东西准确地描述出来</p></li><li><p>感受：说出真实感受，挖掘真实需要<br>虽然感同身受有些难，但是沟通双方达成理解和包容却是可行的。<br>夫妻之间为什么总会发生争吵？因为我们所表达出来的通常都不是我们真实的感受，而是通过带有评判的观察之后臆测出来的对方的行为，这时候的沟通自然已经完全变了味，吵架也就在所难免了。</p></li><li><p>行动：提出具体可执行的请求</p></li></ul><h2 id="如何有效提问与倾听">如何有效提问与倾听</h2><blockquote><p>巧妙地提问可以促使对方进行深入思考，唤醒对方的内在动力，使对方努力去改变自己；倾听则既能满足他人自我表达的需要，又能巩固人与人之间的联结。只有学会提问和倾听，才能成为真正的沟通高手。</p></blockquote><h3 id="不要把建议变成批评">不要把建议变成批评</h3><ul><li><p>明确对方请教的真实意图</p></li><li><p>什么是内在动力？<br>你的内心当中想要把一件事做好的欲望。</p></li><li><p>用提问唤起对方的内在动力<br>通过恰当的提问和启发，引导对方深入、广泛地进行思考，让对方自己找到解决问题的方法，他的问题才能真正解决。</p></li></ul><h3 id="质疑式提问会打击对方积极性">质疑式提问会打击对方积极性</h3><p>提问是为了引发思考，而不是要将你的答案和解决方案直接告诉他人，以展示自己的分析和方案有多智慧，哪怕你心里有更好的答案也不要抢着说，而应通过巧妙地提问让对方先说出答案。同时，恰当的提问也能促使双方共同探讨，这样的沟通才会更加有效。</p><h3 id="启发式提问能激发对方责任感">启发式提问能激发对方责任感</h3><ul><li><p>什么是启发式提问<br>就是向对方提出一些带有启发性的问题，帮助对方的大脑打开一个新的窗口，让对方感觉“我真的没有思考过这些问题”，然后引导对方对这些问题进行深入的梳理，寻找能够真正解决问题的方法。</p></li><li><p>改变现状的标准路径<br>第一步: 觉知，即通过启发让一个人知道他有哪些问题，为什么自己会出现这些问题<br>第二步: 接纳，接纳自己的现状，哪怕现在的自己很糟糕，我们也仍然爱自己<br>第三部: 改变现状。</p></li><li><p>好的提问可以激发对方的行动</p></li></ul><h3 id="提问时对方才是主角">提问时对方才是主角</h3><ul><li><p>启发式提问分为三步<br>询问目标<br>询问现状<br>询问可选择的方法和路径</p></li><li><p>“我也没办法”<br>人会陷入一种“限制性想法”当中。什么是限制性想法？就是人会自己给自己设定很多限制，这些限制会让我们不敢或不愿去想。</p></li></ul><h3 id="放下自我，学会倾听">放下自我，学会倾听</h3><ul><li><p>我们为什么不愿倾听<br>放不下自己。<br>急于反驳。如果反驳效果不佳，我们又可能产生负面的情绪反应。</p></li><li><p>适当给予对方反馈</p></li><li><p>善于在倾听中吸收对方的信息</p></li><li><p>如何倾听<br>深呼吸<br>提问<br>复述</p></li></ul><h3 id="打造沟通的无错区">打造沟通的无错区</h3><p>“无错区”的意思其实是要将沟通双方的关注力从表面的“错误”转向深层的“需要”。</p><ul><li>将冲突看成一个需要解决的问题</li><li>确信你的需求可以获得满足</li><li>相信需求可以引出解决方案</li><li>用合作和联结化解冲突</li><li>对有效的方法庆祝，对无效的方法学习</li></ul><h2 id="用身体语言认识自己和他人">用身体语言认识自己和他人</h2><blockquote><p>人们总是会通过自己的肢体语言、面部表情和微妙暗示向他人传递各种信息，如果我们能正确判断这些信息，沟通就会变得愉快而顺畅。</p></blockquote><h3 id="避免用肢体语言暴露内心所想">避免用肢体语言暴露内心所想</h3><ul><li>减少缺乏自信的手势</li><li>注意紧张时的肢体动作</li></ul><h3 id="一眼看穿对方的微表情">一眼看穿对方的微表情</h3><ul><li>从面部表情猜测对方的情绪</li><li>小动作中表现出来的情绪</li></ul><h3 id="眼神透露出的心理活动">眼神透露出的心理活动</h3><ul><li>视线下移是在掩饰自己的胆怯和不自信</li><li>眼球快速转动是恐惧的表现</li><li>瞳孔变化暗示心理活动</li></ul><h3 id="展现高能量的身体姿态">展现高能量的身体姿态</h3><ul><li>运用与生俱来的骄傲姿态</li><li>正确运用体态语言的沟通力量</li><li>假装自己已经达成沟通目标</li></ul><h3 id="利用心理暗示调节自己的状态">利用心理暗示调节自己的状态</h3><ul><li>引导对方点头</li><li>用缓慢的语速说话</li><li>用表情和肢体动作改变情绪</li></ul><h2 id="让文字发挥力量">让文字发挥力量</h2><blockquote><p>相较于面对面的语言沟通，文字沟通会给沟通双方更多的思考时间，同时在传递语气和情绪方面也更考验智慧。</p></blockquote><h3 id="让文字沟通更专业和精准">让文字沟通更专业和精准</h3><ul><li>配合电话或会议</li><li>商务类书信的沟通</li><li>求职时要运用文字沟通</li></ul><h3 id="发挥文字沟通的优势">发挥文字沟通的优势</h3><ul><li>给彼此留出思考反应的时间</li><li>增加沟通的可信度</li></ul><h3 id="让文字沟通更高效的四个方法">让文字沟通更高效的四个方法</h3><ul><li>沟通目的要明确</li><li>信息传递要完整、准确</li><li>行文简洁，重点突出</li><li>语言表达恰当、合理</li></ul><h2 id="善用沟通力，提升决策力和影响力">善用沟通力，提升决策力和影响力</h2><blockquote><p>在需要做出决策和提升影响力时，高效的沟通力至关重要。出色的沟通力不仅能缓解你的紧张情绪，还能让你的发言更加吸引人，获得听众的共鸣。</p></blockquote><h3 id="如何在会议上高效沟通">如何在会议上高效沟通</h3><ul><li>会前准备充分</li><li>与会人员角色明确</li><li>学会换位思考</li><li>会议要充满创意</li><li>流程科学有序</li></ul><h3 id="利用头脑风暴法激发创意">利用头脑风暴法激发创意</h3><ul><li><p>对提出的意见不讨论、不评价</p></li><li><p>对各种观点都不要急于否认</p></li><li><p>头脑风暴法的流程<br>第一，明确本次会议讨论的具体问题，并且问题越具体、越详细越好。<br>第二，每个人都不要急于发言，而是先针对这个具体问题认真构思一下，把自己的想法整理下来。这个记录的过程就给了与会者独立思考的时间，有益于形成真正独特的思考。<br>第三，各自阐述，不对其他人的观点提出意见。在别人阐述观点时，我们也可以结合自己的想法继续完善方案，这样才能呈现出更多、更有效的解决方案。</p></li></ul><h3 id="六顶思考帽，让会议流程更科学">六顶思考帽，让会议流程更科学</h3><ul><li><p>“蓝帽子”思维<br>代表指挥官，担任着会议中指挥者或主持人的角色。</p></li><li><p>“白帽子”思维<br>代表理性和数据。</p></li><li><p>“黄帽子”思维<br>代表的就是乐观的、有希望的、有建设性的观点。</p></li><li><p>“黑帽子”思维<br>代表着否定、怀疑以及诸多问题，也就是我们常说的批判性思维。</p></li><li><p>“红帽子”思维<br>代表的是感觉、感受、直觉、预感等。</p></li><li><p>“绿帽子”思维<br>表示可以尽情地发挥自己的想象力和创造力，提出各种创意和解决问题的方法。</p></li></ul><h3 id="用平行思维法减少决策风险">用平行思维法减少决策风险</h3><h3 id="三步走，组织高效演讲">三步走，组织高效演讲</h3><ul><li><p>坡道<br>构建坡道的方法有很多，但要构建精彩的坡道只需思考一个问题：听众为什么要在意你的演讲？这个问题的答案就是一个绝妙的坡道。<br>坡道就是要把听众拉到你的演讲当中来。但有一点要注意，就是坡道的时间不要太长，你只有7秒钟的时间可用。</p></li><li><p>发现<br>用坡道成功地捕获了听众的注意力后，你即将说出自己的见解，应该可以引导听众有所发现和收获，而不是强制性地将信息灌输到他们的大脑之中。</p></li><li><p>甜点<br>这里要引起听众的情感共鸣，为听众创造一种感觉，比如紧迫感、诱惑感、惊喜感等。</p></li></ul><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://www.amazon.cn/dp/B088K5SQSM/" target="_blank" rel="noopener">可复制的沟通力</a></p>]]></content>
    
    <summary type="html">
    
      “克己复礼为仁”
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="SoftSkills" scheme="https://neo1989.net/tags/SoftSkills/"/>
    
  </entry>
  
  <entry>
    <title>《实用统计学》</title>
    <link href="https://neo1989.net/Notes/NOTE-practical-statistics/"/>
    <id>https://neo1989.net/Notes/NOTE-practical-statistics/</id>
    <published>2021-02-14T06:53:02.000Z</published>
    <updated>2023-01-13T03:04:27.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="探索性数据分析">探索性数据分析</h2><h3 id="结构化数据的组成">结构化数据的组成</h3><ul><li><p>连续型数据 (区间数据、浮点型数据、数值数据)<br>数据可在一个区间内取任何值。</p></li><li><p>离散型数据 (整数型数据、计数型数据)<br>数据只能取整数，例如计数。</p></li><li><p>分类型数据 (枚举数据、列举数据、因子数据、标称数据、多分支数据)<br>数据只能从特定集合中取值，表示一系列可能的分类。</p></li><li><p>二元数据 (二分数据、逻辑型数据、指示器数据、布尔型数据)<br>一种特殊的分类数据，数据值只能从两个值中取其一（例如0或1, True或False）。</p></li><li><p>有序数据 (有序因子数据)<br>具有明确排序的分类数据。</p></li></ul><blockquote><p>在软件中，数据通常按类型分类。<br>数据类型包括连续型数据、离散型数据、分类数据（其中包括二进制数据）和有序数据。<br>数据分类为软件指明了数据的处理方式。</p></blockquote><h3 id="矩形数据">矩形数据</h3><ul><li><p>数据框<br>电子表格等矩形数据是统计和机器学习模型中的基本数据结构。</p></li><li><p>数据特征 (属性、输入、预测因子、变量)<br>通常称数据表中的一列为一个特征。</p></li><li><p>结果 (因变量、响应、目标、输出)<br>不少数据科学项目涉及对结果的预测，常见的结果为“是”或“否”。特征有时在实验或研究中用于预测结果。</p></li><li><p>记录 (事例、例子、实例、观察、模式、样本)<br>通常称数据表中的一行为一条记录。</p></li></ul><blockquote><p>矩阵是数据科学中的基本数据结构。在矩阵中，行是记录，列是变量（特征）。<br>术语中会存在一些令人困惑之处。在与数据科学相关的各学科中，例如统计学、计算机科学和信息技术等，存在着一系列的同义词。</p></blockquote><h3 id="位置估计">位置估计</h3><ul><li><p>均值 (平均值)<br>所有数据值之和除以数值的个数。</p></li><li><p>加权均值 (加权平均值)<br>各数值乘以相应的权重值，然后加总求和，再除以权重的总和。</p></li><li><p>中位数 (第50百分位数)<br>使得数据集中分别有一半数据位于该值之上和之下。</p></li><li><p>加权中位数<br>使得排序数据集中分别有一半的权重之和位于该值之上和之下。</p></li><li><p>切尾均值 (截尾均值)<br>在数据集剔除一定数量的极值后，再求均值。</p></li><li><p>稳健 (耐抗性)<br>对极值不敏感。</p></li><li><p>离群值 (极值)<br>与大部分数据值差异很大的数据值。</p></li></ul><blockquote><p>均值是一种基本的位置度量，但是对极值（离群值）敏感。<br>其他一些度量更为稳健，例如中位数和切尾均值。</p></blockquote><h3 id="变异性估计">变异性估计</h3><ul><li><p>偏差 (误差、残差)<br>位置的观测值与估计值的直接差异。</p></li><li><p>方差 (均方误差)<br>对于n个数据值，方差是对距离均值的偏差平方后求和，再除以n-1。</p><p>计算方差时的被除数为什么是n-1，而不是n？这一讨论引出了自由度的概念。<br>如果在方差公式中使用了直观的除数n，那么就会低估方差的真实值和总体的标准偏差。这被称为有偏估计。<br>但是，如果除以n-1而不是n，这时标准偏差就是无偏估计。<br>自由度考虑了计算估计量中的限制个数。在这种情况下，自由度是n-1，因为其中有一个限制：<br>标准偏差依赖于计算样本的均值。</p></li><li><p>标准偏差 (L2范数、欧几里得范数)<br>方差的平方根。</p></li><li><p>平均绝对误差 (L1范数、曼哈顿范数)<br>对数据值与均值间偏差的绝对值计算均值。</p></li><li><p>中位数绝对偏差<br>数据值与中位数间绝对偏差的均值。</p></li><li><p>极差<br>数据集中最大值和最小值间的差值。</p></li><li><p>顺序统计量 (秩)<br>基于从大到小排序的数据值的度量。</p></li><li><p>百分位数 (四分位数)<br>表示一个数据集中，P%的值小于或等于第P百分位数，(100-P)%的值大于或等于第P百分位数。</p></li><li><p>四分位距 (四分位差)<br>第75百分位数和第25百分位数间的差值。</p></li></ul><blockquote><p>方差和标准偏差是日常最广为使用的变异性统计量。<br>方差和标准偏差都对离群值敏感。<br>更稳健的度量包括偏离均值（百分位数、四分位距）的平均（中位数）绝对偏差。</p></blockquote><h3 id="探索数据分布">探索数据分布</h3><ul><li><p>箱线图 (箱形图、箱须图)<br>图基提出的一种绘图，是一种快速可视化数据分布情况的方法。</p></li><li><p>频数表<br>将数值型数据的计数情况置于一组间隔（组距）中。</p></li><li><p>直方图<br>对频数表的绘图，其中x轴是组距，y轴是计数（或比例）。</p></li><li><p>密度图<br>直方图的平滑表示，通常基于某种核密度估计。</p></li></ul><blockquote><p>频数直方图在y轴上绘制频数计数，在x轴上绘制变量值。它提供了对数据分布的概览。<br>频数表是直方图中频数计数的表格形式。<br>在箱线图中，箱子的顶部和底部分别表示第75百分位数和第25百分位数。箱线图也提供了数据分布的基本情况。多个箱线图通常是并排展示的，以便于比较分布情况。<br>密度图是直方图的一种平滑表示。它需要一个基于数据估计绘图的函数（当然也可以做多个估计）。</p></blockquote><h3 id="探索二元数据和分类数据">探索二元数据和分类数据</h3><ul><li><p>众数<br>数据集中出现次数最多的类别或值。</p></li><li><p>期望值<br>如果类别可以与一个数值相关联，可以根据类别的出现概率计算一个平均值。</p></li><li><p>条形图<br>在绘图中，以条形表示每个类别出现的频数或占比情况。</p></li><li><p>饼图<br>在绘图中，圆饼中的一个扇形部分表示每个类别出现的频数或占比情况。</p></li></ul><blockquote><p>分类数据通常按比例总结，可以使用条形图将它可视化。<br>类别用于表示不同类型的事物（例如苹果和橘子，男性和女性）、因子变量的等级（例如低、中和高），或由组距分隔的数值型数据。<br>期望值是对每个数值与该数值出现概率的乘积求和，通常用于总结因子变量的等级</p></blockquote><h3 id="相关性">相关性</h3><ul><li><p>相关系数<br>一种用于测量数值变量间相关程度的度量，取值范围在-1到+1之间。</p></li><li><p>相关矩阵<br>将变量在一个表格中按行和列显示，表格中每个单元格的值是对应变量间的相关性。</p></li><li><p>散点图<br>在绘图中，x轴显示一个变量的值，y轴显示另一个变量的值。</p></li></ul><blockquote><p>相关系数测量了两个变量间相互关联的程度。<br>如果变量v1的高值随变量v2的高值的变化而变化，那么v1和v2是正相关的。<br>如果变量v1的高值与变量v2的低值的变化相关联，那么v1和v2是负相关的。<br>相关系数是一种标准化的度量，因此其值的范围处于-1（完全负相关）和+1（完全正相关）之间。<br>如果相关系数为0，那么表示两个变量间没有相关性。但是注意，数据的随机排列将会随机生成正的或负的相关系数。</p></blockquote><h3 id="探索两个及以上变量">探索两个及以上变量</h3><ul><li><p>列联表<br>一种对两个或两个以上分类变量做计数的表格。</p></li><li><p>六边形图<br>一种用于两个数值变量的绘图，图中使用六边形表示记录的组距。</p></li><li><p>等势线图<br>一种类似于地形图的绘图，显示了两个数值型变量的密度情况。</p></li><li><p>小提琴图<br>一种类似于箱线图的绘图，但是显示的是密度估计量。</p></li></ul><blockquote><p>六边形图和等势线图是有用的工具，它们支持以图形方式同时查看两个数值型变量，不会受数据规模的影响。<br>列联表是一种查看两个分类变量计数情况的标准工具。<br>箱线图和小提琴图允许根据分类变量绘制数值型变量。</p></blockquote><h2 id="数据和抽样分布">数据和抽样分布</h2><h3 id="随机抽样和样本偏差">随机抽样和样本偏差</h3><ul><li><p>样本<br>大型数据集的一个子集。</p></li><li><p>总体<br>一个大型数据集，或是一个构想的数据集。</p></li><li><p>N（或n）<br>一般用N表示总体的规模，n表示样本的规模。</p></li><li><p>随机抽样<br>从总体中随机抽取元素到样本中。</p></li><li><p>分层抽样<br>对总体分层，并在每层中做随机抽样。</p></li><li><p>简单随机抽样<br>在不对总体分层的情况下，做随机抽样所得到的样本。</p></li><li><p>样本偏差<br>样本对总体做出了错误的解释。</p></li></ul><blockquote><p>即便是在大数据时代，随机抽样依然是数据科学家的一种重要手段。<br>由于测量或观测不能代表总体而出现系统性误差时，就会产生偏差。<br>数据的质量通常比数量更重要，而随机抽样可以降低偏差，提高数据的质量（否则，实现成本可能很高）。</p></blockquote><h3 id="选择偏差">选择偏差</h3><ul><li><p>偏差<br>系统性误差。</p></li><li><p>数据窥探<br>为得到感兴趣的结果，在数据中做大量的查找。</p></li><li><p>大规模搜索效应<br>由于重复的数据建模，或使用大量的预测变量对数据建模所导致的偏差或非可重现性。</p></li></ul><blockquote><p>指定一个假设，然后遵循随机化和随机抽样的原则收集数据，可以确保不会产生偏差。<br>所有其他类型的数据分析都有产生偏差的风险，风险来自数据的采集和分析过程，包括在数据挖掘中反复地运行模型、在研究中窥探数据，以及事后选取有意义的事件。</p></blockquote><h3 id="统计量的抽样分布">统计量的抽样分布</h3><ul><li><p>样本统计量<br>对抽取自大规模总体中的样本做计算，所得到的一些度量值。数据分布</p></li><li><p>数据分布<br>单个值在数据集中的频数分布。</p></li><li><p>抽样分布<br>一个样本统计量在多个样本或重抽样中的频数分布。</p></li><li><p>中心极限定理<br>当样本的规模增大时，抽样分布呈正态分布的趋势。</p></li><li><p>标准误差<br>多个样本间样本统计量的变异性（标准偏差）。不要与标准偏差混淆，后者指的是个体数据值间的变异性。</p></li></ul><blockquote><p>样本统计量的频数分布表明了度量在各个不同抽样间的变化情况。<br>抽样分布可以使用自助法估计，也可以通过依赖于中心极限定理的公式计算得到。<br>标准误差是一个关键的度量，它汇总了抽样统计量的变异性。</p></blockquote><h3 id="自助法">自助法</h3><ul><li><p>自助样本（bootstrap sample）<br>从观测数据集中做有放回的抽取而得到的样本。</p></li><li><p>重抽样<br>在观测数据中重复抽取样本的过程，其中包括自助过程和置换（混洗）过程。</p></li></ul><blockquote><p>自助法（即对数据集做有放回的抽样）是一种评估样本统计量变异性的强大工具。<br>自助法可以类似的方式应用于各种场景中，无须深入探究抽样分布的数学近似。<br>自助法可以在不使用数学近似的情况下，估计统计量的抽样分布。<br>用于预测模型时，聚合多个自助样本的预测（即Bagging方法），要优于使用单个模型的预测。</p></blockquote><h3 id="置信区间">置信区间</h3><ul><li><p>置信水平<br>以百分比表示的置信区间。该区间是从同一总体中以同一方式构建的，可以包含我们感兴趣的统计量。</p></li><li><p>区间端点<br>置信区间的两端。</p></li></ul><blockquote><p>置信区间是一种以区间范围表示估计量的常用方法。<br>数据越多，样本估计量的变异性越小。<br>所能容忍的置信水平越低，置信区间就越狭小。<br>自助法是一种构建置信区间的有效方法。</p></blockquote><h3 id="正态分布">正态分布</h3><ul><li><p>误差<br>数据点与预测值或均值间的差异。</p></li><li><p>标准化<br>数据值减去均值，再除以标准偏差。</p></li><li><p>z分数<br>单个数据点标准化的结果。</p></li><li><p>标准正态分布<br>均值为0、标准偏差为1的正态分布。</p></li><li><p>QQ图<br>对样本分布与正态分布间接近程度的可视化绘图。</p></li></ul><blockquote><p>在统计学的发展史中，正态分布有着十分重要的地位，因为它允许从数学上近似不确定性和变异性。<br>虽然原始数据通常并不符合正态分布，但误差通常是符合正态分布的。对于大规模样本的均值和总数，也是一样的。<br>要将数据转换为z分数，需要减去数据的均值，再除以标准偏差。这样，所生成的数据才可以与正态分布进行对比。</p></blockquote><h3 id="长尾分布">长尾分布</h3><ul><li><p>尾<br>一个频数分布的狭长部分，其中相对极值出现的频数很低。</p></li><li><p>偏斜<br>分布的一个尾部长于另一个尾部。</p></li></ul><blockquote><p>大部分数据是不符合正态分布的。<br>假设数据符合正态分布，这可导致对极端事件产生错误的估计（即“黑天鹅”现象）。</p></blockquote><h3 id="学生t分布">学生t分布</h3><ul><li><p>n<br>表示一个样本的规模。</p></li><li><p>自由度<br>自由度是一个参数，允许根据不同的样本规模、统计量和组数对t分布进行调整。</p></li></ul><blockquote><p>t分布实际上是一个分布家族。它们与正态分布相似，但是尾部略厚。<br>t分布被广泛地用作样本均值分布、两个样本均值间的差异、回归参数等的参考基础。</p></blockquote><h3 id="二项分布">二项分布</h3><ul><li><p>试验<br>一次输出离散值的事件，例如，一次硬币抛掷。</p></li><li><p>成功<br>一次试验的输出为我们感兴趣的结果。</p></li><li><p>二项 (二元)<br>具有两个输出</p></li><li><p>二项试验 (伯努利试验)<br>有两种输出的试验。</p></li><li><p>二项分布 (伯努利分布)<br>在多次试验中（例如x次），成功次数的分布。</p></li></ul><blockquote><p>二项输出在建模中十分重要，因为它们表示了基本的决策情况，例如是否购买、是否点击、存活还是死亡等。<br>二项试验是一种具有两种可能结果的试验，其中一种结果的概率为p，另一种结果的概率为1-p。<br>当n很大并且p不接近于0（或1）时，二项分布可使用正态分布近似。</p></blockquote><h3 id="泊松分布及其相关分布">泊松分布及其相关分布</h3><ul><li><p>lambda<br>单位时间内或单位空间中的事件发生率。</p></li><li><p>泊松分布<br>单位时间内或单位空间中事件数量的频数分布。</p></li><li><p>指数分布<br>在时间或距离上，从一个事件到下一个事件的频数分布。</p></li><li><p>韦伯分布<br>泛化版本的指数分布。韦伯分布允许事件发生的速率随时间变化。</p></li></ul><blockquote><p>如果事件发生率为常数，那么可以用泊松分布对单位时间或空间内的事件数量进行建模。<br>这种场景下，可以用指数分布对两个事件间的时间间隔或距离建模。<br>如果事件发生率会随时间变化（例如，设备故障率的增大），可以使用韦伯分布建模。</p></blockquote><h2 id="统计实验与显著性检验">统计实验与显著性检验</h2><h3 id="A-B测试">A/B测试</h3><ul><li><p>处理<br>实验对象所接触的东西，例如药品、价格、Web标题等。</p></li><li><p>实验组<br>行特定处理的一组对象。</p></li><li><p>对照组<br>执行标准处理或不执行处理的一组对象。</p></li><li><p>随机化<br>随机地分配实验对象以进行处理的过程。</p></li><li><p>实验对象<br>接受处理者，例如Web访问者、病人等。</p></li><li><p>检验统计量<br>用于检验处理效果的度量。</p></li></ul><blockquote><p>将实验对象分配给两组或更多组，各组的条件完全相同，只是要接受的处理不同。<br>在理想情况下，实验对象是随机分配给各组的。</p></blockquote><h3 id="假设检验">假设检验</h3><ul><li><p>零假设<br>完全归咎于偶然性的假设。</p></li><li><p>备择假设<br>与零假设相反，即实验者希望证实的假设。</p></li><li><p>单向检验<br>在假设检验中，只从一个方向上计数偶然性结果。</p></li><li><p>双向检验<br>在假设检验中，从正反两个方向上计数偶然性结果。</p></li></ul><blockquote><p>零假设的逻辑理念体现为没有特殊事件发生，任何观察到的效果都是由随机偶然导致的。<br>假设检验假定零假设为真，创建“零模型”（一种概率模型），并检验所观察到的效果是否是该模型的合理结果。</p></blockquote><h3 id="重抽样">重抽样</h3><ul><li><p>置换检验 (随机化检验、随机置换检验、准确检验)<br>将两组或多组样本组合在一起，并将观测值随机地（或穷尽地）重新分配给重抽样。</p></li><li><p>有放回，无放回<br>在抽样时，所抽取的元素在下一次抽取前是否放回样本中。</p></li></ul><blockquote><p>置换检验将多个样本组合在一起，并做随机混洗。<br>对混洗后的值做分组并重抽样，计算我们感兴趣的统计量。<br>重复上述过程，并在表格中记录重抽样统计量的情况。<br>对比统计量的观测值与重抽样分布，就可以判定观测到的样本间差异是否由偶然性导致的。</p></blockquote><h3 id="统计显著性和p值">统计显著性和p值</h3><ul><li><p>p值<br>对于一个加入了零假设的偶然性模型，p值指得到与观测结果一样不寻常或极端的结果的概率。</p></li><li><p>α值<br>在实际结果的确是统计显著的情况下，α值指偶然性结果必须超出的“不寻常性”概率的阈值。</p></li><li><p>第一类错误<br>错误地将一个由随机导致的效果归结为真。</p></li><li><p>第二类错误<br>错误地将一个为真的效果归结为由随机导致的。</p></li></ul><blockquote><p>显著性检验可以用于确定观测到的效果是否落在零假设模型的随机变异范围内。<br>给定一个零假设模型，p值表示模型所生成的结果与观测到的结果同样极端的概率。<br>α值是零假设随机模型“不寻常性”的阈值。<br>相对于数据科学而言，显著性检验在正式的研究报告中更加重要。但是近年来，即便是对于研究报告，p值的重要性也一直在下降。</p></blockquote><h3 id="t检验">t检验</h3><ul><li><p>检验统计量<br>对我们所关注的差异或效果的度量。</p></li><li><p>t统计量<br>归一化的检验统计量。</p></li><li><p>t分布<br>一种用于比较所观测到的t统计量的参考分布。对于t检验，参考分布是从零假设生成的。</p></li></ul><blockquote><p>在计算机出现之前，重抽样检验并不实用，统计人员使用标准参考分布。<br>检验统计量应该做归一化，这样才能与参考分布做比较。<br>t统计量是一种广为使用的归一化统计量。</p></blockquote><h3 id="多重检验">多重检验</h3><ul><li><p>第一类错误<br>错误地得出一个效果是统计显著的结论。</p></li><li><p>错误发现率<br>在多重检验中，犯第一类错误的比率。</p></li><li><p>p值校正<br>用于在同一数据上做多重检验。</p></li><li><p>过拟合<br>拟合了噪声。</p></li></ul><blockquote><p>在研究工作或数据挖掘项目中，多重性（多重比较、多变量、多模型等）增加了仅根据随机对某个结果得出显著性结论的风险。<br>对于涉及多重统计比较的情况（即显著性的多重检验），可以使用统计校正过程。<br>在数据挖掘中使用结果变量带标记的验证样本，有助于避免得到误导性的结果。</p></blockquote><h3 id="自由度">自由度</h3><ul><li><p>n (样本规模)<br>在数据中，观测（也称为行或记录）的数量。</p></li><li><p>d.f.<br>degrees of freedom（自由度）的简写。</p></li></ul><blockquote><p>自由度是归一化检验统计量计算的一部分。它使得归一化后的结果可以与参考分布（例如t分布、F分布等）进行对比。<br>在回归中，为避免出现多重共线性问题，在将分类变量因子化为n-1个标识或虚拟变量时，应考虑其中隐含的自由度概念。</p></blockquote><h3 id="方差分析">方差分析</h3><ul><li><p>两两对比<br>对于有多个组的情况，在两个组之间做假设检验（比如对均值）。</p></li><li><p>多项检验（omnibus test）<br>一种可以测定多个组均值间方差的单一假设检验。</p></li><li><p>方差分解<br>从整体统计量中（例如，从整体均值、处理均值以及残差中），分离出单个值的贡献情况。</p></li><li><p>F统计量<br>一种归一化统计量，用于衡量多个组均值间的差异是否会超过随机模型的预期。</p></li><li><p>SS<br>sum of square（平方和）的简写，指与某一均值的偏差。</p></li></ul><blockquote><p>方差分析是一种用于分析多组处理结果的统计过程。<br>方差分析是对A/B测试中类似过程的一种扩展，用于评估各组之间的整体方差是否落在随机变异范围内。<br>方差分析的一个有用结果是识别出与组处理、交互效果和误差相关的方差成分。</p></blockquote><h3 id="卡方检验">卡方检验</h3><ul><li><p>卡方统计量<br>观测数据偏离预期程度的量度。</p></li><li><p>期望值 (期望)<br>在某种假设（通常是零假设）下，我们期望数据能给出的结果。</p></li><li><p>d.f.<br>自由度。</p></li></ul><blockquote><p>统计学中一个常见的过程是检验观测情况与独立性假设是否一致，例如购买特定产品的倾向是否与性别无关。<br>卡方分布是一种加入了独立性假设的参考分布。由观测情况计算得到的卡方统计量，必须与卡方分布进行对比。</p></blockquote><h3 id="多臂老虎机算法">多臂老虎机算法</h3><ul><li><p>多臂老虎机<br>一种假想的老虎机，提供多个拉杆供用户选择，每个拉杆对应不同的收益，用于模拟多处理实验。</p></li><li><p>臂<br>表示实验中的一个处理，例如Web测试中的标题A。</p></li><li><p>获胜<br>通过实验模拟老虎机上的获胜，例如客户点击了链接。</p></li></ul><blockquote><p>传统的A/B测试基于随机抽样过程，会导致过度地使用非最优处理。<br>相比而言，多臂老虎机算法改进了抽样过程，加入了在实验过程中学到的信息，减少了非最优处理的频数。<br>多臂老虎机算法还有助于有效地应对两种以上的处理。<br>多臂老虎机具有多种不同的算法，能够解决如何将抽样概率从非最优处理转移到（假设的）最优处理的问题。</p></blockquote><h3 id="检验效能和样本规模">检验效能和样本规模</h3><ul><li><p>效果规模<br>在统计检验中，期望能检测到的效果的最小规模，例如点击率提高20%。</p></li><li><p>检验效能<br>给定样本规模，检测到给定效果规模的概率。</p></li><li><p>显著性水平<br>在检验中所使用的统计显著性水平。</p></li></ul><blockquote><p>在确定样本的规模之前，需提前确定要执行的统计检验。<br>必须指定要检测效果的最小规模。<br>还必须指定检测这一效果规模（检验效能）所需的概率。<br>最后，还必须指定执行检验的显著性水平（α值）。</p></blockquote><h2 id="回归与预测">回归与预测</h2><h3 id="简单线性回归">简单线性回归</h3><ul><li><p>响应变量 (因变量、变量Y、目标、结果)<br>想要预测的变量。</p></li><li><p>自变量 (自变量、变量X、特征、属性)<br>用于预测响应的变量。</p></li><li><p>记录 (行、案例、实例、示例)<br>一个表示特定个体或实例的向量，由因子和结果值组成。</p></li><li><p>截距 ($ b_0 $、$ β_0 $)<br>回归线的截距，即当X = 0时的预测值。</p></li><li><p>回归系数 (斜率、$ b_1 $、$ β_1 $、参数估计值、权重)<br>回归线的斜率。</p></li><li><p>拟合值 (预测值)<br>从回归线获得的估计值[插图]。</p></li><li><p>残差 (误差)<br>观测值和拟合值之间的差异。</p></li><li><p>最小二乘法 (普通最小二乘法)<br>一种通过最小化残差的平方和而拟合回归的方法。</p></li></ul><blockquote><p>回归方程将响应变量Y和预测变量X间的关系建模为一条直线。<br>回归模型给出了拟合值和残差，即响应的预测值和预测的误差。<br>回归模型通常使用最小二乘法拟合。<br>回归可用于预测和解释。</p></blockquote><h3 id="多元线性回归">多元线性回归</h3><ul><li><p>均方根误差 (RMSE)<br>回归均方误差的平方根，它是比较回归模型时使用最广泛的度量。</p></li><li><p>标准残差 (RSE)<br>与均方根误差的计算一样，只是根据自由度做了调整。</p></li><li><p>R方 (决定系数、$ R^2 $)<br>可以被模型解释的变异的比例，值介于0到1之间。</p></li><li><p>t统计量<br>预测因子的系数，除以系数的标准误差。它提供了一种比较模型中变量重要性的度量。</p></li><li><p>加权回归<br>在回归中，记录具有不同的权重。</p></li></ul><blockquote><p>多元线性回归建模了响应变量Y与多个预测变量$ X_1, …, X_p $之间的关系。<br>均方根误差（RMSE）和R2是评价模型最重要的度量。<br>回归系数的标准误差可用于度量变量对模型的贡献的可靠性。<br>逐步回归是一种自动确定模型中应包括哪些变量的方法。<br>加权回归用于拟合函数中，可以对特定记录给予更大或更小的权重。</p></blockquote><h3 id="使用回归做预测">使用回归做预测</h3><ul><li><p>预测区间<br>个体预测值的不确定区间范围。</p></li><li><p>外推法<br>将模型扩展到拟合所用的数据范围之外。</p></li></ul><blockquote><p>超出数据范围的外推会导致误差。<br>置信区间量化了回归系数的不确定度。<br>预测区间量化了单个预测中的不确定度。<br>包括R在内的很多统计软件，都会使用公式在默认或指定输出中给出预测区间和置信区间。<br>也可以使用自助法确定置信区间，该做法的解释和理念同上。</p></blockquote><h3 id="回归中的因子变量">回归中的因子变量</h3><ul><li><p>虚拟变量<br>二元的0/1变量，通过对因子数据重新编码得到，可用于回归模型或其他模型。</p></li><li><p>参考编码 (编码处理)<br>统计学家最常使用的编码类型。它以因子的一层作为参考层，并将其他因子与参考层进行对比。</p></li><li><p>独热编码（one hot encoder）<br>机器学习领域中常用的一种编码。它保留了所有的因子层。虽然该编码适用于部分机器学习算法，但并不适用于多元线性回归。</p></li><li><p>偏差编码 (总和对照编码)<br>在编码中用于对比的并不是参考层，而是将每一层与整体均值进行对比。</p></li></ul><blockquote><p>因子变量需要转换为数值变量，才能在回归中使用。<br>要编码一个具有P个不同值的因子变量，最常用的方法是表示为P-1个虚拟变量。<br>即便是在规模非常大的数据集中，多层因子变量也需整合为具有更少层的变量。<br>一些因子的层是有序的，可以表示为单一的数值变量。</p></blockquote><h3 id="解释回归方程">解释回归方程</h3><ul><li><p>相关变量<br>当预测变量高度相关时，难以解释单个回归系数。</p></li><li><p>多重共线性 (共线性)<br>当预测变量间存在完美的或近乎完美的相关性时，回归是不稳定的，或者说是不可能计算的。</p></li><li><p>混淆变量<br>一种重要的预测变量。忽视该变量可导致回归方程给出伪关系。</p></li><li><p>主效应<br>预测变量和结果变量之间的关系，该关系独立于其他的变量。</p></li><li><p>交互作用<br>两个或两个以上预测变量和响应之间的相互依赖关系。</p></li></ul><blockquote><p>考虑到预测因子之间的相关性，在多元线性回归中，必须注意如何解释回归系数。<br>多重共线性可能导致拟合回归方程中存在数值不稳定的问题。<br>混淆变量是指在模型中遗漏的重要预测因子，它可以导致存在虚假关系的回归方程。<br>如果变量和响应之间存在相互依赖的关系，那么需要在两个变量间添加一个交互项。</p></blockquote><h3 id="回归诊断">回归诊断</h3><ul><li><p>标准残差<br>残差除以残差的标准误差。</p></li><li><p>离群值<br>距离其他记录（或预测结果）很远的记录（或结果值）。</p></li><li><p>强影响值 (influential value)<br>一个值或记录，其存在与否会使回归方程有很大差异。</p></li><li><p>杠杆 (hat-value)<br>单个记录对回归方程的影响程度。</p></li><li><p>非正态残差<br>非正态分布的残差可能会导致一些对回归的技术需求失效。但在数据科学中，通常并不会关注该问题。</p></li><li><p>异方差性<br>在输出的部分范围中具有较高变异性的残差。这可能表明在回归方程中缺失了某个预测变量。</p></li><li><p>偏残差图 (变量添加图、added-variable-plot)<br>展示结果变量和单个预测变量之间关系的一种诊断图。</p></li></ul><blockquote><p>鉴于离群值可能会在小规模数据集中导致问题，关注离群值主要是为了发现数据中存在的问题，或是确定异常所在。<br>单个记录（包括回归离群值）可以对小规模数据集的回归方程产生很大的影响。但是在大数据中，这种效果却荡然无存。<br>如果将回归模型用于形式推断（如p值等），那么应该检验对残差分布的一些假设。但是对于数据科学而言，残差分布通常无关紧要。<br>偏残差图可以用于定性地评估每个回归项的拟合情况，这可能会得出另一种模型声明。</p></blockquote><h3 id="多项式回归和样条回归">多项式回归和样条回归</h3><ul><li><p>多项式回归<br>在回归方程中添加了多项式项，例如平方项、三次方项等。</p></li><li><p>样条回归<br>使用一系列多项式片段去拟合一条平滑曲线。</p></li><li><p>结点<br>分隔样条片段的值。</p></li><li><p>广义加性模型  (GAM)<br>可以自动选择结点的样条模型。</p></li></ul><blockquote><p>在回归中，离群值表现为具有很大残差的记录。<br>多重共线性会导致拟合回归方程中存在数值不稳定的问题。<br>混淆变量是一种重要的预测变量。如果在一个模型中忽略了混淆变量，将会导致回归方程给出伪关系。<br>如果一个变量的效果依赖于另一个变量（因子变量）的层级，那么在两个变量之间需要有交互项。<br>多项式回归可以拟合预测变量和结果变量之间的非线性关系。<br>样条是一组连接在一起的多项式片段，连接点被称为结点。<br>广义加性模型可以自动指定样条函数中的结点。</p></blockquote><h2 id="分类">分类</h2><h3 id="朴素贝叶斯算法">朴素贝叶斯算法</h3><ul><li><p>条件概率<br>在给定另一个事件（比如Y = i）的条件下，观测到某个事件（比如X = i）的概率，记作 $ P(X_i | Y_i) $。</p></li><li><p>后验概率<br>在给定预测因子的情况下，出现某一结果的概率（后验概率不同于结果的先验概率，后者并未考虑预测因子的信息）。</p></li></ul><blockquote><p>朴素贝叶斯适用于分类的（因子型的）预测和结果。<br>朴素贝叶斯要解答的问题是：“在每个结果类别中，哪些预测类别是最可能发生的？”<br>该问题可以转化为，在给定预测值的情况下，估计结果属于不同类别的概率。</p></blockquote><h3 id="判别分析">判别分析</h3><ul><li><p>协方差<br>对一个变量相对于另一个变量的一致程度（幅度和方向类似）的度量。</p></li><li><p>判别函数<br>当应用于预测变量上时，该函数可以使类之间的分离度最大化。</p></li><li><p>判别权重<br>应用判别函数得到的分值，用于估计记录属于某个类的概率。</p></li></ul><blockquote><p>判别分析适用于连续预测因子或分类预测因子，也适用于分类结果。<br>判别分析使用协方差矩阵计算线性判别函数，该函数用于区分属于不同类的记录。<br>线性判别函数对每个记录生成一个权重或分值（每个可能的类对应一个权重），以此来确定记录的估计类。</p></blockquote><h3 id="逻辑回归">逻辑回归</h3><ul><li><p>Logit函数 (对数函数)<br>一种能将属于某个类的概率映射到 ±∞ 范围上（而不是0到1之间）的函数。</p></li><li><p>几率<br>“成功”（1）与“不成功”（0）之间的比率。</p></li><li><p>对数几率<br>转换后的模型（即线性模型）中的响应。该响应已被映射回概率值。</p></li></ul><blockquote><p>逻辑回归和线性回归类似，只不过其结果是二元变量。<br>在逻辑回归中需要做多次转换，以将模型转化为一种可以像线性模型一样拟合的形式，并使用对数优势比作为响应变量。<br>通过迭代过程拟合了线性模型之后，应将对数几率映射回概率值。<br>逻辑回归的计算快速，并且生成的模型可以在不重新计算的情况下对新数据打分，因此它得到了广泛的使用。</p></blockquote><h3 id="评估分类模型">评估分类模型</h3><ul><li><p>正确率（accuracy）<br>正确分类的百分比（或比例）。</p></li><li><p>混淆矩阵<br>按预测分类和实际分类情况对记录分别计数，将计数结果以表格形式显示。例如，对于二元变量，使用的是2×2的表格。</p></li><li><p>灵敏度 (召回率)<br>在预测结果中，1被正确分类的百分比（或比例）。</p></li><li><p>特异性<br>在预测结果中，0被正确分类的百分比（或比例）。</p></li><li><p>准确率（precision）<br>预测结果为1、真实值也为1的百分比（或比例）。</p></li><li><p>ROC曲线<br>灵感度与特异性的绘图。</p></li><li><p>提升（lift）<br>在不同截止概率的情况下，衡量模型在识别（相对罕见的）1上的有效性。</p></li></ul><blockquote><p>正确率（即预测分类正确的百分比）可以用于评估模型，但只是评估的第一步。<br>其他度量（召回率、特异性、准确率）侧重于更具体的性能特征。例如，召回率测定了模型正确识别1的良好程度。<br>AUC（ROC曲线下的面积）是对模型区分1与0能力的一种常用度量。<br>提升衡量了一个模型在识别1上的有效性，并且常常是按十分位数逐个计算的，从分类为1可能性最大之处开始。</p></blockquote><h3 id="不平衡数据的处理策略">不平衡数据的处理策略</h3><ul><li><p>欠采样 (下采样)<br>在分类模型中，使用更少的多数类记录。</p></li><li><p>过采样 (上采样)<br>在分类模型中，更多地使用稀有类记录。必要时可以使用自助法。</p></li><li><p>上权重、下权重<br>在模型中，对稀有类赋予更大的权重，对多数类赋予更小的权重。</p></li><li><p>数据生成<br>类似于自助法，只是每个新的自助记录与原记录略有不同。</p></li><li><p>z分数<br>对结果做归一化所生成的值。</p></li><li><p>K<br>在最近邻计算中使用的近邻个数。</p></li></ul><blockquote><p>分类算法在高度不平衡数据（其中感兴趣的结果“1”十分罕见）中会存在问题。<br>平衡训练数据的一种策略是，对多数类做欠采样，或者对稀有类做过采样。<br>如果使用了数据中所有的“1”依然不够，可以对稀有类做自助法，或使用SMOTE算法创建与稀有类相似的合成数据。<br>不平衡数据通常表明正确的分类（即“1”）具有更高的价值。我们应将这种值的比率纳入到评估度量中。</p></blockquote><h2 id="统计机器学习">统计机器学习</h2><h3 id="K最近邻算法">K最近邻算法</h3><ul><li><p>近邻<br>具有相似预测值的两个记录。</p></li><li><p>距离度量<br>以单一数值的形式，测量两个记录之间的距离。</p></li><li><p>标准化 (归一化)<br>减去均值，并除以标准偏差。</p></li><li><p>z分数<br>标准化后得到的值。</p></li><li><p>K<br>在最近邻计算中考虑的近邻个数。</p></li></ul><blockquote><p>KNN通过指定与一条记录相似的记录所属的类，实现对该记录的分类。<br>可以使用欧氏距离或其他相关度量判定相似度（距离）。<br>与一条记录进行比较的最近邻数（即K值），取决于使用不同K值时，算法在训练数据上的性能。<br>预测变量通常需要做标准化，以避免大尺度变量主导了距离度量。<br>KNN常常作为预测建模过程的第一个阶段。KNN的预测值会作为一个预测变量添加回数据中，进而用于第二阶段（非KNN）的建模。</p></blockquote><h3 id="树模型">树模型</h3><ul><li><p>递归分区（recursive partition）<br>反复对数据进行划分和细分，目的是使每个最终细分内的结果尽可能同质。</p></li><li><p>拆分值（split value）<br>一个预测变量值，它将一组记录分为两部分，使得一部分中的预测变量小于拆分值，而另一部分中的预测变量大于拆分值。</p></li><li><p>节点<br>在决策树中（或在一组相应的分支规则中），节点是拆分值的图形化表示（或规则表示）。</p></li><li><p>叶子<br>一组if-then规则的终点，或一个树分支的终点。在树中访问叶子的规则，构成了对树中一条记录的分类规则。</p></li><li><p>损失<br>在拆分过程的某一阶段中误分类的个数。损失越大，不纯度越高。</p></li><li><p>不纯度 (异质性)<br>表示在数据的一个细分中发现多个类混杂的程度。细分中混杂的类越多，该细分的不纯度就越高。</p></li><li><p>剪枝<br>为了降低过拟合，对一棵完全长成树逐步剪枝的过程。</p></li></ul><blockquote><p>决策树生成一组规则，用于分类或预测结果。<br>规则对应于如何将数据划分为连续的子分区。<br>每个分区或拆分指定一个预测变量值（即拆分值），将分区中数据拆分为高于和低于该拆分值的两组记录（即子分区）。<br>在每个阶段，树算法选择使每个子分区内结果的不纯度最小的拆分。<br>一旦算法不能做进一步的拆分，就得到了一棵完全长成树。每个末端节点或叶子内的记录属于相同的类。此后，遵循该规则（拆分）路径的新记录，将会分配为该类。<br>完全长成树会过产生拟合，因此为了使模型捕获信号而非噪声，必须做剪枝。<br>虽然随机森林和Boosting等多树模型算法具有更好的预测性能，但失去了单个树模型基于规则的交流能力。</p></blockquote><h3 id="Bagging和随机森林">Bagging和随机森林</h3><ul><li><p>集成 (模型平均)<br>使用一组模型给出预测。</p></li><li><p>Bagging (自助法聚合)<br>对数据使用自助法构建一组模型的通用方法。</p></li><li><p>随机森林 (自助法聚合决策树)<br>使用决策树的一类自助法聚合估计。</p></li><li><p>变量重要性<br>对预测变量在模型性能中重要性的测量。</p></li></ul><blockquote><p>通过组合多个模型的结果，集成模型提高了模型正确率。<br>Bagging是一类特殊的集成模型，它使用数据的自助法抽样拟合多个模型，并对模型取平均值。<br>随机森林是一种应用于决策树的特殊Bagging方法。除了对数据重抽样之外，随机森林算法还在拆分树时对预测变量做抽样。<br>对变量重要性的一种度量是随机森林的一种有用输出。变量重要性根据变量对模型正确率的贡献度，对变量排序。<br>随机森林具有一组超参数。可以使用交叉验证调整超参数，以避免产生过拟合。</p></blockquote><h3 id="Boosting">Boosting</h3><ul><li><p>Boosting<br>在拟合一组模型时所使用的一种通用方法。Boosting在每轮连续的拟合中，会对具有更大残差的记录赋予更大的权重。</p></li><li><p>Adaboost<br>Boosting算法的一种早期实现，它根据残差的情况对数据重新加权。</p></li><li><p>梯度提升<br>一种更通用的Boosting算法。它将问题转化为代价函数最小化的问题。</p></li><li><p>随机梯度提升（SGD）<br>最常用的Boosting算法。它在每轮拟合中加入了对记录和数据列的重抽样。</p></li><li><p>正则化<br>通过在代价函数中对模型参数的数量添加惩罚项，避免产生过拟合。</p></li><li><p>超参数<br>在拟合算法之前就需要设定的参数。</p></li></ul><blockquote><p>Boosting是一类基于对一组模型做拟合的集成模型。在连续的每轮拟合中，Boosting算法会为具有更大残差的记录赋予更大的权重。<br>随机梯度提升是最通用的Boosting算法，具有最佳性能。随机梯度提升最常见的形式是使用树模型。<br>XGBoost是一种广为使用的随机梯度提升软件包，它计算高效。所有数据科学常用的语言中都提供了XGBoost。<br>Boosting容易过拟合数据。为了避免产生过拟合，需要调整超参数。<br>正则化通过在模型的参数数量（例如，树的规模）上添加惩罚项，避免产生过拟合。<br>鉴于Boosting算法需要设置大量的超参数，交叉验证尤为重要。</p></blockquote><h2 id="无监督学习">无监督学习</h2><h3 id="主成分分析">主成分分析</h3><ul><li><p>主成分<br>预测变量的一种线性组合。</p></li><li><p>载荷 (权重)<br>将预测因子转换为成分的过程中所使用的权重值。</p></li><li><p>陡坡图<br>一种展示各成分方差的绘图，图中显示了各成分的相对重要性。</p></li></ul><blockquote><p>主成分是预测变量的线性组合，但仅限于数值型预测变量。<br>主成分计算的原则是使成分之间的相关性最小化，进而减少冗余。<br>通常，有限数量的成分就可以解释结果变量的大部分方差。<br>这样就可以使用一组有限的主成分代替（更多的）原始预测变量，从而降低维度。</p></blockquote><h3 id="K-Means聚类">K-Means聚类</h3><ul><li><p>类（cluster）<br>一组类似的记录。</p></li><li><p>类均值<br>表示类内记录变量均值的向量。</p></li><li><p>K<br>类的个数。</p></li></ul><blockquote><p>所需的类数K由用户决定。<br>K-Means算法通过迭代地将记录分配给最近的类均值，直到类的分配情况不再发生改变，实现了类的生成。<br>通常，出于实际的考虑决定了K的选择。在统计学上不存在最优的类数。</p></blockquote><h3 id="层次聚类">层次聚类</h3><ul><li><p>树状图<br>一种可视化表示，显示了记录及其所属类的层次结构。</p></li><li><p>距离<br>测量两个记录之间的接近程度。</p></li><li><p>相异性<br>测量两个类之间的接近程度。</p></li></ul><blockquote><p>层次聚类算法开始时，每条记录单独构成一个类。<br>在凝聚算法中，类逐步与相邻的类合并，直到所有记录属于单一类。<br>凝聚算法的类历史可以被保留并绘制出来。用户（无须预先指定类数）可以在算法执行的各个阶段，可视化地查看类数和类的结构。<br>有多种方法可以计算类之间的距离。这些方法都依赖于所有记录间距离。</p></blockquote><h3 id="基于模型的聚类">基于模型的聚类</h3><blockquote><p>基于模型的聚类方法假设类是由不同数据生成过程所生成的，各个数据生成过程具有不同的概率分布。<br>基于模型的聚类方法拟合了不同的模型，假设有不同数量的分布（通常是正态分布）。<br>基于模型的聚类方法无须使用过多的参数（即过拟合），就能选出一个能很好地拟合数据的模型（以及类数）。</p></blockquote><h3 id="变量的缩放和分类变量">变量的缩放和分类变量</h3><ul><li><p>缩放<br>缩小或放大数据的方法，常用于将多个变量缩放到同一尺度上。</p></li><li><p>归一化 (标准化)<br>一种通过减去均值并除以标准偏差进行缩放的方法。</p></li><li><p>高氏距离（Gower’s distance）<br>一种应用于数值数据和类别数据相混合的缩放算法。它可以将所有变量缩放到[0, 1]范围内。</p></li></ul><blockquote><p>以不同尺度测量的变量，需要转换到相似的尺度上。这样，变量对算法的影响不会主要由变量的尺度决定。<br>归一化（标准化）是一种常用的缩放方法——减去均值再除以标准偏差计算。<br>另一种缩放方法是高氏距离，它将所有的变量缩放到[0, 1]范围内。高氏距离通常用于含有数值型数据和分类数据的混合数据。</p></blockquote><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://www.amazon.cn/dp/B07MNV5MSN" target="_blank" rel="noopener">面向数据科学家的实用统计学</a></p>]]></content>
    
    <summary type="html">
    
      重要的统计学概念
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="DAE" scheme="https://neo1989.net/tags/DAE/"/>
    
      <category term="Math" scheme="https://neo1989.net/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Pandas常用</title>
    <link href="https://neo1989.net/CheatSheet/CHEATSHEET-pandas/"/>
    <id>https://neo1989.net/CheatSheet/CHEATSHEET-pandas/</id>
    <published>2021-01-12T07:50:19.000Z</published>
    <updated>2021-02-07T08:31:34.173Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你可以不用，但你不能不会。</p></blockquote><table><thead><tr><th style="text-align:left">Grammar</th><th style="text-align:center">Explanation / Examples</th></tr></thead><tbody><tr><td style="text-align:left"><strong>Importing Data</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.read_csv(filename)</td><td style="text-align:center">From a CSV file</td></tr><tr><td style="text-align:left">pd.read_table(filename)</td><td style="text-align:center">From a delimited text file (like TSV)</td></tr><tr><td style="text-align:left">pd.read_excel(filename)</td><td style="text-align:center">From an Excel file</td></tr><tr><td style="text-align:left">pd.read_sql(query, connection_object)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.read_json(json_string)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.read_html(url)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.DataFrame(dict)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>Exporting Data</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.to_csv(filename)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.to_sql(table_name, connection_object)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.to_json(filename)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>Create Test Objects</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.DataFrame(np.random.rand(20, 5))</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.Series(my_list)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.index = pd.date_range(‘1900/1/30’, periods=df.shape[0])</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>Viewing / Inspecting Data</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.head(n)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.tail(n)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.shape</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.describe()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.value_counts()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>Selection</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df[col]</td><td style="text-align:center">Returns column with label col as Series</td></tr><tr><td style="text-align:left">df[[col1, col2]]</td><td style="text-align:center">Returns columns as a new DataFrame</td></tr><tr><td style="text-align:left">ss.iloc[0]</td><td style="text-align:center">Selection by position</td></tr><tr><td style="text-align:left">df.iloc[0, :]</td><td style="text-align:center">First row</td></tr><tr><td style="text-align:left">df.iloc[0, 0]</td><td style="text-align:center">First element of first column</td></tr><tr><td style="text-align:left"><strong>Data Cleaning</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.columns = [‘a’,‘b’,‘c’]</td><td style="text-align:center">Rename columns</td></tr><tr><td style="text-align:left">pd.isnull()</td><td style="text-align:center">Checks for null Values, Returns Boolean Arrray</td></tr><tr><td style="text-align:left">pd.notnull()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.dropna()</td><td style="text-align:center">Drop all rows that contain null values</td></tr><tr><td style="text-align:left">df.dropna(axis=1)</td><td style="text-align:center">Drop all columns that contain null values</td></tr><tr><td style="text-align:left">df.dropna(axis=1, thresh=n)</td><td style="text-align:center">Drop all rows have have less than n non null values</td></tr><tr><td style="text-align:left">df.fillna(x)</td><td style="text-align:center">Replace all null values with x</td></tr><tr><td style="text-align:left">ss.fillna(ss.mean())</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">ss.astype(float)</td><td style="text-align:center">Convert the datatype of the series to float</td></tr><tr><td style="text-align:left">ss.replace(1, ‘one’)</td><td style="text-align:center">Replace all values equal to 1 with ‘one’</td></tr><tr><td style="text-align:left">ss.replace([1, 3], [‘one’, ‘three’])</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.rename(columns=lambda x: x + 1)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.rename(columns={‘old_name’: ‘new_ name’})</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.set_index(‘column_one’)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.rename(index=lambda x: x + 1)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>Filter, Sort, and Groupby</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df[df[col].gt(0.5)]</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df[(df[col] &gt; 0.5) &amp; (df[col] &lt; 0.7)]</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.sort_values(col1)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.sort_values(col2, ascending=False)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.sort_values([col1,col2], ascending=[True, False])</td><td style="text-align:center">Sort values by col1 in ascending order then col2 in descending order</td></tr><tr><td style="text-align:left">df.groupby(col)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.groupby([col1, col2])</td><td style="text-align:center">Returns groupby object for values from multiple columns</td></tr><tr><td style="text-align:left">df.pivot_table(index=col1, values=[col2, col3], aggfunc=np.mean)</td><td style="text-align:center">Create a pivot table that groups by col1 and calculates the mean of col2 and col3</td></tr><tr><td style="text-align:left">df.groupby(col1).agg(np.mean)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.apply(np.mean)</td><td style="text-align:center">Apply the function np.mean() across each column</td></tr><tr><td style="text-align:left">df.apply(np.max, axis=1)</td><td style="text-align:center">Apply the function np.max() across each row</td></tr><tr><td style="text-align:left"><strong>Join / Combine</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df1.append(df2)</td><td style="text-align:center">Add the rows in df1 to the end of df2 (columns should be identical)</td></tr><tr><td style="text-align:left">pd.concat([df1, df2], axis=1)</td><td style="text-align:center">Add the columns in df1 to the end of df2 (rows should be identical)</td></tr><tr><td style="text-align:left">df1.join(df2, on=col1, how=‘inner’)</td><td style="text-align:center">SQL-style</td></tr><tr><td style="text-align:left"><strong>Statistics</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.describe()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.mean()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.corr()</td><td style="text-align:center">Returns the correlation between columns in a DataFrame</td></tr><tr><td style="text-align:left">df.count()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.max()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.min()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.median()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.std()</td><td style="text-align:center"></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      Save more time.
    
    </summary>
    
    
      <category term="CheatSheet" scheme="https://neo1989.net/categories/CheatSheet/"/>
    
    
      <category term="DAE" scheme="https://neo1989.net/tags/DAE/"/>
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
  </entry>
  
  <entry>
    <title>Excel必会</title>
    <link href="https://neo1989.net/CheatSheet/CHEATSHEET-excel-formulas/"/>
    <id>https://neo1989.net/CheatSheet/CHEATSHEET-excel-formulas/</id>
    <published>2021-01-08T06:54:55.000Z</published>
    <updated>2021-02-02T06:30:45.042Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你可以不用，但你不能不会。</p></blockquote><h3 id="常用公式">常用公式</h3><table><thead><tr><th style="text-align:left">Formula</th><th style="text-align:center">Grammar</th><th style="text-align:center">Explanation / Examples</th></tr></thead><tbody><tr><td style="text-align:left"><strong>日期时间类</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">DATE</td><td style="text-align:center">DATE(year, month, day)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">DAYS</td><td style="text-align:center">DAYS(end_date, start_date)</td><td style="text-align:center">返回两个日期之间的天数</td></tr><tr><td style="text-align:left">DAY</td><td style="text-align:center">DAY(serial_number)</td><td style="text-align:center">返回一个月中的第几天的数值 [1, 31]</td></tr><tr><td style="text-align:left">MONTH</td><td style="text-align:center"></td><td style="text-align:center">返回月份值 [1, 12]</td></tr><tr><td style="text-align:left">YEAR</td><td style="text-align:center"></td><td style="text-align:center">返回日期的年份值 [1900, 9999]</td></tr><tr><td style="text-align:left"><strong>统计类</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">COUNT</td><td style="text-align:center"></td><td style="text-align:center">计算区域中包含数字的单元格的个数</td></tr><tr><td style="text-align:left">COUNTA</td><td style="text-align:center"></td><td style="text-align:center">计算区域中非空单元格的个数</td></tr><tr><td style="text-align:left">COUNTBLANK</td><td style="text-align:center"></td><td style="text-align:center">计算某个区域中空单元格的数目</td></tr><tr><td style="text-align:left">COUNTIF</td><td style="text-align:center">COUNTIF(range, criteria)</td><td style="text-align:center">计算某个区域中满足给定条件的单元格数目</td></tr><tr><td style="text-align:left">COUNTIFS</td><td style="text-align:center"></td><td style="text-align:center">统计一组给定条件所指定的单元格数</td></tr><tr><td style="text-align:left">SUM</td><td style="text-align:center"></td><td style="text-align:center">计算单元格区域中所有数值的和</td></tr><tr><td style="text-align:left">SUMIF</td><td style="text-align:center"></td><td style="text-align:center">对满足条件的单元格求和</td></tr><tr><td style="text-align:left">SUMIFS</td><td style="text-align:center"></td><td style="text-align:center">对一组给定条件指定的单元格求和</td></tr><tr><td style="text-align:left">SUMPRODUCT</td><td style="text-align:center"></td><td style="text-align:center">点积</td></tr><tr><td style="text-align:left">FREQUENCY</td><td style="text-align:center">FREQUENCY(data_array, bins_array)</td><td style="text-align:center">以一列垂直数组返回一组数据的频率分布</td></tr><tr><td style="text-align:left">MAX</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">MIN</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">RANK</td><td style="text-align:center"></td><td style="text-align:center">返回某数字在一列数字中相对于其他数值的大小排名</td></tr><tr><td style="text-align:left">RAND</td><td style="text-align:center"></td><td style="text-align:center">返回大于或等于 0 且小于 1 的平均分布随机数</td></tr><tr><td style="text-align:left">RANDBETWEEN</td><td style="text-align:center">RANDBETWEEN(bottom, top)</td><td style="text-align:center">返回一个介于指定的数字之间的随机数</td></tr><tr><td style="text-align:left">AVERAGEA</td><td style="text-align:center"></td><td style="text-align:center">算数平均数</td></tr><tr><td style="text-align:left">QUARTILE</td><td style="text-align:center">QUARTILE(array, quart)</td><td style="text-align:center">返回一组数据的四分位点</td></tr><tr><td style="text-align:left">VAR</td><td style="text-align:center"></td><td style="text-align:center">方差</td></tr><tr><td style="text-align:left">STDEV</td><td style="text-align:center"></td><td style="text-align:center">标准差</td></tr><tr><td style="text-align:left">TTEST</td><td style="text-align:center">TTEST(array1, array2, tails, type)</td><td style="text-align:center">返回t-检验的概率值</td></tr><tr><td style="text-align:left">CHITEST</td><td style="text-align:center">CHITEST(actual_range, expected_range)</td><td style="text-align:center">返回独立性检验的结果: 针对统计和相应的自由度返回卡方分布值</td></tr><tr><td style="text-align:left">FTEST</td><td style="text-align:center">FTEST(array1, array2)</td><td style="text-align:center">返回的是当 Array1 和 Array2 的方差无明显差异时的双尾概率</td></tr><tr><td style="text-align:left"><strong>关联匹配类</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">INDEX</td><td style="text-align:center">INDEX(…)</td><td style="text-align:center">在给定的单元格区域中，返回特定行列交叉处单元格的值或引用</td></tr><tr><td style="text-align:left">LOOKUP</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">VLOOKUP</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">MATCH</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">ROW</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">COLUMN</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">OFFSET</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>逻辑运算类</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">IF</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">IF*</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">AND</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">OR</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">IS*</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>数据清洗类</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">TRIM</td><td style="text-align:center"></td><td style="text-align:center">清除掉单元格两边的空格</td></tr><tr><td style="text-align:left">CONCATENATE</td><td style="text-align:center"></td><td style="text-align:center">将多个文本字符串合并成一个</td></tr><tr><td style="text-align:left">REPLACE</td><td style="text-align:center">REPLACE(old_text, start_num, num_chars, new_text)</td><td style="text-align:center">通过下标替换字符串</td></tr><tr><td style="text-align:left">SUBSTITUTE</td><td style="text-align:center">SUBSTITUTE(text, old_text, new_text, instance_num)</td><td style="text-align:center">通过内容替换字符串</td></tr><tr><td style="text-align:left">LEFT / MID / RIGHT</td><td style="text-align:center"></td><td style="text-align:center">截取字符串</td></tr><tr><td style="text-align:left">LEN / LENB</td><td style="text-align:center"></td><td style="text-align:center">字符串长度</td></tr><tr><td style="text-align:left">FIND</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">SEARCH</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">INT</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">RAOUND</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h3 id="常见错误">常见错误</h3><table><thead><tr><th style="text-align:left">Error</th><th style="text-align:center">Explanation</th></tr></thead><tbody><tr><td style="text-align:left">#####!</td><td style="text-align:center">计算结果过长，单元格容纳不下；增加列宽可解决</td></tr><tr><td style="text-align:left">#DIV/0</td><td style="text-align:center">除数为0，或公式被空单元格除</td></tr><tr><td style="text-align:left">#N/A</td><td style="text-align:center">公式中无可用数值，或缺少函数参数</td></tr><tr><td style="text-align:left">#NAME?</td><td style="text-align:center">引用了无法识别的名称</td></tr><tr><td style="text-align:left">#NULL!</td><td style="text-align:center">使用了错误的区域运算符，或错误的单元格引用</td></tr><tr><td style="text-align:left">#NUM!</td><td style="text-align:center">在需要数字参数的地方使用了无法接受的参数，或计算结果过大过小</td></tr><tr><td style="text-align:left">#RFF!</td><td style="text-align:center">引用了无效的单元格</td></tr><tr><td style="text-align:left">#VALUE!</td><td style="text-align:center">公式中含有一个错误类型的参数或操作数</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      Save more time.
    
    </summary>
    
    
      <category term="CheatSheet" scheme="https://neo1989.net/categories/CheatSheet/"/>
    
    
      <category term="DAE" scheme="https://neo1989.net/tags/DAE/"/>
    
  </entry>
  
  <entry>
    <title>The End Is Not the End, 2020</title>
    <link href="https://neo1989.net/SeizeTheDay/SUMMARY-2020/"/>
    <id>https://neo1989.net/SeizeTheDay/SUMMARY-2020/</id>
    <published>2020-12-31T14:22:00.000Z</published>
    <updated>2022-11-18T16:11:33.097Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Always walk in the middle of the road.</p></blockquote><h3 id="〖-2020-〗">〖 2020! 〗</h3><ul><li>COVID-19</li><li>科比·布莱恩特逝世, “<a href="/SeizeTheDay/Bryant-2-and-24/"><strong>Mamba out</strong></a>”</li><li>接手ETL、数据分析</li><li>入门<a href="/tags/ML"><strong>机器学习</strong></a></li><li>上手NLP、搜索引擎相关</li><li>换了台MBP-i7-32G，终于能本地跑腾讯的词向量了</li><li>国庆期间，海南万宁第一次真冲浪</li><li>业余开发了个小程序：间读记。利用NLP技术的短句推荐</li></ul><h3 id="〖-2021-〗">〖 2021? 〗</h3><ul><li>深入机器学习、数据分析</li></ul>]]></content>
    
    <summary type="html">
    
      The summary of 2020 and new year&#39;s resolution.
    
    </summary>
    
    
      <category term="SeizeTheDay" scheme="https://neo1989.net/categories/SeizeTheDay/"/>
    
    
  </entry>
  
</feed>
