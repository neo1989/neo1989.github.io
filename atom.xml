<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>愚苏记</title>
  
  <subtitle>To no avail but try.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://neo1989.net/"/>
  <updated>2021-04-21T13:46:59.246Z</updated>
  <id>https://neo1989.net/</id>
  
  <author>
    <name>Neo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《超级自控力》</title>
    <link href="https://neo1989.net/ReadingNotes/NOTE-super-self-control/"/>
    <id>https://neo1989.net/ReadingNotes/NOTE-super-self-control/</id>
    <published>2021-04-21T07:05:36.000Z</published>
    <updated>2021-04-21T13:46:59.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打造远离拖延的环境">打造远离拖延的环境</h2><h3 id="保持办公桌的干净整洁-–-断舍离">保持办公桌的干净整洁 – 断舍离</h3><ul><li>各种书籍、文件分类摆放</li><li>利用一些文具，诸如笔筒、书立、文件夹等</li><li>定时筛选、丢掉废弃纸质文件和其他垃圾</li><li>保留必须物品，其他的全部扔掉或者赠送给有需要的人</li></ul><h3 id="收起那些耽误正事的杂物">收起那些耽误正事的杂物</h3><ul><li>工作时手机关机（静音），必要时用电脑登录社交软件</li><li>卸载非必要APP，同种类型的只留下最好的那个</li><li>如果每天有大量信息需要处理，可以规划好每天固定的时间回复消息</li><li>不断进行心理暗示，不要在无聊的事情上浪费时间</li></ul><h3 id="远离假装努力的积极废人">远离假装努力的积极废人</h3><ul><li>少立flag</li><li>不要用战略上勤奋掩盖战术上的懒惰</li><li>主动远离懒惰、不自律者</li></ul><h3 id="让自己的生活尽量规律化">让自己的生活尽量规律化</h3><blockquote><p>真正规律化的生活是，在特定的时间做特定的事情，不要让一件事情上的焦虑影响另外一件事情的进行。</p></blockquote><ul><li>制定计划，合理分配时间</li><li>给自己留出独立的工作时间，减少干扰因素</li><li>将休闲娱乐与工作学习明确划分开</li><li>设置自我奖励机制，按时作息就奖励自己一个小礼物</li><li>让家人或朋友帮忙监督</li><li>利用好碎片化时间处理未完成的事情</li><li>睡前将手机等电子产品关机并收纳到抽屉里</li></ul><h3 id="及时疏解内在的消极情绪">及时疏解内在的消极情绪</h3><ul><li>倾诉，给压抑的心情一个出口</li><li>进行自我审视，找出消极情绪的根源</li><li>积极寻找帮助，切实解决问题</li><li>通过做自己喜欢的事情来打退消极情绪</li></ul><h3 id="多跟优秀自律的人在一起">多跟优秀自律的人在一起</h3><ul><li>跳出原本的惰性生活状态，主动向优秀的同事、朋友请教</li><li>利用互联网及时了解行业信息</li><li>关注行业中的佼佼者，通过互联网平台汲取经验</li><li>适当参加一些业内成功人士的分享活动</li><li>大胆迈出第一步，主动结识优秀者</li></ul><h2 id="设立有切实意义的目标">设立有切实意义的目标</h2><h3 id="用目标改变虚耗精力的状态">用目标改变虚耗精力的状态</h3><blockquote><p>“目标的坚定是性格中最必要的力量源泉之一，也是成功的利器之一，没有它，天才也会在矛盾屋顶的迷径中，徒劳无功”</p></blockquote><ul><li>你想在哪个领域获得成功</li><li>具体想得到什么样的收获</li><li>为了实现这个目标你要完成哪些事情</li><li>把这个事情分摊下来，每一天需要完成多少</li><li>思考在完成这件事情的过程中可能遇到的阻碍</li><li>你可能会因为什么原因放弃目标</li><li>怎样克服实现目标过程中的困难和阻碍因素</li><li>如果发现目标不恰当该如何调整</li><li>除了当前方案外是否还有plan B</li><li>你需要和谁一起完成这个目标</li></ul><h3 id="掌握指定目标的SMART原则">掌握指定目标的SMART原则</h3><ul><li>S（specific）： 明确性，不能笼统和抽象</li><li>M（measurable）：衡量性，即需要量化</li><li>A（attainable）：可实现性，目标不可过高或过低，要适量</li><li>R（realistic）：相关性，与主要目标要相关</li><li>T（time bound）：时限性，即完成目标的时间期限</li></ul><h3 id="为目标附加Deadline">为目标附加Deadline</h3><ul><li>番茄钟</li><li>设立deadline，不可太过迟缓，也不能操之过急</li></ul><h3 id="把大目标分解成小目标">把大目标分解成小目标</h3><blockquote><p>“每一步都走向一个最终要到达的目标，这并不够，应该每一站都有一个目标，每一步都有自有价值。”</p></blockquote><ul><li>把漫长的征途划分为一段一段，每当你到达一站的时候心理都会充满无尽的欢喜，然后充满激情的冲向下一站。</li></ul><h3 id="每天都要有可实现的目标">每天都要有可实现的目标</h3><blockquote><p>“合抱之木，生于毫末；九层之台，起于垒土；千里之行，始于足下。”</p></blockquote><h3 id="列好实现目标的具体步骤">列好实现目标的具体步骤</h3><ul><li>你想要实现什么样的目标？</li><li>为了实现这个目标你需要花多长时间？</li><li>要想实现这个目标你需要做哪些事情？</li><li>第一步是什么，需要在什么时间完成？</li><li>第二步，第三步，以及后续呢？</li><li>你的早晨、睡前这两个黄金时间如何安排？</li><li>如何完成这些具体的、细小的步骤？</li><li>当你遇到瓶颈的时候要怎么解决，咨询专业人士、上网查询资料或是其他？</li></ul><h3 id="有变动及时调整目标">有变动及时调整目标</h3><blockquote><p>一个正确的目标给人的动力是巨大的，而错误的目标却会把我们引入错误的方向，方向错，步步错。</p></blockquote><ul><li>有变动时，及时调整目标。</li></ul><h2 id="成为高校的行动派">成为高校的行动派</h2><h3 id="改掉习惯性担忧的毛病">改掉习惯性担忧的毛病</h3><blockquote><p>担忧可以归纳为：为已经发生的事情而担忧；为还没有发生的事情而担忧；担忧付出了努力却得不到满意的结果。</p></blockquote><ul><li>给自己心理暗示：担忧是无用的</li><li>找到担忧的原因，即：你面临着什么问题</li><li>思考解决问题的办法</li><li>明白这样一个道理：已经发生的事情，担忧没有用；还未发生的事情尚有时间想办法补救，担忧没有必要；努力了却不一定能成功的事情，做到内心无悔即可。</li><li>从生理上减缓担忧：运动、呼吸新鲜空气、拥有充分的睡眠和健康的饮食。</li><li>珍爱身边的朋友，建立积极的社交关系，可以向朋友诉说自己的担忧和苦恼</li><li>把目光放长远，保持心胸豁达</li><li>以一种平淡随然的态度面对生活</li></ul><h3 id="想做一件事立刻就行动">想做一件事立刻就行动</h3><blockquote><p>“我们一直推迟我们知道最终无法逃避的事情，这样的蠢行是一个普遍的人类弱点，它或多或少都盘踞在每个人的心灵里。”</p></blockquote><ul><li>做出初始行动 （前奏）</li></ul><h3 id="对抗趋乐避苦的懒惰本能">对抗趋乐避苦的懒惰本能</h3><ul><li><p>除了努力、拼命上进之外没有别的选择，为环境所迫，因而在极端的环境下爆发，为了生存只能吃苦磨砺，如果放弃挣扎选择了物质上的舒适，就意味着死亡或溃败。</p></li><li><p>有选择的空间，向前一步可以有更好的生活，向后一步也不至于落到深渊，一分耕耘一分收获。</p></li><li><p>行动力来源于清晰而深刻的认知。</p></li></ul><h3 id="今天的事不要推到明天做">今天的事不要推到明天做</h3><blockquote><p>“一天也不能虚度，要下定决心把可能完成的事情一把抓住然后紧紧抱住，有机会就绝不任其逃走，而且必定要贯彻执行”</p></blockquote><ul><li>把握好“黄金时间段”</li><li>抓住零碎时间</li><li>合理排序，科学工作</li><li>提高专注力</li></ul><h3 id="克服虎头蛇尾的三分钟热度">克服虎头蛇尾的三分钟热度</h3><ul><li>一段时间内只专注一件事</li><li>不断发掘生活的乐趣，避免陷入枯燥和厌倦的状态</li><li>指定循序渐进的计划</li><li>寻找志同道合的伙伴，互相监督、一起同行</li></ul><h3 id="讨厌的事情也得认真做好">讨厌的事情也得认真做好</h3><blockquote><p>很多人之所以拖延，是因为他讨厌某件事情</p></blockquote><ul><li>这件事情重要吗？</li><li>讨厌的原因是什么，是因为不擅长还是因为回报周期太长</li><li>做了这件不喜欢的事情你能收获什么？</li><li>如果不做会有什么样的后果？</li><li>你有选择不做的余地吗？</li><li>如果不做这件事情，你还有别的效益更大化的选择吗？</li><li>你有多长时间来完成这件事情，时间允许你拖延吗？</li><li>怎样才能让这个过程不那么枯燥？</li></ul><h2 id="让时间的价值最大化">让时间的价值最大化</h2><h3 id="把事情按照轻重缓急排序">把事情按照轻重缓急排序</h3><blockquote><p>以“价值”为基础排序。我们做任何事情都脱离不了其价值意义。</p></blockquote><ul><li>重要且紧急的事情</li><li>重要但不紧急的事情</li><li>紧急但不重要的事情</li><li>不紧急也不重要的事情</li></ul><h3 id="用好高效的“黄金时间”">用好高效的“黄金时间”</h3><blockquote><p>“普通人只想如何打发时间，有才能的人则设法利用时间。”</p></blockquote><ul><li>早晨6点（记忆力最佳）</li><li>8-10点（思维最活跃）</li><li>18-20点（最沉着）</li><li>入睡前的时间（加强记忆最好的时间）</li></ul><p>如何定位“黄金时间”</p><ul><li>在备忘录上列出每日事项</li><li>列出自己能够抽出来的所有时间</li><li>找出周围环境最好、最适宜的时间段，即为黄金时间</li><li>把最重要的事情放在“黄金时间”段完成</li><li>其他事项放在其他时间完成</li></ul><p>如何打造“黄金时间”</p><ul><li>自然环境上：以舒适、开阔、安静为重要元素</li><li>生理上：头脑清醒、充满活力、思维清晰的时间段最好</li><li>生活换教室：排除手机等移动设备的干扰，让自己更加专注</li><li>时间段的选取上：尽量选择大段的时间，不至于在执行任务的过程中被打断</li></ul><h3 id="重视不起眼的零碎时间">重视不起眼的零碎时间</h3><ul><li>利用“衔接式”时间</li><li>利用“并列式”时间</li><li>减少零碎时间</li></ul><h3 id="一次用心把事情做好">一次用心把事情做好</h3><blockquote><p>“逐二兔者不得其一”</p></blockquote><ul><li>人的精力有限</li><li>思绪具有连贯性</li><li>一次只做一件事</li></ul><h3 id="拒绝那些让自己分心的事">拒绝那些让自己分心的事</h3><blockquote><p>让我们分心的事情大概有：周围的环境；他人正在做的事情；乱七八糟的思绪；</p></blockquote><ul><li>删繁就简</li><li>摒弃杂念</li></ul><h3 id="无谓的细节无须浪费时间">无谓的细节无须浪费时间</h3><blockquote><p>把时间和精力花费在最重要的地方</p></blockquote><p>什么样的细节是无谓的细节</p><ul><li>日常生活中的细节</li><li>工作中的“次要任务”</li></ul><h3 id="掌握时间管理的二八法则">掌握时间管理的二八法则</h3><blockquote><p>用80%的时间去完成那最关键的20%的事情。</p></blockquote><p>如何确定那重要性为80%的事情?</p><ul><li>寻找效益最大化的事项</li><li>截止日期即将到来的事项</li></ul><h3 id="学会使用高效的番茄工作法">学会使用高效的番茄工作法</h3><p>番茄工作法的好处</p><ul><li>提升注意力，劳逸结合</li><li>减轻焦虑感，加强决心</li><li>改善任务流程，减少干扰因素</li></ul><h2 id="把逃避彻底删掉">把逃避彻底删掉</h2><h3 id="认识到问题与痛苦的价值">认识到问题与痛苦的价值</h3><blockquote><p>正路不一定就是一条平坦的直路，难免有曲折和崎岖坎坷，要绕一些弯，甚至难免会误入歧途。</p></blockquote><ul><li>攻克难题过程中收获的经验</li><li>苦尽甘来的收获</li></ul><h3 id="越是恐惧的事情越要去面对">越是恐惧的事情越要去面对</h3><ul><li>写出你的恐惧</li><li>列出最坏的结果</li><li>指定紧密的工作计划，用行动稀释恐惧</li></ul><h3 id="承认问题是解决问题的开始">承认问题是解决问题的开始</h3><blockquote><p>人们通常不会承认两类事情：不承认自我天赋的缺乏；不承认现实存在的、难以解决的问题。</p></blockquote><ul><li>不要对自己过于苛刻</li><li>让家人或朋友成为你的“参谋师”</li><li>明白一切问题都有解决的办法</li></ul><h3 id="不要总是指望别人替你解决问题">不要总是指望别人替你解决问题</h3><blockquote><p>“不论踩什么样的高跷，没有自己的能力是不行的。”</p></blockquote><ul><li>没有人能永远陪伴在你身边</li><li>人际关系的本质是潜在的价值交换</li></ul><p>什么时候靠自己，什么时候寻求帮助？</p><ul><li>能自己独立完成的任务不必寻求他人的帮助</li><li>自己努力一下就可以做到的事情不必劳烦他人</li><li>同事、朋友之间尽量互帮互助，不要单方面接受而不给与</li><li>在团队工作中公平分配任务</li><li>需要他人协助的事情可以向他人寻求帮助和支持</li></ul><h3 id="认清你给自己找的拖延借口">认清你给自己找的拖延借口</h3><blockquote><p>拖延的借口：问题难以解决，因此搁置；总认为还来得及；内心的恐惧；“我很忙”</p></blockquote><ul><li>眼下最紧急的事情是什么？</li><li>你最想做的事情是什么？</li><li>后一项是非做不可的吗？</li><li>思考“你想做的”和“你应该做的”这两件事会带来什么好处跟坏处？</li><li>哪些事效益最大化，损失最小化的事情？</li></ul><blockquote><p>“最珍贵的是今天，最容易失掉的也是今天。”</p></blockquote><h3 id="对工作保持积极主动的态度">对工作保持积极主动的态度</h3><ul><li>保持规律的作息、健康的饮食</li><li>给自己积极的心理暗示</li><li>常做那些“高能量姿势” （“神奇女校”姿势）</li></ul><h3 id="用“做做看”代替对结果的计较">用“做做看”代替对结果的计较</h3><blockquote><p>“现实是此案，理想是彼岸，中间隔着湍急的合理，行动则是加载川上的桥梁。”</p></blockquote><ul><li>“做”不是一个一成不变的过程</li><li>“做做看”的本质在于突破自我</li><li>珍惜试错的机会的成本</li></ul><h3 id="遇到困难不找借口找方法">遇到困难不找借口找方法</h3><blockquote><p>“人的一切痛苦，本质上都是对自己无能的愤怒。”</p></blockquote><ul><li>我应该怎样解决这个问题，并达到我的目标？</li></ul><h3 id="不求完美但求尽最大的努力">不求完美但求尽最大的努力</h3><blockquote><p>相较于成为一名“完美主义者”，你应该成为一名“现实主义者”。</p></blockquote><ul><li>不存在绝对的完美</li><li>人的欲望是无止境的</li><li>过程比结果更重要</li><li>真实比完美更有力量</li></ul><h3 id="敢于平凡让你更有“底气”">敢于平凡让你更有“底气”</h3><ul><li>平凡不等于平庸</li></ul><h2 id="拆掉思维的壁垒">拆掉思维的壁垒</h2><h3 id="删除“我必须”的思维模式">删除“我必须”的思维模式</h3><ul><li>“我必须”表现出来的是一种不自信，而“我可以”、“我能做到”则是一种自信满满的状态。</li></ul><h3 id="认清自己的长板与短板">认清自己的长板与短板</h3><ul><li>多多尝试新事物，开拓新领域</li><li>采纳他人的合理意见和建议</li></ul><h3 id="绷得太紧时让自己停下来">绷得太紧时让自己停下来</h3><ul><li>身体上的休息</li><li>心理上的缓冲</li></ul><h3 id="别担心达不到完美的结果">别担心达不到完美的结果</h3><ul><li>这种担心是无效担心</li><li>100分纵然完美，80分也可以</li><li>苛求完美会给人带来巨大的压力</li></ul><h3 id="没有尝试之前别给自己设限">没有尝试之前别给自己设限</h3><blockquote><p>还没尝试就设限的人一般处于什么心理：自卑，认为自己不配得到更好的东西；过度重视外在因素的重要性</p></blockquote><ul><li>大胆说出你内心的渴望</li><li>大胆尝试和追求那些你以前不敢奢求的事物</li></ul><h3 id="努力跳出熟悉的心理舒适区">努力跳出熟悉的心理舒适区</h3><ul><li>那些看似“舒适”的状态，往往只是表象</li><li>一时的舒适并不能代表会一直舒适</li></ul><h3 id="防止过分内疚消耗你的精力">防止过分内疚消耗你的精力</h3><ul><li>告别内疚，无须在意他人的眼光</li><li>拖延不好，但只要按部就班做出改变，一定会发生转机</li></ul><h2 id="用自律换得自由">用自律换得自由</h2><h3 id="用延迟满足击退拖延的念头">用延迟满足击退拖延的念头</h3><ul><li>选择做重要且紧急的事情会有什么结果</li><li>选择做短暂又吸引人的事情会有什么结果</li></ul><h3 id="给自己设置一个合理的期望值">给自己设置一个合理的期望值</h3><p>什么是&quot;合理&quot;</p><ul><li>基于现实</li><li>比自己的实际水平稍高一点</li><li>设置你独特的期望值</li></ul><blockquote><p>这一路也行风雨兼程，但请你始终保持可贵的清醒，不要美化过程，不要自怨自艾，一切以客观现实为基础，希望你能成为那个“手可摘星辰”的人。</p></blockquote><h3 id="利用增长的事慢慢建立自信">利用增长的事慢慢建立自信</h3><blockquote><p>“要有信心，然后全力以赴——假如具有这种观念，任何事情十有八九都能成功。”</p></blockquote><ul><li>找到你擅长的事情</li><li>把擅长的事情做到极致</li><li>把擅长的事情和事业相结合</li></ul><h3 id="把自己想象成不拖延的人">把自己想象成不拖延的人</h3><ul><li>“见贤思齐”</li></ul><h3 id="懈怠时开启自我激励模式">懈怠时开启自我激励模式</h3><ul><li>强迫自己回想一遍最初的目标</li><li>看激励人心的影片、听励志音乐</li><li>对自己说：再坚持一会儿</li><li>主动向优秀的人看齐</li></ul><h3 id="借助奖惩措施改变行为模式">借助奖惩措施改变行为模式</h3><ul><li><p>作为“奖励”和“惩罚”的事物要精挑细选<br>作为奖励的事物，应该是你发自内心喜欢的，位于寻常生活只外的东西。<br>作为惩罚的事物，应当是你感性上渴望但理智上应该拒绝的事物。</p></li><li><p>不要为了“拿到奖励”而工作</p></li><li><p>设置奖惩措施，可以从小事做起</p></li></ul><h3 id="多给自己一些积极的暗示">多给自己一些积极的暗示</h3><ul><li><p>心理暗示不同于自我欺骗<br>前者是缺乏自信和勇气<br>后者是无中生有</p></li><li><p>了解一个人是很难的事情，与其向外界寻求肯定，不如向内寻找价值。</p></li></ul><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://www.amazon.cn/dp/B0828N77XX" target="_blank" rel="noopener">超级自控力训练计划</a></p>]]></content>
    
    <summary type="html">
    
      拖延的本质来源于内心的恐惧。这个恐惧有两层含义：任务本身的艰巨性；害怕失败带来的结果。
    
    </summary>
    
    
      <category term="ReadingNotes" scheme="https://neo1989.net/categories/ReadingNotes/"/>
    
    
      <category term="SoftSkills" scheme="https://neo1989.net/tags/SoftSkills/"/>
    
  </entry>
  
  <entry>
    <title>《沟通力》</title>
    <link href="https://neo1989.net/ReadingNotes/NOTE-ke-fu-zhi-de-gou-tong-li/"/>
    <id>https://neo1989.net/ReadingNotes/NOTE-ke-fu-zhi-de-gou-tong-li/</id>
    <published>2021-03-23T15:27:56.000Z</published>
    <updated>2021-03-24T12:39:48.931Z</updated>
    
    <content type="html"><![CDATA[<h2 id="沟通力是可以复制的">沟通力是可以复制的</h2><blockquote><p>如果说人类社会是一张网，那么每个人就是网上的结点，而人与人之间必须有线，才能互相连接，否则这些结点就无法形成网，无法成为组织、成为社会。人与人之间的这根“线”就是沟通。</p></blockquote><h3 id="沟通力为什么如此重要">沟通力为什么如此重要</h3><ul><li>提升社会竞争力</li><li>加速事业的成功</li><li>人际关系的润滑剂</li></ul><h3 id="沟通的目标不是“口服”而是“心服”">沟通的目标不是“口服”而是“心服”</h3><ul><li>有明确的沟通目标</li><li>善用语气、语调</li><li>用肢体语言为沟通加分</li></ul><h3 id="信息的准确传递与接收">信息的准确传递与接收</h3><ul><li>能够准确地表达自己的感受</li><li>表达时要直接、精确</li><li>运用深夜电台主持人般的声音 (温柔、缓慢、深沉)</li></ul><h3 id="每个人都能学会的沟通力">每个人都能学会的沟通力</h3><ul><li>学习科学的理论 (真实，完整，时效，同一，目标明确)</li><li>掌握正确的方法</li><li>一定要刻意练习</li></ul><h2 id="沟通的本质是尊重与合作">沟通的本质是尊重与合作</h2><blockquote><p>“尊人者，人尊之。”沟通中如果缺乏尊重，不能平衡自己与对方的需要，总以一种自以为是的方式与对方交流，这样的沟通是很难进行的。只有学会尊重与合作，沟通的过程才会愉快而积极，结果才能如你所愿。</p></blockquote><h3 id="了解自己对恐惧的反应">了解自己对恐惧的反应</h3><ul><li><p>合作为什么越来越难？<br>我们之所以生气、愤怒，其实是内心的恐惧在作祟</p></li><li><p>恐惧的根源<br>我们无法完全掌控局面的时候</p></li></ul><h3 id="从对方的视角看他的经历">从对方的视角看他的经历</h3><ul><li><p>什么是真正的尊重？<br>真正的尊重，应该是从他人的视角去看他们所经历的一切，也就是了解对方的“being”，哲学上称为“存在”。简而言之，就是了解对方此刻存在的状态是什么。</p></li><li><p>懂得尊重自己<br>“我”为什么会这样？“我”的哪些需要没有获得满足？</p></li><li><p>尊重是为了促进共赢</p></li></ul><h3 id="平衡自己与他人的需要">平衡自己与他人的需要</h3><ul><li><p>委屈和讨好<br>对自己的需要不太关注或关注度很低，总是把别人的需要放在第一位。（老好人）</p></li><li><p>控制和强势<br>对他人关注极少、只关注自己的需求。</p></li><li><p>忽视和无助<br>既不关注自己的需要，也不关注别人的需要。（不愿沟通）</p></li><li><p>尊重与合作<br>既关注他人的需要，也不忽视自己的需要。</p></li></ul><h3 id="学会处理情绪和信息">学会处理情绪和信息</h3><ul><li><p>知心大姐式<br>只关注其中的情感和关系。</p></li><li><p>冷面杀手式<br>永远只谈实际问题，从不谈感情。</p></li><li><p>拒绝沟通式<br>既不跟你谈信息，也不跟你谈感情，完全是一副拒绝沟通的模式。</p></li><li><p>沟通专家式<br>既会照顾对方的情感，也很懂得处理实际问题。</p></li></ul><h3 id="沟通之前先明确目标">沟通之前先明确目标</h3><ul><li>怎么才能记住沟通的目标<br>你要为自己创造什么？<br>你要为对方创造什么？<br>你需要为你们的关系创造什么？</li></ul><h3 id="不尊重的沟通方式有哪些">不尊重的沟通方式有哪些</h3><ul><li>喜欢给对方贴标签</li><li>忽视对方的感受</li><li>用威胁的口气说话</li><li>喜欢与别人攀比</li></ul><h2 id="沟通高手都善于掌控情绪">沟通高手都善于掌控情绪</h2><blockquote><p>当我们在沟通中遭遇不愉快，进而产生消极的情绪变化或心理状态时，最重要的是控制这种糟糕的情绪或心理蔓延，别让自己被情绪所左右，否则沟通效率会大打折扣。</p></blockquote><h3 id="停止你的暴力沟通">停止你的暴力沟通</h3><ul><li><p>暴力沟通如何出现的<br>道德评判<br>进行比较<br>回避责任<br>强人所难</p></li><li><p>沟通的公式<br>“我观察到……”<br>“我感觉……”<br>“是因为……”<br>“我请求……”</p></li></ul><h3 id="远离“傻瓜式”沟通">远离“傻瓜式”沟通</h3><ul><li>学会打破大脑中的思维惯性<br>更多地调动大脑前庭和大脑皮层的作用，去克服杏仁核和基底核给我们的沟通带来的情绪影响，远离“傻瓜式”沟通。</li></ul><h3 id="奖惩式沟通的代价">奖惩式沟通的代价</h3><ul><li><p>奖惩式沟通的表现<br>你表现好，我就奖励你；表现不好，我就惩罚你。</p></li><li><p>代价<br>破坏对方的安全感和信任感<br>打压对方的内驱力<br>剥夺了对方与你合作的快乐和愿望<br>让对方学会了用奖励和惩罚获得他想要的东西</p></li></ul><h3 id="沟通中切忌挖苦嘲笑">沟通中切忌挖苦嘲笑</h3><ul><li>明确沟通目的，理性交流</li><li>批评可以直接客观</li></ul><h3 id="不抱怨，把握沟通的尺度">不抱怨，把握沟通的尺度</h3><ul><li>表达感受，提出诉求</li><li>阐述诉求的原因</li><li>向对方提出你的建议</li></ul><h3 id="利用复述和认同感染对方">利用复述和认同感染对方</h3><ul><li><p>重复对方所说的话</p></li><li><p>告诉对方“你说得对”<br>让自己和对方产生一种情绪联结。</p></li></ul><h2 id="沟通要从了解需求开始">沟通要从了解需求开始</h2><blockquote><p>需求是沟通当中的重要因子，凡是沟通中出现的问题，多数是由需求不清晰或需求未能获得满足所致。这里的需求，既包括他人的需求，也包括自我需求。</p></blockquote><h3 id="洞悉对方真正需求，避免情绪积累">洞悉对方真正需求，避免情绪积累</h3><h3 id="人类共通的需求名单">人类共通的需求名单</h3><ul><li>朋友、集体、归属感</li><li>放松、休息、快乐</li><li>关注、理解、倾听</li><li>学习、探索、发现</li><li>选择、自由、自我</li><li>被认可、信任感、安全感</li><li>支持、尊重、爱</li></ul><h3 id="发掘和关注自我需求">发掘和关注自我需求</h3><h3 id="用给予礼物的心态去沟通">用给予礼物的心态去沟通</h3><ul><li>给予是人类的基本需求之一</li><li>你与他人有许多“礼物”可以互相给予</li><li>学会辨识“礼物”</li><li>慷慨地将“礼物”给予他人</li><li>从他人给予的“礼物”中学习和成长</li></ul><h3 id="让对方看到更多的选择空间">让对方看到更多的选择空间</h3><ul><li>具有富足心态的人看到的永远是自己拥有什么，自己还有哪些可选择的空间和可能性。</li><li>匮乏心态的本质就是“没的选”</li></ul><h2 id="营造安全的沟通氛围">营造安全的沟通氛围</h2><blockquote><p>当我们按照惯性思维与别人谈话时，通常会用自己最习惯的方式，但我们的惯性思维很可能让对方感觉不安全。这时候我们就需要打破惯性思维，主动营造一个安全的沟通氛围。</p></blockquote><h3 id="找到共同目的，让对方感受到理解">找到共同目的，让对方感受到理解</h3><ul><li><p>找出对方的真实目的，塑造共同目的<br>先一步做出让步。<br>进一步了解对方的真实目的。<br>塑造共同目的。</p></li><li><p>拓宽视野，塑造长远的共同目的</p></li><li><p>寻找联结，维护安全感，保持目的一致性</p></li></ul><h3 id="利用对比说明，防止冒犯和伤害">利用对比说明，防止冒犯和伤害</h3><ul><li>阐明自己的真实目的</li><li>说明你不想看到的结果</li><li>寻找一个两全其美的方法</li></ul><h3 id="标注对方情感，赢得对方接纳">标注对方情感，赢得对方接纳</h3><ul><li>定位情感：了解对方最关注什么</li><li>标注的常用句式：“看上去”“听起来”“似乎……”</li></ul><h3 id="合理使用道歉和“拔刺”">合理使用道歉和“拔刺”</h3><ul><li>道歉：当对方被激怒的时候</li><li>“拔刺”：当谈话还没正式开始的时候</li></ul><h3 id="气氛不对时先关注情绪再关注内容">气氛不对时先关注情绪再关注内容</h3><ul><li><p>学会做一个双核的对话人<br>一个核负责管理氛围、情绪，另一个核负责管理信息、内容。</p></li><li><p>通过心律共鸣营造气场</p></li><li><p>调整气场的几个高能量姿势<br>学学神奇女侠<br>练练瑜伽</p></li></ul><h2 id="用长颈鹿式沟通破解沟通困境">用长颈鹿式沟通破解沟通困境</h2><blockquote><p>长颈鹿有三个特点：高、反应慢、心脏大，这三个特点可以巧妙地运用到我们的沟通当中。心大，遇事不计较；反应慢，从不觉得什么事都会对自己有伤害；再加上它站得高，看得远，不会对眼前的小事斤斤计较。</p></blockquote><h3 id="长颈鹿式沟通的优势">长颈鹿式沟通的优势</h3><ul><li><p>高<br>站得高，可以看得远</p></li><li><p>反应慢<br>具备钝感力的人，大多会从容面对生活中的挫折和伤痛，也会坚定朝着自己的方向前进。</p></li><li><p>心脏大<br>不往心里去。</p></li></ul><h3 id="什么是长颈鹿式沟通">什么是长颈鹿式沟通</h3><ul><li><p>观察：只讲事实，不加入评判<br>把你看到和听到的东西准确地描述出来</p></li><li><p>感受：说出真实感受，挖掘真实需要<br>虽然感同身受有些难，但是沟通双方达成理解和包容却是可行的。<br>夫妻之间为什么总会发生争吵？因为我们所表达出来的通常都不是我们真实的感受，而是通过带有评判的观察之后臆测出来的对方的行为，这时候的沟通自然已经完全变了味，吵架也就在所难免了。</p></li><li><p>行动：提出具体可执行的请求</p></li></ul><h2 id="如何有效提问与倾听">如何有效提问与倾听</h2><blockquote><p>巧妙地提问可以促使对方进行深入思考，唤醒对方的内在动力，使对方努力去改变自己；倾听则既能满足他人自我表达的需要，又能巩固人与人之间的联结。只有学会提问和倾听，才能成为真正的沟通高手。</p></blockquote><h3 id="不要把建议变成批评">不要把建议变成批评</h3><ul><li><p>明确对方请教的真实意图</p></li><li><p>什么是内在动力？<br>你的内心当中想要把一件事做好的欲望。</p></li><li><p>用提问唤起对方的内在动力<br>通过恰当的提问和启发，引导对方深入、广泛地进行思考，让对方自己找到解决问题的方法，他的问题才能真正解决。</p></li></ul><h3 id="质疑式提问会打击对方积极性">质疑式提问会打击对方积极性</h3><p>提问是为了引发思考，而不是要将你的答案和解决方案直接告诉他人，以展示自己的分析和方案有多智慧，哪怕你心里有更好的答案也不要抢着说，而应通过巧妙地提问让对方先说出答案。同时，恰当的提问也能促使双方共同探讨，这样的沟通才会更加有效。</p><h3 id="启发式提问能激发对方责任感">启发式提问能激发对方责任感</h3><ul><li><p>什么是启发式提问<br>就是向对方提出一些带有启发性的问题，帮助对方的大脑打开一个新的窗口，让对方感觉“我真的没有思考过这些问题”，然后引导对方对这些问题进行深入的梳理，寻找能够真正解决问题的方法。</p></li><li><p>改变现状的标准路径<br>第一步: 觉知，即通过启发让一个人知道他有哪些问题，为什么自己会出现这些问题<br>第二步: 接纳，接纳自己的现状，哪怕现在的自己很糟糕，我们也仍然爱自己<br>第三部: 改变现状。</p></li><li><p>好的提问可以激发对方的行动</p></li></ul><h3 id="提问时对方才是主角">提问时对方才是主角</h3><ul><li><p>启发式提问分为三步<br>询问目标<br>询问现状<br>询问可选择的方法和路径</p></li><li><p>“我也没办法”<br>人会陷入一种“限制性想法”当中。什么是限制性想法？就是人会自己给自己设定很多限制，这些限制会让我们不敢或不愿去想。</p></li></ul><h3 id="放下自我，学会倾听">放下自我，学会倾听</h3><ul><li><p>我们为什么不愿倾听<br>放不下自己。<br>急于反驳。如果反驳效果不佳，我们又可能产生负面的情绪反应。</p></li><li><p>适当给予对方反馈</p></li><li><p>善于在倾听中吸收对方的信息</p></li><li><p>如何倾听<br>深呼吸<br>提问<br>复述</p></li></ul><h3 id="打造沟通的无错区">打造沟通的无错区</h3><p>“无错区”的意思其实是要将沟通双方的关注力从表面的“错误”转向深层的“需要”。</p><ul><li>将冲突看成一个需要解决的问题</li><li>确信你的需求可以获得满足</li><li>相信需求可以引出解决方案</li><li>用合作和联结化解冲突</li><li>对有效的方法庆祝，对无效的方法学习</li></ul><h2 id="用身体语言认识自己和他人">用身体语言认识自己和他人</h2><blockquote><p>人们总是会通过自己的肢体语言、面部表情和微妙暗示向他人传递各种信息，如果我们能正确判断这些信息，沟通就会变得愉快而顺畅。</p></blockquote><h3 id="避免用肢体语言暴露内心所想">避免用肢体语言暴露内心所想</h3><ul><li>减少缺乏自信的手势</li><li>注意紧张时的肢体动作</li></ul><h3 id="一眼看穿对方的微表情">一眼看穿对方的微表情</h3><ul><li>从面部表情猜测对方的情绪</li><li>小动作中表现出来的情绪</li></ul><h3 id="眼神透露出的心理活动">眼神透露出的心理活动</h3><ul><li>视线下移是在掩饰自己的胆怯和不自信</li><li>眼球快速转动是恐惧的表现</li><li>瞳孔变化暗示心理活动</li></ul><h3 id="展现高能量的身体姿态">展现高能量的身体姿态</h3><ul><li>运用与生俱来的骄傲姿态</li><li>正确运用体态语言的沟通力量</li><li>假装自己已经达成沟通目标</li></ul><h3 id="利用心理暗示调节自己的状态">利用心理暗示调节自己的状态</h3><ul><li>引导对方点头</li><li>用缓慢的语速说话</li><li>用表情和肢体动作改变情绪</li></ul><h2 id="让文字发挥力量">让文字发挥力量</h2><blockquote><p>相较于面对面的语言沟通，文字沟通会给沟通双方更多的思考时间，同时在传递语气和情绪方面也更考验智慧。</p></blockquote><h3 id="让文字沟通更专业和精准">让文字沟通更专业和精准</h3><ul><li>配合电话或会议</li><li>商务类书信的沟通</li><li>求职时要运用文字沟通</li></ul><h3 id="发挥文字沟通的优势">发挥文字沟通的优势</h3><ul><li>给彼此留出思考反应的时间</li><li>增加沟通的可信度</li></ul><h3 id="让文字沟通更高效的四个方法">让文字沟通更高效的四个方法</h3><ul><li>沟通目的要明确</li><li>信息传递要完整、准确</li><li>行文简洁，重点突出</li><li>语言表达恰当、合理</li></ul><h2 id="善用沟通力，提升决策力和影响力">善用沟通力，提升决策力和影响力</h2><blockquote><p>在需要做出决策和提升影响力时，高效的沟通力至关重要。出色的沟通力不仅能缓解你的紧张情绪，还能让你的发言更加吸引人，获得听众的共鸣。</p></blockquote><h3 id="如何在会议上高效沟通">如何在会议上高效沟通</h3><ul><li>会前准备充分</li><li>与会人员角色明确</li><li>学会换位思考</li><li>会议要充满创意</li><li>流程科学有序</li></ul><h3 id="利用头脑风暴法激发创意">利用头脑风暴法激发创意</h3><ul><li><p>对提出的意见不讨论、不评价</p></li><li><p>对各种观点都不要急于否认</p></li><li><p>头脑风暴法的流程<br>第一，明确本次会议讨论的具体问题，并且问题越具体、越详细越好。<br>第二，每个人都不要急于发言，而是先针对这个具体问题认真构思一下，把自己的想法整理下来。这个记录的过程就给了与会者独立思考的时间，有益于形成真正独特的思考。<br>第三，各自阐述，不对其他人的观点提出意见。在别人阐述观点时，我们也可以结合自己的想法继续完善方案，这样才能呈现出更多、更有效的解决方案。</p></li></ul><h3 id="六顶思考帽，让会议流程更科学">六顶思考帽，让会议流程更科学</h3><ul><li><p>“蓝帽子”思维<br>代表指挥官，担任着会议中指挥者或主持人的角色。</p></li><li><p>“白帽子”思维<br>代表理性和数据。</p></li><li><p>“黄帽子”思维<br>代表的就是乐观的、有希望的、有建设性的观点。</p></li><li><p>“黑帽子”思维<br>代表着否定、怀疑以及诸多问题，也就是我们常说的批判性思维。</p></li><li><p>“红帽子”思维<br>代表的是感觉、感受、直觉、预感等。</p></li><li><p>“绿帽子”思维<br>表示可以尽情地发挥自己的想象力和创造力，提出各种创意和解决问题的方法。</p></li></ul><h3 id="用平行思维法减少决策风险">用平行思维法减少决策风险</h3><h3 id="三步走，组织高效演讲">三步走，组织高效演讲</h3><ul><li><p>坡道<br>构建坡道的方法有很多，但要构建精彩的坡道只需思考一个问题：听众为什么要在意你的演讲？这个问题的答案就是一个绝妙的坡道。<br>坡道就是要把听众拉到你的演讲当中来。但有一点要注意，就是坡道的时间不要太长，你只有7秒钟的时间可用。</p></li><li><p>发现<br>用坡道成功地捕获了听众的注意力后，你即将说出自己的见解，应该可以引导听众有所发现和收获，而不是强制性地将信息灌输到他们的大脑之中。</p></li><li><p>甜点<br>这里要引起听众的情感共鸣，为听众创造一种感觉，比如紧迫感、诱惑感、惊喜感等。</p></li></ul><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://www.amazon.cn/dp/B088K5SQSM/" target="_blank" rel="noopener">可复制的沟通力</a></p>]]></content>
    
    <summary type="html">
    
      “克己复礼为仁”
    
    </summary>
    
    
      <category term="ReadingNotes" scheme="https://neo1989.net/categories/ReadingNotes/"/>
    
    
      <category term="SoftSkills" scheme="https://neo1989.net/tags/SoftSkills/"/>
    
  </entry>
  
  <entry>
    <title>《实用统计学》</title>
    <link href="https://neo1989.net/ReadingNotes/NOTE-practical-statistics/"/>
    <id>https://neo1989.net/ReadingNotes/NOTE-practical-statistics/</id>
    <published>2021-02-14T06:53:02.000Z</published>
    <updated>2021-03-14T15:32:41.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="探索性数据分析">探索性数据分析</h2><h3 id="结构化数据的组成">结构化数据的组成</h3><ul><li><p>连续型数据 (区间数据、浮点型数据、数值数据)<br>数据可在一个区间内取任何值。</p></li><li><p>离散型数据 (整数型数据、计数型数据)<br>数据只能取整数，例如计数。</p></li><li><p>分类型数据 (枚举数据、列举数据、因子数据、标称数据、多分支数据)<br>数据只能从特定集合中取值，表示一系列可能的分类。</p></li><li><p>二元数据 (二分数据、逻辑型数据、指示器数据、布尔型数据)<br>一种特殊的分类数据，数据值只能从两个值中取其一（例如0或1, True或False）。</p></li><li><p>有序数据 (有序因子数据)<br>具有明确排序的分类数据。</p></li></ul><blockquote><p>在软件中，数据通常按类型分类。<br>数据类型包括连续型数据、离散型数据、分类数据（其中包括二进制数据）和有序数据。<br>数据分类为软件指明了数据的处理方式。</p></blockquote><h3 id="矩形数据">矩形数据</h3><ul><li><p>数据框<br>电子表格等矩形数据是统计和机器学习模型中的基本数据结构。</p></li><li><p>数据特征 (属性、输入、预测因子、变量)<br>通常称数据表中的一列为一个特征。</p></li><li><p>结果 (因变量、响应、目标、输出)<br>不少数据科学项目涉及对结果的预测，常见的结果为“是”或“否”。特征有时在实验或研究中用于预测结果。</p></li><li><p>记录 (事例、例子、实例、观察、模式、样本)<br>通常称数据表中的一行为一条记录。</p></li></ul><blockquote><p>矩阵是数据科学中的基本数据结构。在矩阵中，行是记录，列是变量（特征）。<br>术语中会存在一些令人困惑之处。在与数据科学相关的各学科中，例如统计学、计算机科学和信息技术等，存在着一系列的同义词。</p></blockquote><h3 id="位置估计">位置估计</h3><ul><li><p>均值 (平均值)<br>所有数据值之和除以数值的个数。</p></li><li><p>加权均值 (加权平均值)<br>各数值乘以相应的权重值，然后加总求和，再除以权重的总和。</p></li><li><p>中位数 (第50百分位数)<br>使得数据集中分别有一半数据位于该值之上和之下。</p></li><li><p>加权中位数<br>使得排序数据集中分别有一半的权重之和位于该值之上和之下。</p></li><li><p>切尾均值 (截尾均值)<br>在数据集剔除一定数量的极值后，再求均值。</p></li><li><p>稳健 (耐抗性)<br>对极值不敏感。</p></li><li><p>离群值 (极值)<br>与大部分数据值差异很大的数据值。</p></li></ul><blockquote><p>均值是一种基本的位置度量，但是对极值（离群值）敏感。<br>其他一些度量更为稳健，例如中位数和切尾均值。</p></blockquote><h3 id="变异性估计">变异性估计</h3><ul><li><p>偏差 (误差、残差)<br>位置的观测值与估计值的直接差异。</p></li><li><p>方差 (均方误差)<br>对于n个数据值，方差是对距离均值的偏差平方后求和，再除以n-1。</p><p>计算方差时的被除数为什么是n-1，而不是n？这一讨论引出了自由度的概念。<br>如果在方差公式中使用了直观的除数n，那么就会低估方差的真实值和总体的标准偏差。这被称为有偏估计。<br>但是，如果除以n-1而不是n，这时标准偏差就是无偏估计。<br>自由度考虑了计算估计量中的限制个数。在这种情况下，自由度是n-1，因为其中有一个限制：<br>标准偏差依赖于计算样本的均值。</p></li><li><p>标准偏差 (L2范数、欧几里得范数)<br>方差的平方根。</p></li><li><p>平均绝对误差 (L1范数、曼哈顿范数)<br>对数据值与均值间偏差的绝对值计算均值。</p></li><li><p>中位数绝对偏差<br>数据值与中位数间绝对偏差的均值。</p></li><li><p>极差<br>数据集中最大值和最小值间的差值。</p></li><li><p>顺序统计量 (秩)<br>基于从大到小排序的数据值的度量。</p></li><li><p>百分位数 (四分位数)<br>表示一个数据集中，P%的值小于或等于第P百分位数，(100-P)%的值大于或等于第P百分位数。</p></li><li><p>四分位距 (四分位差)<br>第75百分位数和第25百分位数间的差值。</p></li></ul><blockquote><p>方差和标准偏差是日常最广为使用的变异性统计量。<br>方差和标准偏差都对离群值敏感。<br>更稳健的度量包括偏离均值（百分位数、四分位距）的平均（中位数）绝对偏差。</p></blockquote><h3 id="探索数据分布">探索数据分布</h3><ul><li><p>箱线图 (箱形图、箱须图)<br>图基提出的一种绘图，是一种快速可视化数据分布情况的方法。</p></li><li><p>频数表<br>将数值型数据的计数情况置于一组间隔（组距）中。</p></li><li><p>直方图<br>对频数表的绘图，其中x轴是组距，y轴是计数（或比例）。</p></li><li><p>密度图<br>直方图的平滑表示，通常基于某种核密度估计。</p></li></ul><blockquote><p>频数直方图在y轴上绘制频数计数，在x轴上绘制变量值。它提供了对数据分布的概览。<br>频数表是直方图中频数计数的表格形式。<br>在箱线图中，箱子的顶部和底部分别表示第75百分位数和第25百分位数。箱线图也提供了数据分布的基本情况。多个箱线图通常是并排展示的，以便于比较分布情况。<br>密度图是直方图的一种平滑表示。它需要一个基于数据估计绘图的函数（当然也可以做多个估计）。</p></blockquote><h3 id="探索二元数据和分类数据">探索二元数据和分类数据</h3><ul><li><p>众数<br>数据集中出现次数最多的类别或值。</p></li><li><p>期望值<br>如果类别可以与一个数值相关联，可以根据类别的出现概率计算一个平均值。</p></li><li><p>条形图<br>在绘图中，以条形表示每个类别出现的频数或占比情况。</p></li><li><p>饼图<br>在绘图中，圆饼中的一个扇形部分表示每个类别出现的频数或占比情况。</p></li></ul><blockquote><p>分类数据通常按比例总结，可以使用条形图将它可视化。<br>类别用于表示不同类型的事物（例如苹果和橘子，男性和女性）、因子变量的等级（例如低、中和高），或由组距分隔的数值型数据。<br>期望值是对每个数值与该数值出现概率的乘积求和，通常用于总结因子变量的等级</p></blockquote><h3 id="相关性">相关性</h3><ul><li><p>相关系数<br>一种用于测量数值变量间相关程度的度量，取值范围在-1到+1之间。</p></li><li><p>相关矩阵<br>将变量在一个表格中按行和列显示，表格中每个单元格的值是对应变量间的相关性。</p></li><li><p>散点图<br>在绘图中，x轴显示一个变量的值，y轴显示另一个变量的值。</p></li></ul><blockquote><p>相关系数测量了两个变量间相互关联的程度。<br>如果变量v1的高值随变量v2的高值的变化而变化，那么v1和v2是正相关的。<br>如果变量v1的高值与变量v2的低值的变化相关联，那么v1和v2是负相关的。<br>相关系数是一种标准化的度量，因此其值的范围处于-1（完全负相关）和+1（完全正相关）之间。<br>如果相关系数为0，那么表示两个变量间没有相关性。但是注意，数据的随机排列将会随机生成正的或负的相关系数。</p></blockquote><h3 id="探索两个及以上变量">探索两个及以上变量</h3><ul><li><p>列联表<br>一种对两个或两个以上分类变量做计数的表格。</p></li><li><p>六边形图<br>一种用于两个数值变量的绘图，图中使用六边形表示记录的组距。</p></li><li><p>等势线图<br>一种类似于地形图的绘图，显示了两个数值型变量的密度情况。</p></li><li><p>小提琴图<br>一种类似于箱线图的绘图，但是显示的是密度估计量。</p></li></ul><blockquote><p>六边形图和等势线图是有用的工具，它们支持以图形方式同时查看两个数值型变量，不会受数据规模的影响。<br>列联表是一种查看两个分类变量计数情况的标准工具。<br>箱线图和小提琴图允许根据分类变量绘制数值型变量。</p></blockquote><h2 id="数据和抽样分布">数据和抽样分布</h2><h3 id="随机抽样和样本偏差">随机抽样和样本偏差</h3><ul><li><p>样本<br>大型数据集的一个子集。</p></li><li><p>总体<br>一个大型数据集，或是一个构想的数据集。</p></li><li><p>N（或n）<br>一般用N表示总体的规模，n表示样本的规模。</p></li><li><p>随机抽样<br>从总体中随机抽取元素到样本中。</p></li><li><p>分层抽样<br>对总体分层，并在每层中做随机抽样。</p></li><li><p>简单随机抽样<br>在不对总体分层的情况下，做随机抽样所得到的样本。</p></li><li><p>样本偏差<br>样本对总体做出了错误的解释。</p></li></ul><blockquote><p>即便是在大数据时代，随机抽样依然是数据科学家的一种重要手段。<br>由于测量或观测不能代表总体而出现系统性误差时，就会产生偏差。<br>数据的质量通常比数量更重要，而随机抽样可以降低偏差，提高数据的质量（否则，实现成本可能很高）。</p></blockquote><h3 id="选择偏差">选择偏差</h3><ul><li><p>偏差<br>系统性误差。</p></li><li><p>数据窥探<br>为得到感兴趣的结果，在数据中做大量的查找。</p></li><li><p>大规模搜索效应<br>由于重复的数据建模，或使用大量的预测变量对数据建模所导致的偏差或非可重现性。</p></li></ul><blockquote><p>指定一个假设，然后遵循随机化和随机抽样的原则收集数据，可以确保不会产生偏差。<br>所有其他类型的数据分析都有产生偏差的风险，风险来自数据的采集和分析过程，包括在数据挖掘中反复地运行模型、在研究中窥探数据，以及事后选取有意义的事件。</p></blockquote><h3 id="统计量的抽样分布">统计量的抽样分布</h3><ul><li><p>样本统计量<br>对抽取自大规模总体中的样本做计算，所得到的一些度量值。数据分布</p></li><li><p>数据分布<br>单个值在数据集中的频数分布。</p></li><li><p>抽样分布<br>一个样本统计量在多个样本或重抽样中的频数分布。</p></li><li><p>中心极限定理<br>当样本的规模增大时，抽样分布呈正态分布的趋势。</p></li><li><p>标准误差<br>多个样本间样本统计量的变异性（标准偏差）。不要与标准偏差混淆，后者指的是个体数据值间的变异性。</p></li></ul><blockquote><p>样本统计量的频数分布表明了度量在各个不同抽样间的变化情况。<br>抽样分布可以使用自助法估计，也可以通过依赖于中心极限定理的公式计算得到。<br>标准误差是一个关键的度量，它汇总了抽样统计量的变异性。</p></blockquote><h3 id="自助法">自助法</h3><ul><li><p>自助样本（bootstrap sample）<br>从观测数据集中做有放回的抽取而得到的样本。</p></li><li><p>重抽样<br>在观测数据中重复抽取样本的过程，其中包括自助过程和置换（混洗）过程。</p></li></ul><blockquote><p>自助法（即对数据集做有放回的抽样）是一种评估样本统计量变异性的强大工具。<br>自助法可以类似的方式应用于各种场景中，无须深入探究抽样分布的数学近似。<br>自助法可以在不使用数学近似的情况下，估计统计量的抽样分布。<br>用于预测模型时，聚合多个自助样本的预测（即Bagging方法），要优于使用单个模型的预测。</p></blockquote><h3 id="置信区间">置信区间</h3><ul><li><p>置信水平<br>以百分比表示的置信区间。该区间是从同一总体中以同一方式构建的，可以包含我们感兴趣的统计量。</p></li><li><p>区间端点<br>置信区间的两端。</p></li></ul><blockquote><p>置信区间是一种以区间范围表示估计量的常用方法。<br>数据越多，样本估计量的变异性越小。<br>所能容忍的置信水平越低，置信区间就越狭小。<br>自助法是一种构建置信区间的有效方法。</p></blockquote><h3 id="正态分布">正态分布</h3><ul><li><p>误差<br>数据点与预测值或均值间的差异。</p></li><li><p>标准化<br>数据值减去均值，再除以标准偏差。</p></li><li><p>z分数<br>单个数据点标准化的结果。</p></li><li><p>标准正态分布<br>均值为0、标准偏差为1的正态分布。</p></li><li><p>QQ图<br>对样本分布与正态分布间接近程度的可视化绘图。</p></li></ul><blockquote><p>在统计学的发展史中，正态分布有着十分重要的地位，因为它允许从数学上近似不确定性和变异性。<br>虽然原始数据通常并不符合正态分布，但误差通常是符合正态分布的。对于大规模样本的均值和总数，也是一样的。<br>要将数据转换为z分数，需要减去数据的均值，再除以标准偏差。这样，所生成的数据才可以与正态分布进行对比。</p></blockquote><h3 id="长尾分布">长尾分布</h3><ul><li><p>尾<br>一个频数分布的狭长部分，其中相对极值出现的频数很低。</p></li><li><p>偏斜<br>分布的一个尾部长于另一个尾部。</p></li></ul><blockquote><p>大部分数据是不符合正态分布的。<br>假设数据符合正态分布，这可导致对极端事件产生错误的估计（即“黑天鹅”现象）。</p></blockquote><h3 id="学生t分布">学生t分布</h3><ul><li><p>n<br>表示一个样本的规模。</p></li><li><p>自由度<br>自由度是一个参数，允许根据不同的样本规模、统计量和组数对t分布进行调整。</p></li></ul><blockquote><p>t分布实际上是一个分布家族。它们与正态分布相似，但是尾部略厚。<br>t分布被广泛地用作样本均值分布、两个样本均值间的差异、回归参数等的参考基础。</p></blockquote><h3 id="二项分布">二项分布</h3><ul><li><p>试验<br>一次输出离散值的事件，例如，一次硬币抛掷。</p></li><li><p>成功<br>一次试验的输出为我们感兴趣的结果。</p></li><li><p>二项 (二元)<br>具有两个输出</p></li><li><p>二项试验 (伯努利试验)<br>有两种输出的试验。</p></li><li><p>二项分布 (伯努利分布)<br>在多次试验中（例如x次），成功次数的分布。</p></li></ul><blockquote><p>二项输出在建模中十分重要，因为它们表示了基本的决策情况，例如是否购买、是否点击、存活还是死亡等。<br>二项试验是一种具有两种可能结果的试验，其中一种结果的概率为p，另一种结果的概率为1-p。<br>当n很大并且p不接近于0（或1）时，二项分布可使用正态分布近似。</p></blockquote><h3 id="泊松分布及其相关分布">泊松分布及其相关分布</h3><ul><li><p>lambda<br>单位时间内或单位空间中的事件发生率。</p></li><li><p>泊松分布<br>单位时间内或单位空间中事件数量的频数分布。</p></li><li><p>指数分布<br>在时间或距离上，从一个事件到下一个事件的频数分布。</p></li><li><p>韦伯分布<br>泛化版本的指数分布。韦伯分布允许事件发生的速率随时间变化。</p></li></ul><blockquote><p>如果事件发生率为常数，那么可以用泊松分布对单位时间或空间内的事件数量进行建模。<br>这种场景下，可以用指数分布对两个事件间的时间间隔或距离建模。<br>如果事件发生率会随时间变化（例如，设备故障率的增大），可以使用韦伯分布建模。</p></blockquote><h2 id="统计实验与显著性检验">统计实验与显著性检验</h2><h3 id="A-B测试">A/B测试</h3><ul><li><p>处理<br>实验对象所接触的东西，例如药品、价格、Web标题等。</p></li><li><p>实验组<br>行特定处理的一组对象。</p></li><li><p>对照组<br>执行标准处理或不执行处理的一组对象。</p></li><li><p>随机化<br>随机地分配实验对象以进行处理的过程。</p></li><li><p>实验对象<br>接受处理者，例如Web访问者、病人等。</p></li><li><p>检验统计量<br>用于检验处理效果的度量。</p></li></ul><blockquote><p>将实验对象分配给两组或更多组，各组的条件完全相同，只是要接受的处理不同。<br>在理想情况下，实验对象是随机分配给各组的。</p></blockquote><h3 id="假设检验">假设检验</h3><ul><li><p>零假设<br>完全归咎于偶然性的假设。</p></li><li><p>备择假设<br>与零假设相反，即实验者希望证实的假设。</p></li><li><p>单向检验<br>在假设检验中，只从一个方向上计数偶然性结果。</p></li><li><p>双向检验<br>在假设检验中，从正反两个方向上计数偶然性结果。</p></li></ul><blockquote><p>零假设的逻辑理念体现为没有特殊事件发生，任何观察到的效果都是由随机偶然导致的。<br>假设检验假定零假设为真，创建“零模型”（一种概率模型），并检验所观察到的效果是否是该模型的合理结果。</p></blockquote><h3 id="重抽样">重抽样</h3><ul><li><p>置换检验 (随机化检验、随机置换检验、准确检验)<br>将两组或多组样本组合在一起，并将观测值随机地（或穷尽地）重新分配给重抽样。</p></li><li><p>有放回，无放回<br>在抽样时，所抽取的元素在下一次抽取前是否放回样本中。</p></li></ul><blockquote><p>置换检验将多个样本组合在一起，并做随机混洗。<br>对混洗后的值做分组并重抽样，计算我们感兴趣的统计量。<br>重复上述过程，并在表格中记录重抽样统计量的情况。<br>对比统计量的观测值与重抽样分布，就可以判定观测到的样本间差异是否由偶然性导致的。</p></blockquote><h3 id="统计显著性和p值">统计显著性和p值</h3><ul><li><p>p值<br>对于一个加入了零假设的偶然性模型，p值指得到与观测结果一样不寻常或极端的结果的概率。</p></li><li><p>α值<br>在实际结果的确是统计显著的情况下，α值指偶然性结果必须超出的“不寻常性”概率的阈值。</p></li><li><p>第一类错误<br>错误地将一个由随机导致的效果归结为真。</p></li><li><p>第二类错误<br>错误地将一个为真的效果归结为由随机导致的。</p></li></ul><blockquote><p>显著性检验可以用于确定观测到的效果是否落在零假设模型的随机变异范围内。<br>给定一个零假设模型，p值表示模型所生成的结果与观测到的结果同样极端的概率。<br>α值是零假设随机模型“不寻常性”的阈值。<br>相对于数据科学而言，显著性检验在正式的研究报告中更加重要。但是近年来，即便是对于研究报告，p值的重要性也一直在下降。</p></blockquote><h3 id="t检验">t检验</h3><ul><li><p>检验统计量<br>对我们所关注的差异或效果的度量。</p></li><li><p>t统计量<br>归一化的检验统计量。</p></li><li><p>t分布<br>一种用于比较所观测到的t统计量的参考分布。对于t检验，参考分布是从零假设生成的。</p></li></ul><blockquote><p>在计算机出现之前，重抽样检验并不实用，统计人员使用标准参考分布。<br>检验统计量应该做归一化，这样才能与参考分布做比较。<br>t统计量是一种广为使用的归一化统计量。</p></blockquote><h3 id="多重检验">多重检验</h3><ul><li><p>第一类错误<br>错误地得出一个效果是统计显著的结论。</p></li><li><p>错误发现率<br>在多重检验中，犯第一类错误的比率。</p></li><li><p>p值校正<br>用于在同一数据上做多重检验。</p></li><li><p>过拟合<br>拟合了噪声。</p></li></ul><blockquote><p>在研究工作或数据挖掘项目中，多重性（多重比较、多变量、多模型等）增加了仅根据随机对某个结果得出显著性结论的风险。<br>对于涉及多重统计比较的情况（即显著性的多重检验），可以使用统计校正过程。<br>在数据挖掘中使用结果变量带标记的验证样本，有助于避免得到误导性的结果。</p></blockquote><h3 id="自由度">自由度</h3><ul><li><p>n (样本规模)<br>在数据中，观测（也称为行或记录）的数量。</p></li><li><p>d.f.<br>degrees of freedom（自由度）的简写。</p></li></ul><blockquote><p>自由度是归一化检验统计量计算的一部分。它使得归一化后的结果可以与参考分布（例如t分布、F分布等）进行对比。<br>在回归中，为避免出现多重共线性问题，在将分类变量因子化为n-1个标识或虚拟变量时，应考虑其中隐含的自由度概念。</p></blockquote><h3 id="方差分析">方差分析</h3><ul><li><p>两两对比<br>对于有多个组的情况，在两个组之间做假设检验（比如对均值）。</p></li><li><p>多项检验（omnibus test）<br>一种可以测定多个组均值间方差的单一假设检验。</p></li><li><p>方差分解<br>从整体统计量中（例如，从整体均值、处理均值以及残差中），分离出单个值的贡献情况。</p></li><li><p>F统计量<br>一种归一化统计量，用于衡量多个组均值间的差异是否会超过随机模型的预期。</p></li><li><p>SS<br>sum of square（平方和）的简写，指与某一均值的偏差。</p></li></ul><blockquote><p>方差分析是一种用于分析多组处理结果的统计过程。<br>方差分析是对A/B测试中类似过程的一种扩展，用于评估各组之间的整体方差是否落在随机变异范围内。<br>方差分析的一个有用结果是识别出与组处理、交互效果和误差相关的方差成分。</p></blockquote><h3 id="卡方检验">卡方检验</h3><ul><li><p>卡方统计量<br>观测数据偏离预期程度的量度。</p></li><li><p>期望值 (期望)<br>在某种假设（通常是零假设）下，我们期望数据能给出的结果。</p></li><li><p>d.f.<br>自由度。</p></li></ul><blockquote><p>统计学中一个常见的过程是检验观测情况与独立性假设是否一致，例如购买特定产品的倾向是否与性别无关。<br>卡方分布是一种加入了独立性假设的参考分布。由观测情况计算得到的卡方统计量，必须与卡方分布进行对比。</p></blockquote><h3 id="多臂老虎机算法">多臂老虎机算法</h3><ul><li><p>多臂老虎机<br>一种假想的老虎机，提供多个拉杆供用户选择，每个拉杆对应不同的收益，用于模拟多处理实验。</p></li><li><p>臂<br>表示实验中的一个处理，例如Web测试中的标题A。</p></li><li><p>获胜<br>通过实验模拟老虎机上的获胜，例如客户点击了链接。</p></li></ul><blockquote><p>传统的A/B测试基于随机抽样过程，会导致过度地使用非最优处理。<br>相比而言，多臂老虎机算法改进了抽样过程，加入了在实验过程中学到的信息，减少了非最优处理的频数。<br>多臂老虎机算法还有助于有效地应对两种以上的处理。<br>多臂老虎机具有多种不同的算法，能够解决如何将抽样概率从非最优处理转移到（假设的）最优处理的问题。</p></blockquote><h3 id="检验效能和样本规模">检验效能和样本规模</h3><ul><li><p>效果规模<br>在统计检验中，期望能检测到的效果的最小规模，例如点击率提高20%。</p></li><li><p>检验效能<br>给定样本规模，检测到给定效果规模的概率。</p></li><li><p>显著性水平<br>在检验中所使用的统计显著性水平。</p></li></ul><blockquote><p>在确定样本的规模之前，需提前确定要执行的统计检验。<br>必须指定要检测效果的最小规模。<br>还必须指定检测这一效果规模（检验效能）所需的概率。<br>最后，还必须指定执行检验的显著性水平（α值）。</p></blockquote><h2 id="回归与预测">回归与预测</h2><h3 id="简单线性回归">简单线性回归</h3><ul><li><p>响应变量 (因变量、变量Y、目标、结果)<br>想要预测的变量。</p></li><li><p>自变量 (自变量、变量X、特征、属性)<br>用于预测响应的变量。</p></li><li><p>记录 (行、案例、实例、示例)<br>一个表示特定个体或实例的向量，由因子和结果值组成。</p></li><li><p>截距 ($ b_0 $、$ β_0 $)<br>回归线的截距，即当X = 0时的预测值。</p></li><li><p>回归系数 (斜率、$ b_1 $、$ β_1 $、参数估计值、权重)<br>回归线的斜率。</p></li><li><p>拟合值 (预测值)<br>从回归线获得的估计值[插图]。</p></li><li><p>残差 (误差)<br>观测值和拟合值之间的差异。</p></li><li><p>最小二乘法 (普通最小二乘法)<br>一种通过最小化残差的平方和而拟合回归的方法。</p></li></ul><blockquote><p>回归方程将响应变量Y和预测变量X间的关系建模为一条直线。<br>回归模型给出了拟合值和残差，即响应的预测值和预测的误差。<br>回归模型通常使用最小二乘法拟合。<br>回归可用于预测和解释。</p></blockquote><h3 id="多元线性回归">多元线性回归</h3><ul><li><p>均方根误差 (RMSE)<br>回归均方误差的平方根，它是比较回归模型时使用最广泛的度量。</p></li><li><p>标准残差 (RSE)<br>与均方根误差的计算一样，只是根据自由度做了调整。</p></li><li><p>R方 (决定系数、$ R^2 $)<br>可以被模型解释的变异的比例，值介于0到1之间。</p></li><li><p>t统计量<br>预测因子的系数，除以系数的标准误差。它提供了一种比较模型中变量重要性的度量。</p></li><li><p>加权回归<br>在回归中，记录具有不同的权重。</p></li></ul><blockquote><p>多元线性回归建模了响应变量Y与多个预测变量$ X_1, …, X_p $之间的关系。<br>均方根误差（RMSE）和R2是评价模型最重要的度量。<br>回归系数的标准误差可用于度量变量对模型的贡献的可靠性。<br>逐步回归是一种自动确定模型中应包括哪些变量的方法。<br>加权回归用于拟合函数中，可以对特定记录给予更大或更小的权重。</p></blockquote><h3 id="使用回归做预测">使用回归做预测</h3><ul><li><p>预测区间<br>个体预测值的不确定区间范围。</p></li><li><p>外推法<br>将模型扩展到拟合所用的数据范围之外。</p></li></ul><blockquote><p>超出数据范围的外推会导致误差。<br>置信区间量化了回归系数的不确定度。<br>预测区间量化了单个预测中的不确定度。<br>包括R在内的很多统计软件，都会使用公式在默认或指定输出中给出预测区间和置信区间。<br>也可以使用自助法确定置信区间，该做法的解释和理念同上。</p></blockquote><h3 id="回归中的因子变量">回归中的因子变量</h3><ul><li><p>虚拟变量<br>二元的0/1变量，通过对因子数据重新编码得到，可用于回归模型或其他模型。</p></li><li><p>参考编码 (编码处理)<br>统计学家最常使用的编码类型。它以因子的一层作为参考层，并将其他因子与参考层进行对比。</p></li><li><p>独热编码（one hot encoder）<br>机器学习领域中常用的一种编码。它保留了所有的因子层。虽然该编码适用于部分机器学习算法，但并不适用于多元线性回归。</p></li><li><p>偏差编码 (总和对照编码)<br>在编码中用于对比的并不是参考层，而是将每一层与整体均值进行对比。</p></li></ul><blockquote><p>因子变量需要转换为数值变量，才能在回归中使用。<br>要编码一个具有P个不同值的因子变量，最常用的方法是表示为P-1个虚拟变量。<br>即便是在规模非常大的数据集中，多层因子变量也需整合为具有更少层的变量。<br>一些因子的层是有序的，可以表示为单一的数值变量。</p></blockquote><h3 id="解释回归方程">解释回归方程</h3><ul><li><p>相关变量<br>当预测变量高度相关时，难以解释单个回归系数。</p></li><li><p>多重共线性 (共线性)<br>当预测变量间存在完美的或近乎完美的相关性时，回归是不稳定的，或者说是不可能计算的。</p></li><li><p>混淆变量<br>一种重要的预测变量。忽视该变量可导致回归方程给出伪关系。</p></li><li><p>主效应<br>预测变量和结果变量之间的关系，该关系独立于其他的变量。</p></li><li><p>交互作用<br>两个或两个以上预测变量和响应之间的相互依赖关系。</p></li></ul><blockquote><p>考虑到预测因子之间的相关性，在多元线性回归中，必须注意如何解释回归系数。<br>多重共线性可能导致拟合回归方程中存在数值不稳定的问题。<br>混淆变量是指在模型中遗漏的重要预测因子，它可以导致存在虚假关系的回归方程。<br>如果变量和响应之间存在相互依赖的关系，那么需要在两个变量间添加一个交互项。</p></blockquote><h3 id="回归诊断">回归诊断</h3><ul><li><p>标准残差<br>残差除以残差的标准误差。</p></li><li><p>离群值<br>距离其他记录（或预测结果）很远的记录（或结果值）。</p></li><li><p>强影响值 (influential value)<br>一个值或记录，其存在与否会使回归方程有很大差异。</p></li><li><p>杠杆 (hat-value)<br>单个记录对回归方程的影响程度。</p></li><li><p>非正态残差<br>非正态分布的残差可能会导致一些对回归的技术需求失效。但在数据科学中，通常并不会关注该问题。</p></li><li><p>异方差性<br>在输出的部分范围中具有较高变异性的残差。这可能表明在回归方程中缺失了某个预测变量。</p></li><li><p>偏残差图 (变量添加图、added-variable-plot)<br>展示结果变量和单个预测变量之间关系的一种诊断图。</p></li></ul><blockquote><p>鉴于离群值可能会在小规模数据集中导致问题，关注离群值主要是为了发现数据中存在的问题，或是确定异常所在。<br>单个记录（包括回归离群值）可以对小规模数据集的回归方程产生很大的影响。但是在大数据中，这种效果却荡然无存。<br>如果将回归模型用于形式推断（如p值等），那么应该检验对残差分布的一些假设。但是对于数据科学而言，残差分布通常无关紧要。<br>偏残差图可以用于定性地评估每个回归项的拟合情况，这可能会得出另一种模型声明。</p></blockquote><h3 id="多项式回归和样条回归">多项式回归和样条回归</h3><ul><li><p>多项式回归<br>在回归方程中添加了多项式项，例如平方项、三次方项等。</p></li><li><p>样条回归<br>使用一系列多项式片段去拟合一条平滑曲线。</p></li><li><p>结点<br>分隔样条片段的值。</p></li><li><p>广义加性模型  (GAM)<br>可以自动选择结点的样条模型。</p></li></ul><blockquote><p>在回归中，离群值表现为具有很大残差的记录。<br>多重共线性会导致拟合回归方程中存在数值不稳定的问题。<br>混淆变量是一种重要的预测变量。如果在一个模型中忽略了混淆变量，将会导致回归方程给出伪关系。<br>如果一个变量的效果依赖于另一个变量（因子变量）的层级，那么在两个变量之间需要有交互项。<br>多项式回归可以拟合预测变量和结果变量之间的非线性关系。<br>样条是一组连接在一起的多项式片段，连接点被称为结点。<br>广义加性模型可以自动指定样条函数中的结点。</p></blockquote><h2 id="分类">分类</h2><h3 id="朴素贝叶斯算法">朴素贝叶斯算法</h3><ul><li><p>条件概率<br>在给定另一个事件（比如Y = i）的条件下，观测到某个事件（比如X = i）的概率，记作 $ P(X_i | Y_i) $。</p></li><li><p>后验概率<br>在给定预测因子的情况下，出现某一结果的概率（后验概率不同于结果的先验概率，后者并未考虑预测因子的信息）。</p></li></ul><blockquote><p>朴素贝叶斯适用于分类的（因子型的）预测和结果。<br>朴素贝叶斯要解答的问题是：“在每个结果类别中，哪些预测类别是最可能发生的？”<br>该问题可以转化为，在给定预测值的情况下，估计结果属于不同类别的概率。</p></blockquote><h3 id="判别分析">判别分析</h3><ul><li><p>协方差<br>对一个变量相对于另一个变量的一致程度（幅度和方向类似）的度量。</p></li><li><p>判别函数<br>当应用于预测变量上时，该函数可以使类之间的分离度最大化。</p></li><li><p>判别权重<br>应用判别函数得到的分值，用于估计记录属于某个类的概率。</p></li></ul><blockquote><p>判别分析适用于连续预测因子或分类预测因子，也适用于分类结果。<br>判别分析使用协方差矩阵计算线性判别函数，该函数用于区分属于不同类的记录。<br>线性判别函数对每个记录生成一个权重或分值（每个可能的类对应一个权重），以此来确定记录的估计类。</p></blockquote><h3 id="逻辑回归">逻辑回归</h3><ul><li><p>Logit函数 (对数函数)<br>一种能将属于某个类的概率映射到 ±∞ 范围上（而不是0到1之间）的函数。</p></li><li><p>几率<br>“成功”（1）与“不成功”（0）之间的比率。</p></li><li><p>对数几率<br>转换后的模型（即线性模型）中的响应。该响应已被映射回概率值。</p></li></ul><blockquote><p>逻辑回归和线性回归类似，只不过其结果是二元变量。<br>在逻辑回归中需要做多次转换，以将模型转化为一种可以像线性模型一样拟合的形式，并使用对数优势比作为响应变量。<br>通过迭代过程拟合了线性模型之后，应将对数几率映射回概率值。<br>逻辑回归的计算快速，并且生成的模型可以在不重新计算的情况下对新数据打分，因此它得到了广泛的使用。</p></blockquote><h3 id="评估分类模型">评估分类模型</h3><ul><li><p>正确率（accuracy）<br>正确分类的百分比（或比例）。</p></li><li><p>混淆矩阵<br>按预测分类和实际分类情况对记录分别计数，将计数结果以表格形式显示。例如，对于二元变量，使用的是2×2的表格。</p></li><li><p>灵敏度 (召回率)<br>在预测结果中，1被正确分类的百分比（或比例）。</p></li><li><p>特异性<br>在预测结果中，0被正确分类的百分比（或比例）。</p></li><li><p>准确率（precision）<br>预测结果为1、真实值也为1的百分比（或比例）。</p></li><li><p>ROC曲线<br>灵感度与特异性的绘图。</p></li><li><p>提升（lift）<br>在不同截止概率的情况下，衡量模型在识别（相对罕见的）1上的有效性。</p></li></ul><blockquote><p>正确率（即预测分类正确的百分比）可以用于评估模型，但只是评估的第一步。<br>其他度量（召回率、特异性、准确率）侧重于更具体的性能特征。例如，召回率测定了模型正确识别1的良好程度。<br>AUC（ROC曲线下的面积）是对模型区分1与0能力的一种常用度量。<br>提升衡量了一个模型在识别1上的有效性，并且常常是按十分位数逐个计算的，从分类为1可能性最大之处开始。</p></blockquote><h3 id="不平衡数据的处理策略">不平衡数据的处理策略</h3><ul><li><p>欠采样 (下采样)<br>在分类模型中，使用更少的多数类记录。</p></li><li><p>过采样 (上采样)<br>在分类模型中，更多地使用稀有类记录。必要时可以使用自助法。</p></li><li><p>上权重、下权重<br>在模型中，对稀有类赋予更大的权重，对多数类赋予更小的权重。</p></li><li><p>数据生成<br>类似于自助法，只是每个新的自助记录与原记录略有不同。</p></li><li><p>z分数<br>对结果做归一化所生成的值。</p></li><li><p>K<br>在最近邻计算中使用的近邻个数。</p></li></ul><blockquote><p>分类算法在高度不平衡数据（其中感兴趣的结果“1”十分罕见）中会存在问题。<br>平衡训练数据的一种策略是，对多数类做欠采样，或者对稀有类做过采样。<br>如果使用了数据中所有的“1”依然不够，可以对稀有类做自助法，或使用SMOTE算法创建与稀有类相似的合成数据。<br>不平衡数据通常表明正确的分类（即“1”）具有更高的价值。我们应将这种值的比率纳入到评估度量中。</p></blockquote><h2 id="统计机器学习">统计机器学习</h2><h3 id="K最近邻算法">K最近邻算法</h3><ul><li><p>近邻<br>具有相似预测值的两个记录。</p></li><li><p>距离度量<br>以单一数值的形式，测量两个记录之间的距离。</p></li><li><p>标准化 (归一化)<br>减去均值，并除以标准偏差。</p></li><li><p>z分数<br>标准化后得到的值。</p></li><li><p>K<br>在最近邻计算中考虑的近邻个数。</p></li></ul><blockquote><p>KNN通过指定与一条记录相似的记录所属的类，实现对该记录的分类。<br>可以使用欧氏距离或其他相关度量判定相似度（距离）。<br>与一条记录进行比较的最近邻数（即K值），取决于使用不同K值时，算法在训练数据上的性能。<br>预测变量通常需要做标准化，以避免大尺度变量主导了距离度量。<br>KNN常常作为预测建模过程的第一个阶段。KNN的预测值会作为一个预测变量添加回数据中，进而用于第二阶段（非KNN）的建模。</p></blockquote><h3 id="树模型">树模型</h3><ul><li><p>递归分区（recursive partition）<br>反复对数据进行划分和细分，目的是使每个最终细分内的结果尽可能同质。</p></li><li><p>拆分值（split value）<br>一个预测变量值，它将一组记录分为两部分，使得一部分中的预测变量小于拆分值，而另一部分中的预测变量大于拆分值。</p></li><li><p>节点<br>在决策树中（或在一组相应的分支规则中），节点是拆分值的图形化表示（或规则表示）。</p></li><li><p>叶子<br>一组if-then规则的终点，或一个树分支的终点。在树中访问叶子的规则，构成了对树中一条记录的分类规则。</p></li><li><p>损失<br>在拆分过程的某一阶段中误分类的个数。损失越大，不纯度越高。</p></li><li><p>不纯度 (异质性)<br>表示在数据的一个细分中发现多个类混杂的程度。细分中混杂的类越多，该细分的不纯度就越高。</p></li><li><p>剪枝<br>为了降低过拟合，对一棵完全长成树逐步剪枝的过程。</p></li></ul><blockquote><p>决策树生成一组规则，用于分类或预测结果。<br>规则对应于如何将数据划分为连续的子分区。<br>每个分区或拆分指定一个预测变量值（即拆分值），将分区中数据拆分为高于和低于该拆分值的两组记录（即子分区）。<br>在每个阶段，树算法选择使每个子分区内结果的不纯度最小的拆分。<br>一旦算法不能做进一步的拆分，就得到了一棵完全长成树。每个末端节点或叶子内的记录属于相同的类。此后，遵循该规则（拆分）路径的新记录，将会分配为该类。<br>完全长成树会过产生拟合，因此为了使模型捕获信号而非噪声，必须做剪枝。<br>虽然随机森林和Boosting等多树模型算法具有更好的预测性能，但失去了单个树模型基于规则的交流能力。</p></blockquote><h3 id="Bagging和随机森林">Bagging和随机森林</h3><ul><li><p>集成 (模型平均)<br>使用一组模型给出预测。</p></li><li><p>Bagging (自助法聚合)<br>对数据使用自助法构建一组模型的通用方法。</p></li><li><p>随机森林 (自助法聚合决策树)<br>使用决策树的一类自助法聚合估计。</p></li><li><p>变量重要性<br>对预测变量在模型性能中重要性的测量。</p></li></ul><blockquote><p>通过组合多个模型的结果，集成模型提高了模型正确率。<br>Bagging是一类特殊的集成模型，它使用数据的自助法抽样拟合多个模型，并对模型取平均值。<br>随机森林是一种应用于决策树的特殊Bagging方法。除了对数据重抽样之外，随机森林算法还在拆分树时对预测变量做抽样。<br>对变量重要性的一种度量是随机森林的一种有用输出。变量重要性根据变量对模型正确率的贡献度，对变量排序。<br>随机森林具有一组超参数。可以使用交叉验证调整超参数，以避免产生过拟合。</p></blockquote><h3 id="Boosting">Boosting</h3><ul><li><p>Boosting<br>在拟合一组模型时所使用的一种通用方法。Boosting在每轮连续的拟合中，会对具有更大残差的记录赋予更大的权重。</p></li><li><p>Adaboost<br>Boosting算法的一种早期实现，它根据残差的情况对数据重新加权。</p></li><li><p>梯度提升<br>一种更通用的Boosting算法。它将问题转化为代价函数最小化的问题。</p></li><li><p>随机梯度提升（SGD）<br>最常用的Boosting算法。它在每轮拟合中加入了对记录和数据列的重抽样。</p></li><li><p>正则化<br>通过在代价函数中对模型参数的数量添加惩罚项，避免产生过拟合。</p></li><li><p>超参数<br>在拟合算法之前就需要设定的参数。</p></li></ul><blockquote><p>Boosting是一类基于对一组模型做拟合的集成模型。在连续的每轮拟合中，Boosting算法会为具有更大残差的记录赋予更大的权重。<br>随机梯度提升是最通用的Boosting算法，具有最佳性能。随机梯度提升最常见的形式是使用树模型。<br>XGBoost是一种广为使用的随机梯度提升软件包，它计算高效。所有数据科学常用的语言中都提供了XGBoost。<br>Boosting容易过拟合数据。为了避免产生过拟合，需要调整超参数。<br>正则化通过在模型的参数数量（例如，树的规模）上添加惩罚项，避免产生过拟合。<br>鉴于Boosting算法需要设置大量的超参数，交叉验证尤为重要。</p></blockquote><h2 id="无监督学习">无监督学习</h2><h3 id="主成分分析">主成分分析</h3><ul><li><p>主成分<br>预测变量的一种线性组合。</p></li><li><p>载荷 (权重)<br>将预测因子转换为成分的过程中所使用的权重值。</p></li><li><p>陡坡图<br>一种展示各成分方差的绘图，图中显示了各成分的相对重要性。</p></li></ul><blockquote><p>主成分是预测变量的线性组合，但仅限于数值型预测变量。<br>主成分计算的原则是使成分之间的相关性最小化，进而减少冗余。<br>通常，有限数量的成分就可以解释结果变量的大部分方差。<br>这样就可以使用一组有限的主成分代替（更多的）原始预测变量，从而降低维度。</p></blockquote><h3 id="K-Means聚类">K-Means聚类</h3><ul><li><p>类（cluster）<br>一组类似的记录。</p></li><li><p>类均值<br>表示类内记录变量均值的向量。</p></li><li><p>K<br>类的个数。</p></li></ul><blockquote><p>所需的类数K由用户决定。<br>K-Means算法通过迭代地将记录分配给最近的类均值，直到类的分配情况不再发生改变，实现了类的生成。<br>通常，出于实际的考虑决定了K的选择。在统计学上不存在最优的类数。</p></blockquote><h3 id="层次聚类">层次聚类</h3><ul><li><p>树状图<br>一种可视化表示，显示了记录及其所属类的层次结构。</p></li><li><p>距离<br>测量两个记录之间的接近程度。</p></li><li><p>相异性<br>测量两个类之间的接近程度。</p></li></ul><blockquote><p>层次聚类算法开始时，每条记录单独构成一个类。<br>在凝聚算法中，类逐步与相邻的类合并，直到所有记录属于单一类。<br>凝聚算法的类历史可以被保留并绘制出来。用户（无须预先指定类数）可以在算法执行的各个阶段，可视化地查看类数和类的结构。<br>有多种方法可以计算类之间的距离。这些方法都依赖于所有记录间距离。</p></blockquote><h3 id="基于模型的聚类">基于模型的聚类</h3><blockquote><p>基于模型的聚类方法假设类是由不同数据生成过程所生成的，各个数据生成过程具有不同的概率分布。<br>基于模型的聚类方法拟合了不同的模型，假设有不同数量的分布（通常是正态分布）。<br>基于模型的聚类方法无须使用过多的参数（即过拟合），就能选出一个能很好地拟合数据的模型（以及类数）。</p></blockquote><h3 id="变量的缩放和分类变量">变量的缩放和分类变量</h3><ul><li><p>缩放<br>缩小或放大数据的方法，常用于将多个变量缩放到同一尺度上。</p></li><li><p>归一化 (标准化)<br>一种通过减去均值并除以标准偏差进行缩放的方法。</p></li><li><p>高氏距离（Gower’s distance）<br>一种应用于数值数据和类别数据相混合的缩放算法。它可以将所有变量缩放到[0, 1]范围内。</p></li></ul><blockquote><p>以不同尺度测量的变量，需要转换到相似的尺度上。这样，变量对算法的影响不会主要由变量的尺度决定。<br>归一化（标准化）是一种常用的缩放方法——减去均值再除以标准偏差计算。<br>另一种缩放方法是高氏距离，它将所有的变量缩放到[0, 1]范围内。高氏距离通常用于含有数值型数据和分类数据的混合数据。</p></blockquote><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://www.amazon.cn/dp/B07MNV5MSN" target="_blank" rel="noopener">面向数据科学家的实用统计学</a></p>]]></content>
    
    <summary type="html">
    
      重要的统计学概念
    
    </summary>
    
    
      <category term="ReadingNotes" scheme="https://neo1989.net/categories/ReadingNotes/"/>
    
    
      <category term="DAE" scheme="https://neo1989.net/tags/DAE/"/>
    
      <category term="Math" scheme="https://neo1989.net/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Pandas常用</title>
    <link href="https://neo1989.net/CheatSheet/CHEATSHEET-pandas/"/>
    <id>https://neo1989.net/CheatSheet/CHEATSHEET-pandas/</id>
    <published>2021-01-12T07:50:19.000Z</published>
    <updated>2021-02-07T08:31:34.173Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你可以不用，但你不能不会。</p></blockquote><table><thead><tr><th style="text-align:left">Grammar</th><th style="text-align:center">Explanation / Examples</th></tr></thead><tbody><tr><td style="text-align:left"><strong>Importing Data</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.read_csv(filename)</td><td style="text-align:center">From a CSV file</td></tr><tr><td style="text-align:left">pd.read_table(filename)</td><td style="text-align:center">From a delimited text file (like TSV)</td></tr><tr><td style="text-align:left">pd.read_excel(filename)</td><td style="text-align:center">From an Excel file</td></tr><tr><td style="text-align:left">pd.read_sql(query, connection_object)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.read_json(json_string)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.read_html(url)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.DataFrame(dict)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>Exporting Data</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.to_csv(filename)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.to_sql(table_name, connection_object)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.to_json(filename)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>Create Test Objects</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.DataFrame(np.random.rand(20, 5))</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.Series(my_list)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.index = pd.date_range(‘1900/1/30’, periods=df.shape[0])</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>Viewing / Inspecting Data</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.head(n)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.tail(n)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.shape</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.describe()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.value_counts()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>Selection</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df[col]</td><td style="text-align:center">Returns column with label col as Series</td></tr><tr><td style="text-align:left">df[[col1, col2]]</td><td style="text-align:center">Returns columns as a new DataFrame</td></tr><tr><td style="text-align:left">ss.iloc[0]</td><td style="text-align:center">Selection by position</td></tr><tr><td style="text-align:left">df.iloc[0, :]</td><td style="text-align:center">First row</td></tr><tr><td style="text-align:left">df.iloc[0, 0]</td><td style="text-align:center">First element of first column</td></tr><tr><td style="text-align:left"><strong>Data Cleaning</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.columns = [‘a’,‘b’,‘c’]</td><td style="text-align:center">Rename columns</td></tr><tr><td style="text-align:left">pd.isnull()</td><td style="text-align:center">Checks for null Values, Returns Boolean Arrray</td></tr><tr><td style="text-align:left">pd.notnull()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.dropna()</td><td style="text-align:center">Drop all rows that contain null values</td></tr><tr><td style="text-align:left">df.dropna(axis=1)</td><td style="text-align:center">Drop all columns that contain null values</td></tr><tr><td style="text-align:left">df.dropna(axis=1, thresh=n)</td><td style="text-align:center">Drop all rows have have less than n non null values</td></tr><tr><td style="text-align:left">df.fillna(x)</td><td style="text-align:center">Replace all null values with x</td></tr><tr><td style="text-align:left">ss.fillna(ss.mean())</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">ss.astype(float)</td><td style="text-align:center">Convert the datatype of the series to float</td></tr><tr><td style="text-align:left">ss.replace(1, ‘one’)</td><td style="text-align:center">Replace all values equal to 1 with ‘one’</td></tr><tr><td style="text-align:left">ss.replace([1, 3], [‘one’, ‘three’])</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.rename(columns=lambda x: x + 1)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.rename(columns={‘old_name’: ‘new_ name’})</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.set_index(‘column_one’)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.rename(index=lambda x: x + 1)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>Filter, Sort, and Groupby</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df[df[col].gt(0.5)]</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df[(df[col] &gt; 0.5) &amp; (df[col] &lt; 0.7)]</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.sort_values(col1)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.sort_values(col2, ascending=False)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.sort_values([col1,col2], ascending=[True, False])</td><td style="text-align:center">Sort values by col1 in ascending order then col2 in descending order</td></tr><tr><td style="text-align:left">df.groupby(col)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.groupby([col1, col2])</td><td style="text-align:center">Returns groupby object for values from multiple columns</td></tr><tr><td style="text-align:left">df.pivot_table(index=col1, values=[col2, col3], aggfunc=np.mean)</td><td style="text-align:center">Create a pivot table that groups by col1 and calculates the mean of col2 and col3</td></tr><tr><td style="text-align:left">df.groupby(col1).agg(np.mean)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.apply(np.mean)</td><td style="text-align:center">Apply the function np.mean() across each column</td></tr><tr><td style="text-align:left">df.apply(np.max, axis=1)</td><td style="text-align:center">Apply the function np.max() across each row</td></tr><tr><td style="text-align:left"><strong>Join / Combine</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df1.append(df2)</td><td style="text-align:center">Add the rows in df1 to the end of df2 (columns should be identical)</td></tr><tr><td style="text-align:left">pd.concat([df1, df2], axis=1)</td><td style="text-align:center">Add the columns in df1 to the end of df2 (rows should be identical)</td></tr><tr><td style="text-align:left">df1.join(df2, on=col1, how=‘inner’)</td><td style="text-align:center">SQL-style</td></tr><tr><td style="text-align:left"><strong>Statistics</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.describe()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.mean()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.corr()</td><td style="text-align:center">Returns the correlation between columns in a DataFrame</td></tr><tr><td style="text-align:left">df.count()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.max()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.min()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.median()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.std()</td><td style="text-align:center"></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      Save more time.
    
    </summary>
    
    
      <category term="CheatSheet" scheme="https://neo1989.net/categories/CheatSheet/"/>
    
    
      <category term="DAE" scheme="https://neo1989.net/tags/DAE/"/>
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
  </entry>
  
  <entry>
    <title>Excel必会</title>
    <link href="https://neo1989.net/CheatSheet/CHEATSHEET-excel-formulas/"/>
    <id>https://neo1989.net/CheatSheet/CHEATSHEET-excel-formulas/</id>
    <published>2021-01-08T06:54:55.000Z</published>
    <updated>2021-02-02T06:30:45.042Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你可以不用，但你不能不会。</p></blockquote><h3 id="常用公式">常用公式</h3><table><thead><tr><th style="text-align:left">Formula</th><th style="text-align:center">Grammar</th><th style="text-align:center">Explanation / Examples</th></tr></thead><tbody><tr><td style="text-align:left"><strong>日期时间类</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">DATE</td><td style="text-align:center">DATE(year, month, day)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">DAYS</td><td style="text-align:center">DAYS(end_date, start_date)</td><td style="text-align:center">返回两个日期之间的天数</td></tr><tr><td style="text-align:left">DAY</td><td style="text-align:center">DAY(serial_number)</td><td style="text-align:center">返回一个月中的第几天的数值 [1, 31]</td></tr><tr><td style="text-align:left">MONTH</td><td style="text-align:center"></td><td style="text-align:center">返回月份值 [1, 12]</td></tr><tr><td style="text-align:left">YEAR</td><td style="text-align:center"></td><td style="text-align:center">返回日期的年份值 [1900, 9999]</td></tr><tr><td style="text-align:left"><strong>统计类</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">COUNT</td><td style="text-align:center"></td><td style="text-align:center">计算区域中包含数字的单元格的个数</td></tr><tr><td style="text-align:left">COUNTA</td><td style="text-align:center"></td><td style="text-align:center">计算区域中非空单元格的个数</td></tr><tr><td style="text-align:left">COUNTBLANK</td><td style="text-align:center"></td><td style="text-align:center">计算某个区域中空单元格的数目</td></tr><tr><td style="text-align:left">COUNTIF</td><td style="text-align:center">COUNTIF(range, criteria)</td><td style="text-align:center">计算某个区域中满足给定条件的单元格数目</td></tr><tr><td style="text-align:left">COUNTIFS</td><td style="text-align:center"></td><td style="text-align:center">统计一组给定条件所指定的单元格数</td></tr><tr><td style="text-align:left">SUM</td><td style="text-align:center"></td><td style="text-align:center">计算单元格区域中所有数值的和</td></tr><tr><td style="text-align:left">SUMIF</td><td style="text-align:center"></td><td style="text-align:center">对满足条件的单元格求和</td></tr><tr><td style="text-align:left">SUMIFS</td><td style="text-align:center"></td><td style="text-align:center">对一组给定条件指定的单元格求和</td></tr><tr><td style="text-align:left">SUMPRODUCT</td><td style="text-align:center"></td><td style="text-align:center">点积</td></tr><tr><td style="text-align:left">FREQUENCY</td><td style="text-align:center">FREQUENCY(data_array, bins_array)</td><td style="text-align:center">以一列垂直数组返回一组数据的频率分布</td></tr><tr><td style="text-align:left">MAX</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">MIN</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">RANK</td><td style="text-align:center"></td><td style="text-align:center">返回某数字在一列数字中相对于其他数值的大小排名</td></tr><tr><td style="text-align:left">RAND</td><td style="text-align:center"></td><td style="text-align:center">返回大于或等于 0 且小于 1 的平均分布随机数</td></tr><tr><td style="text-align:left">RANDBETWEEN</td><td style="text-align:center">RANDBETWEEN(bottom, top)</td><td style="text-align:center">返回一个介于指定的数字之间的随机数</td></tr><tr><td style="text-align:left">AVERAGEA</td><td style="text-align:center"></td><td style="text-align:center">算数平均数</td></tr><tr><td style="text-align:left">QUARTILE</td><td style="text-align:center">QUARTILE(array, quart)</td><td style="text-align:center">返回一组数据的四分位点</td></tr><tr><td style="text-align:left">VAR</td><td style="text-align:center"></td><td style="text-align:center">方差</td></tr><tr><td style="text-align:left">STDEV</td><td style="text-align:center"></td><td style="text-align:center">标准差</td></tr><tr><td style="text-align:left">TTEST</td><td style="text-align:center">TTEST(array1, array2, tails, type)</td><td style="text-align:center">返回t-检验的概率值</td></tr><tr><td style="text-align:left">CHITEST</td><td style="text-align:center">CHITEST(actual_range, expected_range)</td><td style="text-align:center">返回独立性检验的结果: 针对统计和相应的自由度返回卡方分布值</td></tr><tr><td style="text-align:left">FTEST</td><td style="text-align:center">FTEST(array1, array2)</td><td style="text-align:center">返回的是当 Array1 和 Array2 的方差无明显差异时的双尾概率</td></tr><tr><td style="text-align:left"><strong>关联匹配类</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">INDEX</td><td style="text-align:center">INDEX(…)</td><td style="text-align:center">在给定的单元格区域中，返回特定行列交叉处单元格的值或引用</td></tr><tr><td style="text-align:left">LOOKUP</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">VLOOKUP</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">MATCH</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">ROW</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">COLUMN</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">OFFSET</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>逻辑运算类</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">IF</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">IF*</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">AND</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">OR</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">IS*</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>数据清洗类</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">TRIM</td><td style="text-align:center"></td><td style="text-align:center">清除掉单元格两边的空格</td></tr><tr><td style="text-align:left">CONCATENATE</td><td style="text-align:center"></td><td style="text-align:center">将多个文本字符串合并成一个</td></tr><tr><td style="text-align:left">REPLACE</td><td style="text-align:center">REPLACE(old_text, start_num, num_chars, new_text)</td><td style="text-align:center">通过下标替换字符串</td></tr><tr><td style="text-align:left">SUBSTITUTE</td><td style="text-align:center">SUBSTITUTE(text, old_text, new_text, instance_num)</td><td style="text-align:center">通过内容替换字符串</td></tr><tr><td style="text-align:left">LEFT / MID / RIGHT</td><td style="text-align:center"></td><td style="text-align:center">截取字符串</td></tr><tr><td style="text-align:left">LEN / LENB</td><td style="text-align:center"></td><td style="text-align:center">字符串长度</td></tr><tr><td style="text-align:left">FIND</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">SEARCH</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">INT</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">RAOUND</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h3 id="常见错误">常见错误</h3><table><thead><tr><th style="text-align:left">Error</th><th style="text-align:center">Explanation</th></tr></thead><tbody><tr><td style="text-align:left">#####!</td><td style="text-align:center">计算结果过长，单元格容纳不下；增加列宽可解决</td></tr><tr><td style="text-align:left">#DIV/0</td><td style="text-align:center">除数为0，或公式被空单元格除</td></tr><tr><td style="text-align:left">#N/A</td><td style="text-align:center">公式中无可用数值，或缺少函数参数</td></tr><tr><td style="text-align:left">#NAME?</td><td style="text-align:center">引用了无法识别的名称</td></tr><tr><td style="text-align:left">#NULL!</td><td style="text-align:center">使用了错误的区域运算符，或错误的单元格引用</td></tr><tr><td style="text-align:left">#NUM!</td><td style="text-align:center">在需要数字参数的地方使用了无法接受的参数，或计算结果过大过小</td></tr><tr><td style="text-align:left">#RFF!</td><td style="text-align:center">引用了无效的单元格</td></tr><tr><td style="text-align:left">#VALUE!</td><td style="text-align:center">公式中含有一个错误类型的参数或操作数</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      Save more time.
    
    </summary>
    
    
      <category term="CheatSheet" scheme="https://neo1989.net/categories/CheatSheet/"/>
    
    
      <category term="DAE" scheme="https://neo1989.net/tags/DAE/"/>
    
  </entry>
  
  <entry>
    <title>MAC命令行快捷键</title>
    <link href="https://neo1989.net/CheatSheet/CHEATSHEET-mac-cmd/"/>
    <id>https://neo1989.net/CheatSheet/CHEATSHEET-mac-cmd/</id>
    <published>2020-12-22T07:17:43.000Z</published>
    <updated>2021-01-06T12:10:14.432Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">CheatSheet</th><th style="text-align:center">DESC</th></tr></thead><tbody><tr><td style="text-align:center">CTRL + a</td><td style="text-align:center">左移到行首</td></tr><tr><td style="text-align:center">CTRL + e</td><td style="text-align:center">右移到行尾</td></tr><tr><td style="text-align:center">CTRL + b</td><td style="text-align:center">左移一格</td></tr><tr><td style="text-align:center">CTRL + f</td><td style="text-align:center">右移一格</td></tr><tr><td style="text-align:center">ESC + b</td><td style="text-align:center">左移一词</td></tr><tr><td style="text-align:center">ESC + f</td><td style="text-align:center">右移一词</td></tr><tr><td style="text-align:center">CTRL + d</td><td style="text-align:center">删除当前字符</td></tr><tr><td style="text-align:center">CTRL + h</td><td style="text-align:center">删除左边一个字符</td></tr><tr><td style="text-align:center">CTRL + w</td><td style="text-align:center">删除左边一个词 (不包含当前字符)</td></tr><tr><td style="text-align:center">CTRL + k</td><td style="text-align:center">删除当前及右边所有字符</td></tr><tr><td style="text-align:center">ESC + DEL</td><td style="text-align:center">清除至行首 (不包含当前及右边所有字符)</td></tr><tr><td style="text-align:center">CTRL + u</td><td style="text-align:center">清除当前行</td></tr><tr><td style="text-align:center">CTRL + t</td><td style="text-align:center">交换光标当前字符和左边一个字符的位置</td></tr><tr><td style="text-align:center">ESC + t</td><td style="text-align:center">交换光标当前词和左边一词的位置 <br/> (当前空格右边如果有词，那空格算右边一词的，否则算前面一词的)</td></tr><tr><td style="text-align:center">CTRL + c</td><td style="text-align:center">杀死当前进程</td></tr><tr><td style="text-align:center">CTRL + z</td><td style="text-align:center">挂起当前进程 (fg恢复)</td></tr><tr><td style="text-align:center">CTRL + l</td><td style="text-align:center">清屏</td></tr><tr><td style="text-align:center">CTRL + r</td><td style="text-align:center">搜索历史命令</td></tr><tr><td style="text-align:center">CTRL + y</td><td style="text-align:center">粘贴上次的删除</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      快人一步。
    
    </summary>
    
    
      <category term="CheatSheet" scheme="https://neo1989.net/categories/CheatSheet/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
  </entry>
  
  <entry>
    <title>《机器学习》</title>
    <link href="https://neo1989.net/ReadingNotes/NOTE-machine-learning-exercises/"/>
    <id>https://neo1989.net/ReadingNotes/NOTE-machine-learning-exercises/</id>
    <published>2020-12-15T09:09:39.000Z</published>
    <updated>2021-01-30T07:15:00.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gists-摘要">Gists 摘要</h2><h3 id="概述">概述</h3><ul><li><p>举例说明机器学习的基本过程<br>定义分析目标、收集数据、数据预处理、数据建模、模型训练、模型评估、模型应用</p></li><li><p>讨论数据数量和质量对机器学习的影响。<br>数据数量少、质量低，无法完成任务、欠拟合、维度爆炸等；数据量大，耗费计算资源、过拟合。</p></li><li><p>讨论目前机器学习应用中存在的主要问题。<br>选择什么模型或算法、选择什么优化方法、如何对数据进行预处理、目标函数是什么、过拟合与欠拟合的处理、维度爆炸</p></li></ul><h3 id="基本方法">基本方法</h3><ul><li><p>什么是标准差、方差和协方差？它们反映了数据的什么内容？<br>方差：离平均的平方距离的平均。<br>标准差：方差的平方根, 描述的是样本集的分散程度。<br>协方差：用于衡量两个随机变量的联合变化程度。 可以反映两个变量是否正负相关或线性无关。</p></li><li><p>如何利用平均值和标准差判断数据的异常值？<br>与平均值的偏差超过三倍标准差的测定值，称为高度异常的异常值。<br>标准差可用于识别符合高斯或类高斯分布的数据中的异常值。</p></li><li><p>何为正则化？其功能是什么？<br>正则化是为了避免过拟合，在经验风险上加入了一个惩罚项。正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值就越大。</p></li><li><p>常见的数据概率分布有哪些？<br>伯努利分布、均匀分布、二项分布、正态分布、泊松分布、指数分布等</p></li><li><p>损失函数和风险函数的含义和作用是什么？<br>损失函数是关于模型计算结果 $f(x)$ 和样本目标实际结果 $Y$ 的非负实值函数，记做 $L(y, f(x))$ ，用来解释模型在每个样本实例上的误差损失。<br>函数的值越小，说明预测值与实际值越接近，即模型的拟合效果越好。<br>$L(y, f(x))$ 可以被认为是模型的经验风险，是模型关于训练样本集的平均损失。通常情况下，经验风险也可以训练数据集的损失函数来确定。<br>损失函数反应了模型预测结果和实际结果之间的差距，理解损失函数的本质有助于对算法进行优化，需要结合业务目标和数据特点对问题的本质进行理解，并用数学公式进行抽象，并选择简单的实现方法进行应用。</p></li><li><p>训练误差如何度量和减少？<br>训练误差是模型 $Y$ 关于训练数据集的平均损失。损失函数可以有多种，包括 0-1损失函数、平方损失函数、绝对损失函数、对数损失函数。<br>训练误差较高时可以调整超参数重新训练。</p></li><li><p>如何理解L0、L1和L2正则化？<br>L0正则化是通过限制向量中非0的元素的个数实现模型优化，用L0来正则化一个参数举证 $W$ , 目标是使其更稀疏，即 $W$ 中的大部分元数都是0。很明显，如果通过L0范数作为罚项， 就是寻找最优稀疏特征项.<br>L1正则化是通过对向量中各个元素绝对值之和进行限制，任何的规则化算子，如果在 $W_i = 0$ 的地方不可微，并且可以分解为多项式的形式，那么这个规则化算子就可以实现稀疏。<br>L2正则化是指向量各元素求平方和然后求平方根，用模最小化来确保 $w$ 的每个元素都很小，都接近于0。</p></li><li><p>什么是交叉校验？常用的交叉校验方法有哪些？<br>常用方法：HoldOut检验、简单交叉检验、k折交叉检验、留一交叉检验</p></li><li><p>如何评价一个算法的性能？<br>分类算法评价指标有：准确率、准确率、召回率、F1值、ROC曲线等<br>回归模型的评价指标有：平均绝对偏差（MAE）、均方误差（MSE）、 均方根误差（RMSE）、R2指标等</p></li><li><p>数据降维有哪些常用的方法？<br>主成分分析、线性判别分析、奇异值分解、局部线性嵌入、拉普拉斯特征映射</p></li><li><p>举例解释主成分分析。<br>主成分分析是最常用的线性降维方法，它的目标是通过某种线性投影，将高维的数据映射到低维的空间中，并期望在所投影的维度上数据的方差最大，以此使用较少的维度，同时保留较多原数据的维度。</p></li><li><p>LDA的基本思想是什么？<br>线性判别分析的原理是对于给定的训练集，设法将样本投影到一条直线上，是的同类的投影点尽可能的接近，异类样本的投影点尽可能的远离。<br>在对新样本进行分类时，将其投影到这条直线上，再根据投影点的位置来确定新样本的类别。</p></li><li><p>拉普拉斯特征映射的功能是什么？<br>拉普拉斯特征映射是一种基于图的降维算法，它希望相互间有关系的点在降维后的空间中尽可能的靠近，从而在降维后仍能保持原有的数据结构</p></li><li><p>为什么要考虑特征提取？<br>特征提取目的是自动地构建新的特征，将原始数据转换为一组具有明显统计意义的核心特征</p></li><li><p>特征构造有哪些常用的方法？<br>一般使用混合属性或者组合属性来创建新的特征，或是分解、切分原有的特征来创建新的特征。<br>特征生成前的原始数据可以分单列变量、多列变量、多行样本（时间序列）等三种情况。</p></li><li><p>特征提取有哪些常用的方法？<br>主成分分析、独立成分分析、线性判别分析</p></li><li><p>线性回归的过程是什么？</p><ol><li>确定输入变量与目标变量间的回归模型，即变量间相关关系的数学表达式。</li><li>根据样本估计并检验回归模型及未知参数。</li><li>从众多的输入变量中，判断哪些变量对目标变量的影响是显著的。</li><li>根据输入变量的已知值，来估计目标变量的平均值并给出预测精度。</li></ol></li><li><p>逻辑回归为什么可以预测新样本的类别？<br>LR是一种预测分析，解释因变量与一个或多个自变量之间的关系。<br>与线性回归不同的是它的目标变量有多种类别, 所以逻辑回归主要用于解决分类问题。<br>与线性回归相比，它用概率的方式，预测出来属于某一分类的概率值，如果大于50%，则属于该分类。</p></li><li><p>举例说明二次判别分析的功能。</p></li><li><p>在机器学习过程的每个阶段，机器学习起到什么作用？</p></li></ul><h3 id="决策树与分类算法">决策树与分类算法</h3><ul><li><p>分类解决什么问题？<br>分类算法是利用训练样本集获得的分类函数（分类模型），从而实现将数据集中的样本划分到各个类中。<br>分类模型通过学习训练样本中的属性集与类别之间的潜在关系，并以此为依据对新样本属于哪一类进行预测。</p></li><li><p>常用的分类算法有哪些？<br>决策树、支持向量机、最近邻、贝叶斯网络和神经网络等。</p></li><li><p>简述决策树的生成过程。<br>决策树的构建过程是按照属性的优先级或重要性来逐渐确定树的层次结构，使其叶子节点尽可能属于同一类别，一般采用局部最优额贪心策略来构建决策树。</p></li><li><p>总结常用的决策树C5.0、CHAID、CART等算法的分支标注。<br>C5.0 算法选择分支变量的依据：以信息熵的下降速度作为确定最佳分支变量和分隔阈值的依据。信息熵的下降意味着信息的不确定性下降。<br>CHAID 算法分支处理的标注指标是：独立性检验和相关性（分裂后自变量与目标变量的相关性）。<br>CART 算法在处理中分支属性的度量指标是： Gini指标。</p></li><li><p>举例说明连续属性离散化的几种方法。<br>非监督离散化:<br>等宽离散化：将属性划分为宽度一致的若干个区间。<br>等频离散化：将属性划分为若干个区间，每个区间的数量想等。<br>聚类：根据特性将属性划分为不同的簇，以此形式将连续属性离散化。<br>监督离散化：常用的方法是通过选取极大化区间纯度的临界值来进行划分。<br>C4.5 使用熵作为区间纯度的度量标准。<br>CART 使用Gini系数作为区间纯度的度量标准。</p></li><li><p>什么是过拟合问题？如何判断过拟合？<br>模型的训练误差低但是泛化误差比较高，则称此分类模型过拟合。</p></li><li><p>如何减少过拟合？<br>一方面要注意数据训练集的质量，选取具有代表性样本的训练样本集。<br>另一方面要避免决策树过度增长，通过限制树的深度来减少数据中的噪声对于决策树构建的影响，一般采取剪枝的方法。</p></li><li><p>在决策树的训练过程中，如果通过剪枝减少过拟合？<br>剪枝是用来缩小决策树的规模，从而降低最终算法的复杂度并提高预测准确度，包括预剪枝、后剪枝两类。<br>预剪枝的思路是提前终止决策树的增长，在形成完全拟合训练样本集的决策树之前就停止树的增长，避免过拟合。<br>后剪枝的策略是先让决策树完全生长，之后针对子树进行判断，用叶子节点或者子树中最常用的分支替换子树，以此方式不断改进决策树，直到无法改进为止。</p></li><li><p>决策树的学习质量如何评价？<br>对于一般的分类问题，有训练误差、泛化误差、准确率、精确率、召回率、F值、ROC曲线等指标</p></li><li><p>ROC曲线如何绘制？它的主要功能是什么？<br>通过将连续变量设定出过个不同的临界值，从而计算出一系列真正率和假正率，再以假正率为纵坐标、真正率为横坐标绘制出ROC曲线。<br>ROC曲线下面积越大，模型的准确性越高。在ROC曲线上，最靠近坐标左上方的点为假正率和真正率均较高的临界值。</p></li><li><p>AUC与ROC的关系是什么？<br>ROC曲线下的面积称为AUC。<br>AUC值越大，表示模型准确性越高。<br>ROC曲线越光滑，一般代表过拟合现象越轻。</p></li><li><p>阅读文献，讨论k折交叉校验的方法。<br>k折交叉验证法将样本集随机地划分为k个大小相等的子集，在每一轮交叉验证中， 选择一个子集作为检验集，其余子集作为训练集，重复k轮，保证每一个子集都作为检验集出现。<br>用K轮检验结果取平均值作为模型好坏的评价标准。</p></li><li><p>集成学习的基本原理是什么？<br>集成学习方法是指组合多个模型，以获得更好的效果，使集成的模型具有更强的泛化能力。<br>最常见的集成思想有两种：bagging、boosting。</p></li><li><p>讨论GBDT算法的过程以及应用。<br>梯度提升决策树算法（GBDT）是利用梯度下降的思想，使用损失函数的负梯度在当前模型的值，作为提升树中残差的近似值，以此来拟合回归决策树。<br>算法过程:<br>初始化决策树，估计一个使损失函数最小化的常数构建一个只有根节点的树。<br>不断提升迭代：<br>计算当前模型中损失函数的负梯度值，作为残差的估计值；<br>估计回归树中叶子节点的区域，拟合残差的近似值；<br>利用线性搜索估计叶子节点区域的值，使损失函数极小化；<br>更新决策时。<br>经过若干轮的提升法迭代后，输出最终的模型。</p></li><li><p>以随机森林为例，讨论集成学习能否提高分类的性能。<br>随机森林算法目标是通过将多个弱学习机（如单棵决策树）组合得到一个强学习机。</p></li><li><p>举例说明决策树在实际分类项目中的应用。</p></li><li><p>计算整个Adult数据集中性别属性的Gini指标值和信息增益。</p></li><li><p>使用Python对Iris数据集实现代价复杂度剪枝策略（CCP）。</p></li></ul><h3 id="聚类分析">聚类分析</h3><ul><li><p>聚类分析的目的是什么？<br>聚类分析用于对未知类别的样本进行划分，将它们按照一定的规则划分成若干个类簇，从而揭示样本之间内在的性质以及相互之间的联系。</p></li><li><p>讨论聚类与分析的关系。<br>聚类算法将未标记的样本自动划分为多个类簇，但不会提供对每个类簇的语义解释，这就需要分析人员对聚类结果进行归纳总结，阐述聚类的意义。</p></li><li><p>聚类分析常用的应用领域有哪些？<br>金融保险、生物学、医学、军事、地理、电子商务等领域都有重要用途。</p></li><li><p>常见的聚类有哪些方法？这些方法分别适用于什么场合？<br>基于划分<br>基于层次<br>基于密度<br>基于模型</p></li><li><p>评价聚类算法的好坏可以从哪些方面入手？<br>良好的可伸缩性、处理不同类型数据的能力、处理噪声的能力、对样本顺序的不敏感性、约束条件下的表现、易解释性、易用性等。<br>外部指标包括: Rand统计量、F值、Jaccard指数、FM指数等<br>内部指标：欧氏距离、曼哈顿距离、切比雪夫距离(Chebyshev distance)、闵可夫斯基距离(Minkowski Distance)、紧密度、分隔度、戴维森堡丁指数(DBI)、邓恩指数等</p></li><li><p>在聚类分析中，样本之间的距离常用的计算方法有哪些？<br>欧氏距离、曼哈顿距离、切比雪夫距离(Chebyshev distance)、闵可夫斯基距离(Minkowski Distance)等</p></li><li><p>简要说明基于划分的聚类方法的基本原理。<br>基于划分的方法通过将对象划分为互斥的簇进行聚类， 每个对象属于且仅属于一个簇。<br>划分结果旨在使簇之间的相似性低，簇内部的相似度高。</p></li><li><p>k-均值算法的聚类数k如何确定？<br>第一种方法：与层次聚类算法结合，先通过层次聚类算法得出大致的聚类数目，并且获得一个初始聚类结果，然后再通过k-均值算法改进聚类结果<br>第二种方法：基于系统演化的方法，将数据集视为伪热力学系统，在分裂和合并过程中，将系统演化到稳定平衡状态从而确定k值</p></li><li><p>讨论初始的k个假设聚类中心位置对k-均值算法的影响。<br>k-means算法对初始化聚类中心依赖性比较大，很可能陷入局部最优的情况或使得迭代次数增加</p></li><li><p>k-medoids算法和k-prototype算法对k-均值算法做了哪些改进？<br>k-medoids(中心点算法)不通过计算簇中所有样本的平均值得到簇的中心，而是通过选取原有样本的样本点作为代表对象代表这个簇，计算剩下的样本点到代表对象的距离，将样本点划分到与其距离最近的代表对象所在的簇中。<br>k-prototypes算法在聚类的过程中，是将数据的数值型变量和类别型变量拆开，分开计算样本间变量的距离，再将两者相加，视为样本间的距离。 准则就是使用一个合适的损失函数去度量数值型和分类变量对原型的距离。</p></li><li><p>简述CLARANS算法的思想。</p></li><li><p>讨论DBSCAN算法的几个参数如何选择。</p></li><li><p>举例说明DBSCAN算法的应用。</p></li><li><p>简述OPTICS算法的原理以及适用场合。</p></li><li><p>简述基于层次聚类的思想。</p></li><li><p>常见的层次聚类算法有哪些？分别阐述其思想。</p></li><li><p>凝聚型层次聚类算法有何优点？结合案例讨论其应用。</p></li><li><p>讨论自组织映射网络Kohonen聚类算法的基本思想，并举例说明其应用。</p></li><li><p>举例讨论聚类算法与其他算法的组合应用。</p></li></ul><h3 id="文本分析">文本分析</h3><ul><li><p>常见的文本数据有哪些来源？<br>公开数据、自有数据、爬虫抓取</p></li><li><p>文本挖掘的过程由哪几个环节组成？这些环节分别负责哪些工作？<br>分词（文本分词、去停词、词形归一等）、 文本特征提取和表示（词性标注、句法分析、语义分析、特征提取与表示等）、 特征选择、 知识提取和挖掘、应用（文本分类、情感分析、信息抽取、问答系统）等。</p></li><li><p>什么是文本的特征？<br>文本中少量的、具有代表性语义的词语。一组文本特征的集合即可代表整个文本的语义。</p></li><li><p>提取文本特征有哪些常用的方法？结合例子讨论这些方法的应用。<br>文本数据表示： 布尔模型、向量空间模型、概率模型、图空间模型等<br>文本特征选择：无监督（TF-IDF）、有监督（卡方、信息增益、互信息、WLLR等）</p></li><li><p>TF-IDF适合提取什么样的文本特征？在使用过程中TF-IDF有哪些问题？</p></li><li><p>向量空间模型的作用以及常用计算是什么？<br>向量空间模型能把文本表示成由多维特征构成的向量空间中的点，从而通过计算向量之间的距离来判定文档和查询关键词之间的相似程度。<br>常用度量方法：最小编辑距离、欧氏距离、余弦距离、Jaccard相似度等</p></li><li><p>分析文本分词的基本思想<br>中文分词主要包括词的歧义切分、未登录词识别。</p></li><li><p>文本分词有哪些常用的算法？<br>基于词典<br>基于统计<br>基于规则</p></li><li><p>讨论IK Analyzer开源中文分词工具包所用的分词算法，并用这个文具对某文本进行分词。<br>IK分词使用了“正向迭代最细粒度切分算法”</p></li><li><p>命名实体识别的基本算法有哪些？<br>最大熵模型：关键是建立有效的特征模板，结合不同层次和粒度的特征建立中文实体语义知识库。<br>支持向量机：对于特征集的要求比较高，例如使用实体属性、词性、实体间关系等有助于提高识别的准确性，这一方法由于在细分类别上的识别效果不佳，应用较少。<br>条件随机场：一种判别式概率模型，通过分析序列资料实现对目标序列建模，相较于最大熵模型，它引入了上下文信息实现对未知词汇的识别。<br>隐马尔科夫模型：依赖于训练语料的标签标记，它的速度要快一些，所以它更适用于信息检索等实时性要求较高的场景。</p><p>基于统计的方法对特征的选取要求很高，对语料库的依赖也比较大，需要从文本中选择对该项任务有影响的特征，目前大部分细分领域的语料库是基于现有素材经过机器或者人工干预的方式构建的。</p></li><li><p>什么是语义消歧？说明常用的语义消歧方法的基本思想。<br>消歧就是根据上下文来确定对象的真实语义。</p><p>基于词典的词义消歧主要是基于覆盖度实现。即通过计算语义词典中各词与上下文之间合理搭配程度，选择与当前语境最合适的词语。<br>有监督的消歧方法使用已经标记好的语义资料集构建模型，通过建立相似词语的不同特征表示实现去除歧义的目的。<br>半监督或无监督方法仅需要少量人工或不需要人工标注语料，但依赖于大规模的未标注语料和语料上的句法分析结果。</p></li><li><p>举例说明常用句法分析方法的思想与应用。</p></li><li><p>语义分析的难点在何处？</p></li><li><p>文本分类常用在什么领域？<br>文本内容分类、观点挖掘、垃圾邮件检测等</p></li><li><p>如何从一篇比较长的新闻中抽取摘要？</p></li><li><p>问答系统的基本原理是什么？其中的核心问题如何解决？<br>问答系统在回答用户问题时，首先需要正确理解用户所提的自然语言问题，并抽取其中的关键语义信息，然后在已有语料库、知识库或问答库中通过检索、匹配、推理的手段获取答案并返回给用户。<br>问答系统的核心问题在于问句理解、文本信息抽取和知识推理。</p></li><li><p>举例说明如何分析电商评论、论坛帖子、微博用户帖子中用户的情感。</p></li><li><p>讨论如何从事件报道中抽取相关的信息。<br>事件抽取技术是从非结构化信息中抽取出用户感兴趣的事件，并以结构化呈现给用户。<br>常用的事件抽取的方法包括模式匹配方法和机器学习方法。</p></li></ul><h3 id="神经网络">神经网络</h3><ul><li><p>简述感知机的基本原理。<br>一个感知机神经元将所有的输入参数$x = (x_1, x_2, … , x_n)$与对应的权值$w = (w_1, w_2, … , w_n)$进行加权求和，经过激活函数变换后输出，公式如下： $ y = f(x * w + b) $</p></li><li><p>讨论BP神经网络的学习过程。<br>初始化网络权值和神经元的阈值，一般通过随机的方式进行初始化。<br>前向传播，计算隐层神经元和输出层神经元的输出。<br>后向传播，根据目标函数公式修正权值 $w_{ij}$ 。<br>上述过程反复迭代，通过损失函数和成本函数对前向传播结果进行判定，并通过后向传播过程对权重参数进行修正，一直到满足终止条件为止。</p></li><li><p>BP神经网络有哪些常见应用？<br><strong>函数逼近</strong>：用输入向量和相应的输出向量训练一个网络逼近一个函数。<br><strong>模式识别</strong>：用一个待定的输出向量将它与输入向量联系起来。<br><strong>分类</strong>：把输入向量所定义的合适方式进行分类。<br><strong>数据压缩</strong>：减少输出向量维数以便于传输或存储。</p></li><li><p>神经网络的激活函数有哪些？它们对神经网络的性能有何影响？<br><strong>Sigmoid</strong>：优点在于输出范围为 $(0, 1)$ ，数据在传递过程中不容易发散，并且可以在输出层表示概率值，容易计算。缺点是梯度下降非常明显，两头过于平坦，容易出现梯度消失，而且输出值域不对称。<br><strong>tanh（双曲正切）</strong>：解决了S函数输出值不对称的问题。另外它是完全可微分和反对称的。然而梯度消失的问题任然存在。为了解决学习缓慢、梯度消失问题，可使用更加平缓的变体，如Symmetrical-Sigmoid、Softsign等<br><strong>ReLu（修正线性单元）</strong>：是神经网络中最常用的激活函数。由于ReLU函数是线性特点使其收敛速度比Sigmoid、Tanh更快，而且没有梯度饱和的情况出现。然而，当输入为负值的时候，ReLU会保持静默。</p><p><a href="https://dashee87.github.io/deep%20learning/visualising-activation-functions-in-neural-networks/" target="_blank" rel="noopener">26种神经网络激活函数可视化</a></p></li><li><p>在BP神经网络训练过程中如何减少陷入最小极值点？</p><ol><li>以多组不同参数初始化多个神经网络，按标准方法训练后取其中误差最小的解作为最终参数。</li><li>模拟退火，在每一步都以一定概率接受比当前解更差的结果，从而有助于跳出局部最小。在每步迭代中接受次优解的概率随着时间的推移而逐渐降低，从而保证算法的稳定。</li><li>随机梯度下降，在计算梯度时加入随机因素，因此即使陷入局部极小点，梯度也可能不为0，就有机会跳出局部最小继续搜索。</li><li>遗传算法。</li></ol></li><li><p>在BP神经网络的训练过程中学习步长、隐层个数、隐层单元数等参数如何调整？<br><strong>算法的步长选择</strong> 步长太大，会导致迭代太快，甚至错过最优解。步长太小，迭代速度慢。<br><strong>网络的层数</strong> 理论已经证明，具有偏差和至少一个S型隐层加上一个线性输出层的网络，能够逼近任何有理函数，增加层数可以进一步降低误差，提高精度，但同时也使网络复杂化。另外不能用仅具有非线性激活函数的单层网络来解决问题，因为能用单层网络解决的问题，用自适应线性网络也一定能解决，而且自适应线性网络的运算速度更快，而对于只能用非线性函数解决的问题，单层精度又不够高，也只有增加层数才能达到期望的结果。<br><strong>隐层单元数</strong> 在能够解决问题的前提下，再加上一两个神经元，以加快误差下降速度即可。</p></li><li><p>RBF神经网络的基本原理是什么？</p></li><li><p>RBF为什么可以减少局部极少值难题？</p></li><li><p>Elman神经网络的优点是什么？</p></li><li><p>与决策树比较，神经网络适合处理什么类型的数据和问题？<br>在中小数据集上，优先选择集成树模型。大数据集上推荐神经网络。<br>在需要模型解释度的项目上，优先使用树模型。<br>在项目时间较短的项目上，如果数据质量低（大量缺失值、噪音等），优先使用集成树模型。<br>在硬件条件有限及机器学习知识有限的前提下，优先选择树模型。<br>对于结构化较高的数据，数据量大的数据，优先使用神经网络模型。</p></li><li><p>如何避免过拟合？<br>参数范数惩罚、数据增强、提前终止、Bagging等集成方法、Dropout、批正则化等</p></li><li><p>为什么要对模型的输入数据进行归一化？<br>归一化的目的就是使得预处理的数据被限定在一定的范围内，从而消除奇异样本数据导致的不良影响。</p></li><li><p>什么是梯度消失？<br>在每次训练的迭代中，神经网络权重的更新值与误差函数的偏导数成比例，然而在某些情况下，梯度值会几乎消失，使得权重无法得到有效更新，甚至神经网络可能完全无法继续训练。</p></li><li><p>如何加快梯度下降的速度？<br>Mini-batch 小批量梯度下降法<br>动量(Momentum)梯度下降<br>RMSprop<br>Adam算法<br>Batch Norm</p><p><a href="https://fivecakes.com/p/5bdfa51fd249870dca3afe22" target="_blank" rel="noopener">几种加速梯度下降的方法</a></p></li></ul><h3 id="贝叶斯网络">贝叶斯网络</h3><ul><li><p>贝叶斯定理的适用条件是什么？<br>条件变量之间的独立性</p></li><li><p>举例说明贝叶斯定理的应用。<br>垃圾邮件过滤器</p></li><li><p>在贝叶斯定理的应用过程中，先验概率如何计算？<br>在对历史数据进行统计分析时，为计算方便，常选择现有数据似然分布的共轭分布族(Conjugate Family)中的分布。</p></li><li><p>与决策树、神经网络分类方法比较，贝叶斯定理用于分类有什么不同？<br>叶斯定理用于分类一般是朴素贝叶斯分类（NBC）。<br>朴素贝叶斯分类发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率。NBC模型所需估计的参数很少，对缺失数据不太敏感，算法也比较简单。<br>因为NBC模型假设属性之间相互独立，所以在属性个数多或者相关性较大时，NBC模型的分类效率比不上决策树模型。NBC模型还需要实现知道先验概率，并且其分类决策存在一定的错误率。</p></li><li><p>贝叶斯网络解决了贝叶斯定理的什么问题？<br>贝叶斯网络解决了变量间需要保持条件独立的假设，贝叶斯网络包括了有向无环图和条件概率表，可以系统地描述变量间的关系。</p></li><li><p>如何构建贝叶斯网络？<br><strong>根据问题和领域专家知识手工构建</strong><br><strong>通过对数据进行分析得到 (贝叶斯网络学习)</strong><br><strong>结合了领域专家知识和数据分析得到</strong></p></li><li><p>结合实例，讨论贝叶斯网络的推理过程。<br><strong>精确推理</strong><br><strong>近似推理</strong></p></li><li><p>缺值环境下的贝叶斯估计要克服什么问题？<br>在缺值时，不能直接套用完整数据下的最大似然估计的方法，需要对数据进行近似处理，常用EM算法处理。<br>缺值状态下的贝叶斯估计也缺少必要的先验信息，因此会使用碎权更新法去确定这部分缺失数据。</p></li><li><p>应用贝叶斯网络适合解决什么问题？<br>贝叶斯网络适用于解决不确定性或不完整性问题。</p></li><li><p>贝叶斯网络如何应用于中文分词？<br>中文分词问题可以描述为给定一句话，将其切分为合乎语法和语义的词语序列。</p><p>设一句完整的话为 $X$，$Y$ 为组成该句话的词语集合，共有 $n$ 个词语。于是分词问题可以转化为求下列式子最大值的问题：<br>$$<br>\begin{align}<br>\displaystyle P(Y|X) =  \frac{P(X|Y) \cdot P(Y)}{P(X)}<br>\end{align}<br>$$<br>也就是 $P(X|Y) \cdot P(Y)$ 最大值。由于任意的分词情况下由词语序列生成句子的精确的，所以可以忽略 $P(X|Y)$ ，因此只需找到 $P(Y)$ 的最大值即可。<br>$$<br>P(Y) = P(Y_1, Y_2, … ,Y_n) = P(Y_1) * P(Y_2 | Y_1) * P(Y_3|Y_1, Y_2) * …<br>$$<br>这样的展开子式是指数级增长的，并且数据稀疏的问题也会越来越明显。所以我们假设每个词语只会依赖于词语序列中该词前面出现的k个词语，即k-gram。这里我们假设 $k=2$，于是就有：<br>$$<br>P(Y) = P(Y_1, Y_2, … ,Y_n) = P(Y_1) * P(Y_2|Y_1) * P(Y_3|Y_2) * …<br>$$</p></li><li><p>使用贝叶斯网络实现一个简单拼写检查。</p><ol><li>建立一个足够大的文本库</li><li>对文本库的每一个单词统计其出现频率</li><li>根据用户输入的单词，得到其所有可能的拼写相近的形式</li><li>比较所有拼写相近的词在文本库的出现频率。频率最高的那个词，就是正确的拼法</li></ol></li></ul><h3 id="支持向量机">支持向量机</h3><ul><li><p>作为一种分类算法，支持向量机的基本原理是什么？<br>支持向量机是一种二类分类模型。<br>它的基本模型是定义在特征控件上的间隔最大的线性分类器。支持向量机还包括和技巧，这使它成为实质上的非线性分类器。<br>支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划的问题，也等价于正则化的合页损失函数的最小化问题。</p></li><li><p>支持向量机适合解决什么问题？<br>支持向量机用于二元分类问题，对于多元分类可以将其分解为多个二元分类问题，再进行分类。</p></li><li><p>支持向量机常用在哪些领域？<br>图像分类、文本分类、人脸识别、垃圾邮件检测等</p></li><li><p>支持向量机常用的核函数有哪些？<br><strong>线性核函数</strong> 主要用于线性可分的情况。<br><strong>多项式核函数</strong> 一种非稳态核函数，适合于正交归一化后的数据。<br><strong>径向基核函数</strong> 具有很强的灵活性，应用广泛。大多数情况下有较好的性能。<br><strong>Sigmoid核</strong> 来源于MLP中的激活函数，SVM使用sigmoid相当于一个两层感知机网络</p></li><li><p>核函数的选择对支持向量机的性能有何影响？<br>只要一个对称函数所对应的核矩阵半正定，它就能作为核函数使用。<br>核函数的使用，不一定能够准确的划分，只能说使用哪个核函数，能够逼近真实的划分效果。因此特征空间的好坏对支持向量机的性能至关重要。<br>在不知道特征映射的形式时，我们并不知道什么样的核函数是合适的，而核函数也仅是隐式定义了这个特征空间。<br>于是，核函数的选择成为了支持向量机的最大变数。若核函数选择不合适，则意味着映射到一个不合适的特征空间，很可能导致性能不佳。</p></li><li><p>支持向量机在使用过程中会遇到哪些主要问题？如何解决？</p></li></ul><h3 id="进化计算">进化计算</h3><ul><li><p>遗传算法可以解决哪些问题？<br>遗传算法主要解决技术优化问题，可用于解决数值优化、组合优化、智能控制、人工生命、图像处理、模式识别等领域的问题。<br>比如函数最值问题、旅行商问题、背包问题、车辆路径问题、生产排程问题、选址问题等。</p></li><li><p>讨论遗传算法用于分类问题的原理。<br>用遗传算法解决分类问就是找到一组能姮好拟合训练样本的IF-THEN规则，也就是目标概念。<br>学习过程可以看作是一个搜索过程，也就是在搜索空间中搜索目标概念，目标概念的表示方法有种群表示方法以及单条染色体表示方法。</p></li><li><p>遗传算法的目标函数如何构造？<br>目标函数的构造与期望值有关，同时需要不断尝试，把每一次的目标函数以及得到的结果的平均值记录下来，绘制成图，选择可以使得遗传算法最有效的目标函数</p></li><li><p>讨论遗传算法的常用编码方式<br><strong>二进制编码</strong> 使用0或1表示染色体的基因信息，如0100100<br><strong>格雷编码</strong> 两个相邻的数用格雷码表示，其对应的码位只有一个不相同，从而可以提高算法的局部搜索能力。<br><strong>浮点编码</strong> 是指将个体范围映射到对应浮点数区间范围，精度可以随浮点数区间大小而改变, 用于多维、高精度的连续函数优化问题。<br><strong>符号编码</strong> 指染色体编码串中的基因值可能涉及符号集的字符。使用符号编码，便于编码有意义的基因值。如ADJHKDH</p></li><li><p>遗传算法的步骤有哪些？讨论每个步骤的主要工作。</p><ol><li>随机产生种群</li><li>用轮盘赌策略确定个体的适应度，判断是否符合优化准则，若符合，输出最佳个体及其最优解并结束，否则，进行下一步。</li><li>依据适应度选择再生个体，适应度高的个体被选中的概率高，适应度低的个体被淘汰。</li><li>按照一定的交叉概率和交叉方法，生成新的个体。</li><li>按照一定的变异概率和变异方法，生成新的个体。</li><li>由交叉和变异产生新的一代种群，返回步骤2。</li></ol></li><li><p>初始种群的大小对遗传算法的性能有何影响？<br>规模较大的群体一般对应的个体多样性较高，可以避免算法陷入局部最优解，但计算复杂、算法效率低。<br>群体的规模选择过小会使搜索空间分布范围不足，搜索有可能会停止在一个次优解。</p></li><li><p>讨论基因突变的概率对遗传算法的影响。</p></li><li><p>遗传算法的不足是什么？</p></li><li><p>蚁群算法的原理是什么？<br>蚁群算法来源于蚂蚁寻找食物的过程。<br>蚂蚁总能发现一条从蚁巢到食物源的最短路径。<br>蚂蚁能够在经过的路途中留下“信息素”作为标记，以此来指导自己的活动轨迹。<br>蚂蚁倾向于发现那些“信息素”浓度高的路径，某一路径上走过的蚂蚁越多，遗留下的“信息素”越多，被选中的概率越大，最终形成最短路径。</p></li><li><p>与遗传算法比较，蚁群算法为什么能取得更优的结果？</p></li><li><p>结合案例，讨论蚁群算法的应用过程。</p></li><li><p>与蚁群算法相比，蜂群算法有什么不同？</p></li><li><p>蜂群算法的主要步骤有哪些？</p><ol><li>初始化。</li><li>重复3 ~ 7</li><li>将采蜜蜂与蜜源一一对应，更新蜜源信息，同时确定蜜源的花蜜量。</li><li>观察蜂根据采蜜蜂所提供的信息采用一定的选择策略选择蜜源，根据第一个公式更新蜜源信息，同时确定蜜源的花蜜量。</li><li>确定侦查蜂，寻找新的蜜源。</li><li>记忆迄今为止最好的蜜源。</li><li>判断是否终止。</li></ol></li><li><p>举例说明蜂群算法的应用。</p></li></ul><h3 id="分布式机器学习">分布式机器学习</h3><ul><li><p>分布式学习用在什么场合？<br>机器学习是计算机利用已有的数据生成某种模型，并且利用此模型预测的一种方法。<br>在确定模型结构之后，根据已知模型寻找模型参数的过程就是训练，训练过程中不断依据训练数据来迭代调整模型的参数值，从而使结果更加准确。<br>训练数据集大，模型参数量多，并且各参数需要频繁访问，此时需要进行分布式学习。</p></li><li><p>讨论分布式计算的常用方法。<br><strong>模型并行</strong> 是指在分布式系统不同机器负责网络模型的不同部分。<br><strong>数据并行</strong> 是指不同机器使用同一模型，但是各台机器处理训练数据分割后形成的不同的子数据集。<br><strong>混合并行</strong></p></li><li><p>简述MapReduce计算框架的基本原理。<br>MapReduce框架由一个单独的JobTracker以及每个集群节点对应一个备TaskTracker组成。<br>JobTracker负责调度作业的所有任务，并监控它们的执行，这些任务分布在不同的TaskTracker上，如果任务执行失败，还会调度其重新执行。<br>一个MapReduce作业通常把输入的数据集切分成若干独立的数据块，由Map任务以并行的方式处理，Map输出结果经框架排序后输入到Reduce任务中。<br>整个框架负责任务的调度和监控。</p></li><li><p>MapReduce的过程由哪些环节组成？这些环节分别处理什么工作？</p></li><li><p>为什么Hadoop架构不能处理实时的数据分析工作？<br>Hadoop是一个批处理框架，相较于那些支持流数据的框架，多了些收集数据的时间以及作业调度的时延。<br>从时延角度看，Hadoop不适合处理实时的数据分析工作。<br>Hadoop是基于MapReduce模型的，处理海量数据的离线分析工具，MapReduce模型在实时领域很难有所发挥。</p></li><li><p>举例说明MapReduce的应用。<br>MapReduce多应用在日志分析、搜索引擎、数据挖掘以及信息提取等领域。<br>例如索引系统是Google最大的MapReduce应用程序。Yahoo定期在搜索业务上使用Hadoop来提高其产品和服务，如排名功能和目标广告等。</p></li><li><p>与Hadoop相比，Spark对大数据的处理速度为什么显著提升？<br>Spark是基于内存计算的，省去了Hadoop的大量的磁盘读写操作。<br>Spark对于迭代操作支持延迟处理，在Action操作时才会进行真正的运算。这时可以对计算进行优化，也可以加快处理速度。</p></li><li><p>结合实例，讨论MapReduce在并行决策树算法的应用。<br>并行决策树算法基于MapReduce框架核心思想是分而治之的策略。 将决策树算法中最耗时的属性相似度计算并行运行可以大大提高运行效率。<br>在Map阶段，Map函数以单个元组的形式分解数据。计算属性的相似度，并以&lt;属性名,相似度&gt;的形式输出数据。<br>Reduce阶段，对输出结果中的所有局部结果及相关汇总，找到最大相似度的属性名，选择这个属性作为测试节点，判断它是否为叶子节点，如果是叶子节点，则返回；反之，执行分裂，并将其录入待计算数据库中存储。</p></li><li><p>结合实例，讨论并行k-均值算法的计算过程。</p></li><li><p>查找资料，讨论如何对关联算法Apriori进行并行化改造？</p></li><li><p>讨论对于大样本数据，如何对多元线性回归模型进行并行化改造？</p></li></ul><h3 id="深度学习">深度学习</h3><ul><li><p>深度学习的提出背景是什么？<br>深度学习是一种利用复杂结构的多个处理层来实现对数据进行高层次抽象的算法，是机器学习的一个重要分支。<br>传统的BP算法仅有几层网络，需要手工指定特征且易出现局部最优问题，而深度学习引入了概率生成模型，可自动地从训练集提取特征，解决了手工特征考虑不周的问题。<br>而且初始化了神经网络权重，采用反向传播算法进行训练，与BP算法相比取得了很好的效果。</p></li><li><p>讨论大数据技术对深度学习的促进作用。<br>除了组织存储的数据类型的不同，数据的绝对量是促进深度学习工具和技术发展的一个关键因素。积累了足够的数据后，技术才能更好地发挥作用。</p></li><li><p>比较深度学习主流的几种学习框架。<br><strong>Torch</strong><br><strong>TensorFlow</strong><br><strong>Caffe</strong><br><strong>Keras</strong></p></li><li><p>描述卷积神经网络的结构。<br>卷积神经网络是一种稀疏的网络结构，其中卷积层和子采样层是特征提取功能的核心模块。<br>卷积神经网络采用梯度下降的方式，应用最小化损失函数对网络中各节点的权重参数逐层调节，通过反向递推，不断地调整参数使得损失函数的结果逐渐变小，从而提升整个网络的特征描绘能力，使卷积神经网络分类的精确度和准确率不断提高。</p></li><li><p>卷积神经网络适合解决什么问题？</p></li><li><p>举例说明卷积神经网络的应用。</p></li><li><p>卷积神经网络的输入如何编码？</p></li><li><p>在卷积神经网络中，卷积层和池化层的参数如何确定？</p></li><li><p>常见的卷积神经网络有哪些？<br><a href="http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf" target="_blank" rel="noopener">LeNet</a><br><a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="noopener">AlexNet</a><br><a href="https://arxiv.org/abs/1409.1556" target="_blank" rel="noopener">VggNet</a><br><a href="https://arxiv.org/abs/1512.03385" target="_blank" rel="noopener">ResNet</a></p></li><li><p>卷积神经网络的各层激活函数如何选择？</p></li><li><p>如何防止卷积神经网络的过拟合问题？</p></li><li><p>简述循环神经网络模型的工作原理。<br>循环神经网络是一种对序列数据建模的神经网络。<br>循环神经网络中一个当前神经元的输出与前面的输出也有关，网络会对前面的信息进行记忆并应用于当前神经元的计算中，即隐藏层之间的节点是有连接的，并且隐藏层的输入不仅包括输入层的输出还包括上一时刻隐藏层的输出。<br>理论上，循环神经网络可以对任何长度的序列数据进行处理。但是在实践中，为了降低复杂性往往假设当前的状态只与前面的几个状态相关。</p></li><li><p>循环神经网络的常用应用领域有哪些？</p></li><li><p>举例说明循环神经网络的应用过程。</p></li><li><p>结合长短期记忆神经网络的结构解释其工作过程。</p></li><li><p>举例说明长短期记忆神经网络的应用。</p></li><li><p>卷积神经网络如何进行调优？结合具体案例说明。</p></li></ul><h3 id="高级深度学习">高级深度学习</h3><ul><li><p>目标检测和追踪中的运动目标如何合理地表示？<br>首先要获取目标的初始状态并且提取目标的特征，在此基础上构建目标描述模型，模型可分为生成式模型和判别式模型。<br>生成式方法运用生成模型描述目标的表现特征，之后通过搜索候选目标来最小化重构误差。<br>判别式方法通过训练分类器来区分目标和背景。</p></li><li><p>目标检测与追踪的深度学习框架有哪些？<br>基于分类的算法有R-CNN，Fast R-CNN，Faster R-CNN。<br>基于回归的深度学习框架有 YOLO（You Only Look Once) 和 SSD(Single Shot Multibox Detector)</p></li><li><p>举例说明R-CNN的应用。<br>R-CNN可以用于目标检测、图像识别、检索和分类。</p></li><li><p>长短期记忆神经网络的编码-解码模型有哪些？</p></li><li><p>如何理解循环神经网络的记忆力模型？</p></li><li><p>长短期记忆神经网络在图片标注和看图说话等应用中需要注意什么问题？</p></li><li><p>讨论生成式对抗模型的组成。<br>生成对抗网络由一个生成网络与一个判别网络组成。<br>生成对抗网络的实现方法是让生成模型和判别模型进行博弈，训练过程通过互相博弈使两个模型的性能同时增强。<br>生成模型需要在整个条件内去产生数据的分布，就像高斯分布一样，它需要去拟合整个分布。<br>判别模型就像分类一样，通过一个判别界限去区分样本。</p></li><li><p>举例说明生成式对抗模型的应用。</p></li><li><p>迁移学习解决什么问题？<br><strong>小数据的问题</strong><br><strong>个性化的问题</strong></p></li><li><p>迁移学习常用的方法有哪些？<br><strong>基于样本的迁移学习</strong><br><strong>基于特征的迁移学习</strong><br><strong>基于模型的迁移学习</strong><br><strong>基于关系知识的迁移</strong></p></li><li><p>强化学习的基本思想是什么？<br>强化学习是目标导向的，从白纸一张的状态开始，经由许多个步骤来实现某一个维度上的目标最大化。在训练的过程中不断尝试，错误就惩罚，正确就奖励，由此训练得到的模型在各个状态环境下都最好。</p></li><li><p>简述Q-学习的基本过程。<br>Q-学习是让主体从一个状态到另一个状态不断转换进行探索学习。<br>主体的每一次探索都会从初始状态到目标状态，相当于一次迭代，训练越多，学到的东西越多。<br>初始化Q，初始化状态奖励值。 主体会探索很多状态直到发现一个奖励，此时更新Q。直到Q收敛。</p></li><li><p>强化学习如何与深度学习结合？</p></li></ul><h3 id="推荐系统">推荐系统</h3><ul><li><p>推荐系统的功能是什么？<br>推荐系统是一种帮助用户快速发现有用信息的工具。<br>通过分析用户的历史行为，研究用户偏好，对用户兴趣建模，从而主动给用户推荐能够满足他们感兴趣的信息。<br>本质上，推荐系统是解决用户额外信息获取的问题。在海量冗余信息的情况下，用户容易迷失目标，推荐系统主动筛选信息，将基础数据与算法模型进行结合，帮助其确定目标，最终达到智能化推荐。</p></li><li><p>讨论推荐系统的结构组成。<br><strong>输入模块</strong><br><strong>推荐算法模块</strong><br><strong>推荐输出模块</strong></p></li><li><p>推荐系统常用于哪些领域？<br>可用于电商平台、个性化电影网站、音乐歌单、社交网络、新闻网站、个性化阅读、个性化广告等。</p></li><li><p>推荐系统常用哪些方法？这些方法分别适用什么场合？<br><strong>基于人口统计学的推荐</strong><br><strong>基于内容的推荐</strong> 适用于物品特征易于提取的场合<br><strong>基于协同过滤的推荐</strong> 适用于能够获取到用户历史行为的场合<br><strong>基于关联规则的推荐</strong> 常用于实体商店或在线电商的推荐系统<br><strong>基于知识的推荐</strong><br><strong>基于约束的推荐</strong><br><strong>基于标签的推荐</strong> 适用于有描述信息的关键词产生和应用的场合</p></li><li><p>基于内容的推荐基本思想是什么？<br>根据物品的属性和用户的特殊偏好，直观的选择可推荐物品。</p></li><li><p>举例说明基于内容的推荐应用过程。<br>UserA偏爱科幻小说，ItemA是一本科幻小说，系统便会直接推荐ItemA给UserA。</p></li><li><p>如何为用户和物品建模？</p></li><li><p>如何计算推荐过程中用户和商品的相似性？</p></li><li><p>基于协同过滤的推荐基本思想是什么？</p></li><li><p>基于协同过滤的推荐适用于什么场合？</p></li><li><p>基于用户的协同推荐与基于物品的协同有什么不同？</p></li><li><p>什么是冷启动问题？如何解决？<br>冷启动是数据较少问题。<br><strong>系统冷启动</strong> 先建立起物品的相关度，通过某一物品可以检索到与之相似的其他物品，用户表现出对物品感兴趣后推荐与之相似的其他物品。<br><strong>物品冷启动</strong> 新上线的物品可以利用物品内容相似性，推荐给喜欢类似物品的用户。<br><strong>用户冷启动</strong> 提供非个性化推荐，比如热门排行。或者利用用户注册信息以及用户的社交网络账号。</p></li><li><p>举例说明基于图的推荐算法基本思想及其应用。</p></li><li><p>举例说明隐语义模型在推荐中的应用。</p></li><li><p>简述Apriori和FP增长等关联算法的基本过程。</p></li><li><p>举例说明关联推荐的过程。</p></li><li><p>推荐算法的性能如何评价？<br>满意度、预测准确度、覆盖率、多样性、新颖性、惊喜度、信任度、实时性、健壮性等</p></li><li><p>如何组合基于内容的推荐与基于协同的推荐等多种推荐算法？</p></li><li><p>查找资料，讨论推荐系统的最新发展趋势。</p></li></ul><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://www.amazon.cn/dp/B07NYN8JR1" target="_blank" rel="noopener">机器学习</a></p>]]></content>
    
    <summary type="html">
    
      上帝说，要有光。
    
    </summary>
    
    
      <category term="ReadingNotes" scheme="https://neo1989.net/categories/ReadingNotes/"/>
    
    
      <category term="DAE" scheme="https://neo1989.net/tags/DAE/"/>
    
      <category term="ML" scheme="https://neo1989.net/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode」983. Minimum Cost For Tickets (M)</title>
    <link href="https://neo1989.net/Cramming/CRAMMING-4/"/>
    <id>https://neo1989.net/Cramming/CRAMMING-4/</id>
    <published>2020-11-21T15:38:36.000Z</published>
    <updated>2021-04-23T08:25:58.476Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>In a country popular for train travel, you have planned some train travelling one year in advance.  The days of the year that you will travel is given as an array days.  Each day is an integer from 1 to 365.</p><p>Train tickets are sold in 3 different ways:</p><pre><code>1-day pass is sold for costs[0] dollars;7-day pass is sold for costs[1] dollars;30-day pass is sold for costs[2] dollars.</code></pre><p>The passes allow that many days of consecutive travel.  For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.</p><p>Return the minimum number of dollars you need to travel every day in the given list of days.</p><p><strong>Example 1:</strong></p><pre><code>Input: days = [1,4,6,7,8,20], costs = [2,7,15]Output: 11Explanation:For example, here is one way to buy passes that lets you travel your travel plan:On day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.On day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.In total you spent $11 and covered all the days of your travel.</code></pre><p><strong>Example 2:</strong></p><pre><code> Input: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15] Output: 17 Explanation:  For example, here is one way to buy passes that lets you travel your travel plan: On day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30. On day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31. In total you spent $17 and covered all the days of your travel.</code></pre><p><strong>Note</strong></p><pre><code> 1 &lt;= days.length &lt;= 365 1 &lt;= days[i] &lt;= 365 days is in strictly increasing order. costs.length == 3 1 &lt;= costs[i] &lt;= 1000</code></pre></blockquote><h3 id="思路">思路</h3><pre><code>动态规划</code></pre><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mincostTickets</span><span class="params">(days, costs)</span>:</span></span><br><span class="line">    dayset = set(days)</span><br><span class="line">    tickets = list(zip([<span class="number">1</span>, <span class="number">7</span>, <span class="number">30</span>], costs))</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @lru_cache()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(i)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">365</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">elif</span> i <span class="keyword">in</span> dayset:</span><br><span class="line">            <span class="keyword">return</span> min(dp(i + d) + c <span class="keyword">for</span> d, c <span class="keyword">in</span> tickets)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> dp(i + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><hr><p><img src="http://s3.mindex.xyz/blog/coder/leetcode/leetcode-983.png" alt="Submissions"></p><h3 id="Reference-参考">Reference 参考</h3><p>[1] <a href="https://leetcode.com/problems/minimum-cost-for-tickets/" target="_blank" rel="noopener">983. Minimum Cost For Tickets</a></p>]]></content>
    
    <summary type="html">
    
      磨刀不误砍柴工
    
    </summary>
    
    
      <category term="Cramming" scheme="https://neo1989.net/categories/Cramming/"/>
    
    
      <category term="LeetCode" scheme="https://neo1989.net/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode」 3. Longest Substring (M)</title>
    <link href="https://neo1989.net/Cramming/CRAMMING-3/"/>
    <id>https://neo1989.net/Cramming/CRAMMING-3/</id>
    <published>2020-11-16T15:38:36.000Z</published>
    <updated>2021-04-22T13:14:42.010Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Given a string s, find the length of the longest substring without repeating characters.</p><p><em>Constraints:</em><br>0 &lt;= s.length &lt;= 5 * 104<br>s consists of English letters, digits, symbols and spaces.</p><p><strong>Example 1:</strong></p><p>Input: s = “abcabcbb”<br>Output: 3<br>Explanation: The answer is “abc”, with the length of 3.</p><p><strong>Example 2:</strong></p><p>Input: s = “bbbbb”<br>Output: 1<br>Explanation: The answer is “b”, with the length of 1.</p><p><strong>Example 3:</strong></p><p>Input: s = “pwwkew”<br>Output: 3<br>Explanation: The answer is “wke”, with the length of 3.</p></blockquote><h3 id="思路">思路</h3><pre><code>滑动窗口</code></pre><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(self, s: str)</span> -&gt; int:</span></span><br><span class="line">    chars = set()</span><br><span class="line">    length = len(s)</span><br><span class="line"></span><br><span class="line">    answer, rp = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">        <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">            chars.remove(s[i - <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> rp &lt; length <span class="keyword">and</span> s[rp] <span class="keyword">not</span> <span class="keyword">in</span> chars:</span><br><span class="line">            chars.add(s[rp])</span><br><span class="line">            rp += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        answer = max(answer, rp - i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><hr><p><img src="http://s3.mindex.xyz/blog/coder/leetcode/leetcode-3.png" alt="Submissions"></p><h3 id="Reference-参考">Reference 参考</h3><p>[1] <a href="https://leetcode.com/problems/longest-substring-without-repeating-characters" target="_blank" rel="noopener">3. Longest Substring Without Repeating Characters</a></p>]]></content>
    
    <summary type="html">
    
      磨刀不误砍柴工
    
    </summary>
    
    
      <category term="Cramming" scheme="https://neo1989.net/categories/Cramming/"/>
    
    
      <category term="LeetCode" scheme="https://neo1989.net/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode」 322. Coin Change (M)</title>
    <link href="https://neo1989.net/Cramming/CRAMMING-2/"/>
    <id>https://neo1989.net/Cramming/CRAMMING-2/</id>
    <published>2020-11-03T15:44:40.000Z</published>
    <updated>2021-01-13T16:29:17.875Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p><p><strong>Example 1:</strong></p><p>Input: coins = [1, 2, 5], amount = 11<br>Output: 3<br>Explanation: 11 = 5 + 5 + 1</p><p><strong>Example 2:</strong></p><p>Input: coins = [2], amount = 3<br>Output: -1</p><p><strong>Note:</strong><br>You may assume that you have an infinite number of each kind of coin.</p></blockquote><h3 id="思路">思路</h3><pre><code>dp[i] = min(dp[i], dp[i-c] + 1)</code></pre><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins, amount)</span>:</span></span><br><span class="line">    dp = [<span class="number">0</span>] + [float(<span class="string">'inf'</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(amount)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, amount+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> c <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="keyword">if</span> c &lt;= i:</span><br><span class="line">                dp[i] = min(dp[i], dp[i-c] + <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> <span class="keyword">if</span> dp[amount] &gt; amount <span class="keyword">else</span> dp[amount]</span><br></pre></td></tr></table></figure><h3 id="Golang">Golang</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">coinChange</span><span class="params">(coins []<span class="keyword">int</span>, amount <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="keyword">int</span>, amount+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= amount; i++ &#123;</span><br><span class="line">        dp[i] = amount + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i&lt;=amount; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> _, c := <span class="keyword">range</span>(coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> i &gt;= c &amp;&amp; dp[i] &gt; dp[i-c] + <span class="number">1</span> &#123;</span><br><span class="line">                dp[i] = dp[i-c] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dp[amount] &gt; amount &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Rust">Rust</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">coin_change</span></span>(coins: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;, amount: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> dp: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt; = <span class="built_in">vec!</span>[<span class="number">0</span>; (amount+<span class="number">1</span>) <span class="keyword">as</span> <span class="built_in">usize</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..amount+<span class="number">1</span> &#123;</span><br><span class="line">        dp[i <span class="keyword">as</span> <span class="built_in">usize</span>] = amount + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..amount+<span class="number">1</span>&#123;</span><br><span class="line">        coins.iter().for_each(|c|</span><br><span class="line">            <span class="keyword">if</span>(*c &lt;= i &amp;&amp; dp[i <span class="keyword">as</span> <span class="built_in">usize</span>] &gt; dp[(i - *c) <span class="keyword">as</span> <span class="built_in">usize</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i <span class="keyword">as</span> <span class="built_in">usize</span>] = dp[(i - *c) <span class="keyword">as</span> <span class="built_in">usize</span>] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> dp[amount <span class="keyword">as</span> <span class="built_in">usize</span>] &gt; amount &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[amount <span class="keyword">as</span> <span class="built_in">usize</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C">C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>* coins, <span class="keyword">int</span> coinsSize, <span class="keyword">int</span> amount)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> POS_INF = <span class="number">1.0</span> / <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">float</span> dp[amount+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=amount; i++)&#123;</span><br><span class="line">         dp[i] = (i == <span class="number">0</span>) ? <span class="number">0</span> : POS_INF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=amount; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;coinsSize; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = coins[j];</span><br><span class="line">            <span class="keyword">if</span> (c &lt;= i &amp;&amp; (<span class="keyword">float</span>)dp[i] &gt; dp[i-c] + <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i] = dp[i-c] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; (<span class="keyword">float</span>)amount ? <span class="number">-1</span> : (<span class="keyword">int</span>)dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java">Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">double</span> dp[] = <span class="keyword">new</span> <span class="keyword">double</span>[amount+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;=amount; i++) &#123;</span><br><span class="line">       dp[i] = i == <span class="number">0</span> ? <span class="number">0</span> : Double.POSITIVE_INFINITY;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=amount; i++) &#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> c: coins) &#123;</span><br><span class="line">           <span class="keyword">if</span> (c &lt;= i &amp;&amp; dp[i] &gt; dp[i-c] + <span class="number">1</span>) &#123;</span><br><span class="line">               dp[i] = dp[i-c] + <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> dp[amount] &gt; amount ? -<span class="number">1</span> : (<span class="keyword">int</span>)dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Javascript">Javascript</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> coinChange = <span class="function"><span class="keyword">function</span>(<span class="params">coins, amount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dp = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;=amount; i++)&#123;</span><br><span class="line">        dp[i] = (i == <span class="number">0</span>) ? <span class="number">0</span> : <span class="literal">Infinity</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=amount; i++) &#123;</span><br><span class="line">        coins.forEach(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (c &lt;= i) &#123;</span><br><span class="line">                dp[i] = <span class="built_in">Math</span>.min(dp[i], dp[i - c] + <span class="number">1</span>)</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;) </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] &gt; amount ? <span class="number">-1</span> : dp[amount]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><img src="http://s3.mindex.xyz/blog/coder/leetcode/leetcode-322.png" alt="Submissions"></p><h3 id="Reference-参考">Reference 参考</h3><p>[1] <a href="https://leetcode.com/problems/coin-change" target="_blank" rel="noopener">322. Coin Change</a></p>]]></content>
    
    <summary type="html">
    
      磨刀不误砍柴工
    
    </summary>
    
    
      <category term="Cramming" scheme="https://neo1989.net/categories/Cramming/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
      <category term="LeetCode" scheme="https://neo1989.net/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>「LeetCode」 62. Unique Paths (M)</title>
    <link href="https://neo1989.net/Cramming/CRAMMING-1/"/>
    <id>https://neo1989.net/Cramming/CRAMMING-1/</id>
    <published>2020-11-02T15:30:09.000Z</published>
    <updated>2021-01-13T16:29:45.816Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).<br>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).<br>How many possible unique paths are there?</p><p><strong>Example 1:</strong><br><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt=""><br>Input: m = 3, n = 7<br>Output: 28</p><p><strong>Example 2:</strong></p><pre><code>Input: m = 3, n = 2Output: 3Explanation:From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -&gt; Down -&gt; Down2. Down -&gt; Down -&gt; Right3. Down -&gt; Right -&gt; Down</code></pre></blockquote><h3 id="思路">思路</h3><p>由于机器人只能向右走和向下走，所以:</p><ol><li>地图的第一行和第一列的走法数都是 1</li><li>其他任意一点的走法数是: dp[i][j] = dp[i-1][j] + dp[i][j-1]</li></ol><h3 id="Python">Python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">    path = [[<span class="number">1</span> <span class="keyword">if</span> i==<span class="number">0</span> <span class="keyword">or</span> j == <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span> <span class="keyword">for</span> j <span class="keyword">in</span> range(m)] <span class="keyword">for</span> i <span class="keyword">in</span> range(n)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">            path[i][j] = path[i<span class="number">-1</span>][j] + path[i][j<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> path[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h3 id="Golang">Golang</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">uniquePaths</span><span class="params">(m <span class="keyword">int</span>, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">dp := <span class="built_in">make</span>([][]<span class="keyword">int</span>, n)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">dp[i] = <span class="built_in">make</span>([]<span class="keyword">int</span>, m)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">dp[<span class="number">0</span>][i] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">dp[i][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">1</span>; j &lt; m; j++ &#123;</span><br><span class="line">dp[i][j] = dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Rust">Rust</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">unique_paths</span></span>(m: <span class="built_in">i32</span>, n: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> m: <span class="built_in">usize</span> = m <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">    <span class="keyword">let</span> n: <span class="built_in">usize</span> = n <span class="keyword">as</span> <span class="built_in">usize</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> paths: <span class="built_in">Vec</span>&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;&gt; = <span class="built_in">vec!</span>[<span class="built_in">vec!</span>[<span class="number">0</span>; m]; n];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..m &#123;</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">0</span>..n &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>)&#123;</span><br><span class="line">                paths[j][i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..m &#123;</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="number">1</span>..n &#123;</span><br><span class="line">            paths[j][i] = paths[j-<span class="number">1</span>][i] + paths[j][i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> paths[n-<span class="number">1</span>][m-<span class="number">1</span>];      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C">C</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> paths[n][m]; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                paths[j][i] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                paths[j][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;m; i++) &#123;</span><br><span class="line">            paths[j][i] = paths[j<span class="number">-1</span>][i] + paths[j][i<span class="number">-1</span>];  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> paths[n<span class="number">-1</span>][m<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java">Java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] paths =  <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j == <span class="number">0</span>) &#123;</span><br><span class="line">                paths[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                paths[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">            paths[i][j] = paths[i-<span class="number">1</span>][j] + paths[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> paths[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Javascript">Javascript</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> uniquePaths = <span class="function"><span class="keyword">function</span>(<span class="params">m, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> paths = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</span><br><span class="line">        paths[j] = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || j ==<span class="number">0</span>) &#123;</span><br><span class="line">                paths[j][i] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                paths[j][i] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">1</span>; j&lt;n; j++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;m; i++) &#123;</span><br><span class="line">            paths[j][i] = paths[j<span class="number">-1</span>][i] + paths[j][i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> paths[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><p><img src="http://s3.mindex.xyz/blog/coder/leetcode/leetcode-62.png" alt="Submissions"></p><h3 id="Reference-参考">Reference 参考</h3><p>[1] <a href="https://leetcode.com/problems/unique-paths" target="_blank" rel="noopener">62. Unique Paths</a></p>]]></content>
    
    <summary type="html">
    
      磨刀不误砍柴工
    
    </summary>
    
    
      <category term="Cramming" scheme="https://neo1989.net/categories/Cramming/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
      <category term="LeetCode" scheme="https://neo1989.net/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>自学机器学习十诫</title>
    <link href="https://neo1989.net/MachineLearning/ML-the-10-commandments-of-self-taught-machine-learning-engineers/"/>
    <id>https://neo1989.net/MachineLearning/ML-the-10-commandments-of-self-taught-machine-learning-engineers/</id>
    <published>2020-11-02T09:27:40.000Z</published>
    <updated>2021-01-30T07:16:13.124Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>戒律和自学这两个词不能掉以轻心。一个人必须对自己的教育和启蒙负责。如果你忽略它，别人就会为你做选择。</p></blockquote><h2 id="Gists-摘要">Gists 摘要</h2><h3 id="数学，代码和数据是你最重要的Trinity">数学，代码和数据是你最重要的Trinity</h3><p>任何有效的机器学习管道都是数学、代码和数据的交叉。每一项只有和另一项在一起时才会有效果。</p><p>如果你的数据质量很差，那么无论你的数学计算多么优雅或代码多么高效都没用。</p><p>如果你的数据质量最高，但你的数学计算错误，那么你的结果可能会不是很好，甚至会更糟，造成伤害。</p><p>如果你的数据和数学都是世界级的，但是你的代码效率很低，那么你将无法获得扩展带来的好处。</p><p>数据为你提供了一个包含自然瑰宝的采矿地点。数学就是你的十字镐。代码可以让你建立一支挥舞着十字镐的机器人队伍。</p><p>Trinity是你系统的输入(你拥有的)和输出(你想要的)之间的桥梁。</p><h3 id="唯一例外">唯一例外</h3><p>除了不能平衡Trinity，还有一个更大的罪过：忘记这Trinity是为谁服务的。即使是执行得最好、由最优雅的数学驱动的代码，如果不能为客户提供服务，从最丰富的数据中获得洞察也毫无意义。</p><p>工程师经常会发现自己迷失在一个过程中，忘记了最初想要的结果。尽管他们怀着良好的意图进行，但他们忘记了，意图并不像行动那么重要。</p><p>Trinity至少要为客户提供点好处，总比什么都不提供要好。</p><p>需要澄清的是，如果你的先进模型需要47倍的时间才能提高1%的准确率，那么它是否提供了最好的体验？</p><h3 id="不要被Trinity给骗了">不要被Trinity给骗了</h3><p>无论你多么崇拜这Trinity，你都不应该被你的爱蒙蔽。自学成才的机器学习工程师是他们自己的最大的怀疑者。</p><p>他们知道，数据不能进行证明，只能进行反驳(只要在十亿数据中有一个数据点就能证明之前的概念是错误的)，一点点糟糕的数学运算就会产生极端的后果(自然不是线性的)，代码的效率只有在它最薄弱的地方才有。</p><p>无论Trinity多么神圣，直觉也不应被忽视。如果一个结果好得令人难以置信，除非你很幸运，否则它很可能就是错的。</p><h3 id="和客户保持好关系">和客户保持好关系</h3><p>让机器做它们擅长的事情(反复重复过程)。让你去做你擅长的事情时(关心、设身处地、提问、倾听、领导、教学)。</p><p>你的客户不像你那样关心Trinity。他们关心他们的需求是否得到满足。</p><h3 id="向先驱致敬">向先驱致敬</h3><p>当你想到计算机、机器学习、人工智能、数学等领域时，你会想到谁的名字？</p><p>Ada Lovelace，Geoffrey Hinton，Yann LeCun，Yoshua Bengio，Alan Turing，Fei Fei Li，Grace Hopper，Andrew Ng，Jon Von Neumann，Alan Kay，Stuart Russel，Peter Norvig？</p><p>当然，在你听到或记住的所有名字中，有1000个名字功不可没，但却从历史书中消失了。</p><p>后起之秀应该认可前辈们做出的巨大努力，但也应该认可他们中的每一个人都会告诉这位新晋的机器学习工程师同样的事情：这个领域的未来取决于你的工作。</p><h3 id="适时重写">适时重写</h3><p>你的目标应该是在第一时间构建可靠的东西。但随着技能的提高，你可能会重构之前的作品，拆掉它们，用新的视角重新创造它们。</p><p>自学成才的机器学习工程师都明白，就像大自然一样，软件和机器学习项目永远不会完成，它们一直在运动。数据变化，代码在新的硬件上执行，一个天才发现了一个计算高效，低内存依赖的优化器适合，并称之为“亚当”。</p><p>你不仅应该对这些变化持开放态度，还应该欢迎它们。一旦它们出现，请使用你最好的判断力来判断它们是否值得实现到你的系统中 —— 因为有些东西是新的，并不意味着它是必需的。</p><h3 id="不要成为工具奴">不要成为工具奴</h3><p>在编程界，一个常见的轶事是粉刷自行车棚。它说的是一个程序员，或者一组程序员，担心的是车棚应该是什么颜色，而不是问一些重要的问题，比如车棚是否真的可以存放自行车。</p><p>当然，这个自行车棚也可以用电脑程序来代替。</p><p>在机器学习的世界里，你会听到关于R还是Python、TensorFlow还是PyTorch、书籍还是课程、数学还是code first(两者都有，记得这Trinity吧)、Spark还是Hadoop、Amazon Web Services还是谷歌云平台、VSCode还是Jupyter、Nvidia还是……的无休止的争论。</p><p>所有的比较都是有效的，但没有一个值得与对方争论。</p><p>你应该回答的真正问题是：用什么可以让我以最快、最可靠的方式建立我的想法？</p><p>一旦你问自己这个问题，你会发现其他人都在问自己同样的问题。</p><p>工程师的诅咒是从工具开始，然后寻找问题，而不是从问题开始，然后寻找工具，只有到了那个时候，如果没有合适的工具，才应该去构建它。</p><p>学习资源也是如此。数学、代码和数据的Trinity，在你学习它的时候就是不变的，唯一重要的是你如何使用它。</p><p>不要忘记：许多问题可以在没有机器学习的情况下解决。</p><h3 id="想法就是生意">想法就是生意</h3><p>不要把一个执行好想法的人与窃取你想法的人混为一谈。你的想法在别人手中比在你的头脑中更有价值。</p><p>作为一名工程师，你的角色不仅是建立自己的想法，而且还要与他人沟通，向他们展示如何从这些想法中获益。如果你缺乏这样的沟通能力，你应该与有这种能力的人合作，或者寻求培养这种能力。</p><p>在一个没人知道该相信什么的世界里，你可以通过做真实的自己来区分自己。诚实面对你做的东西所能提供的和你所不知道的。能够承认自己的无知是一种优势，而不是弱点。</p><p>好的技术总是胜利的，撒谎永远不会胜利。构建技术。不要撒谎。</p><h3 id="你的邻居、同事、同学和伙伴也在思考这个问题">你的邻居、同事、同学和伙伴也在思考这个问题</h3><p>你看到别人的进步而嫉妒吗？或者你把它看作是你能做到的事情的动力？</p><p>你对别人的成功的感觉就是你自己成功时候的感觉。</p><h3 id="不能贪">不能贪</h3><p>你应该寻求建立你运用Trinity的技能，回答那些你想要提供服务的人的问题，但你不应该带着欲望这样做。欲望会诅咒你，让你永远过于严肃地看待未来，而不是享受你现在所拥有的。</p><p>对提高技能的渴望的治疗方法是培养对学习的热爱。</p><p>自学成才的机器学习工程师能够很快地学习利用数学、代码和数据力量所需的概念，但不能匆忙行事。他们明白学习任何有价值的技术都需要时间，如果是这样的话，还不如享受这个过程。</p><p>从一开始，你就是对自己的启蒙和教育负责的人。知道了这一点，你就应该选择那些无论你有什么样的运气都能成功的项目。这个项目是否满足了你的好奇心？它是否对你的技能构成挑战？它可以让你遵守这些戒律吗？如果是这样，就足够了。</p><p>最后，在沿着自己的道路行进的同时，自学成才的机器学习工程师在他们的脑海中一直保持着这样的印象：</p><ul><li>No certifications without knowledge.</li><li>No (over)thinking without doing.</li><li>No learning without enjoyment.</li><li>No creations without style.</li><li>No skill without practice.</li><li>No tools without purpose.</li><li>No showboating without shipping.</li><li>No assumptions without scepticism.</li><li>No consumption without contribution.</li><li>No desire for the future without love for the present.</li></ul><p>最重要的是，<strong>No machine learning without the trinity</strong>。</p><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://danielbourke.substack.com/p/the-10-commandments-of-self-taught" target="_blank" rel="noopener">The 10 Commandments of Self-Taught Machine Learning Engineers</a></p>]]></content>
    
    <summary type="html">
    
      Principles for using math, code and data to seduce Mother Nature into revealing her secrets.
    
    </summary>
    
    
      <category term="MachineLearning" scheme="https://neo1989.net/categories/MachineLearning/"/>
    
    
      <category term="DAE" scheme="https://neo1989.net/tags/DAE/"/>
    
      <category term="ML" scheme="https://neo1989.net/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>Machine Learning Project Checklist</title>
    <link href="https://neo1989.net/MachineLearning/ML-machine-learning-project-checklist/"/>
    <id>https://neo1989.net/MachineLearning/ML-machine-learning-project-checklist/</id>
    <published>2020-10-29T08:04:32.000Z</published>
    <updated>2021-02-01T15:13:56.862Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Obviously, you should feel free to adapt this checklist to you needs.</p></blockquote><h2 id="Gists-摘要">Gists 摘要</h2><hr><h3 id="Frame-the-Problem-and-Look-at-the-Big-Picture-架构问题，关注蓝图">Frame the Problem and Look at the Big Picture (架构问题，关注蓝图)</h3><ul><li>Define the objective in business terms.</li><li>How will your solutiion be used?</li><li>What are the current solutions/workarounds (if any)?</li><li>How should you frame this problem (supervised/unsupervised, online/offline, etc.)?</li><li>How should performance be measured?</li><li>Is the performance measure aligned with the business objective?</li><li>What would be the minimun performance needed to reach the business objective?</li><li>What are comparable problems? Can you reuse experience or tools?</li><li>Is human expertise available?</li><li>How would you solve the problem manually?</li><li>List the assumptions you (or others) have made so far.</li><li>Verify assumptions if possible.</li></ul><h3 id="Get-the-Data-获取数据">Get the Data (获取数据)</h3><pre><code>Note: automate as much as possible so you can easily get fresh data.</code></pre><ul><li>List the data you need and how much you need.</li><li>Find and document where you can get that data.</li><li>Check how much space it will take.</li><li>Check legal obligations, and get authorization if necessary.</li><li>Get access authorizations.</li><li>Create a workspace (with enough storage space).</li><li>Get the data.</li><li>Convert the data to a format you can easily manipulate (without changing the data itself).</li><li>Ensure sensitive information is deleted or protected(e.g., anonymized).</li><li>Check the size and type of data (time series, sample, geographical, etc.).</li><li>Sample a test set , put it aside, and never look at it (no data snooping!).</li></ul><h3 id="Explore-the-Data-研究数据">Explore the Data (研究数据)</h3><pre><code>Note: try to get insights from a field expert for these steps.</code></pre><ul><li>Create a copy of the data for exploration (sampling it down to manageable size if necessary).</li><li>Create a Jupyter notebook to keep a record of your data exploration.</li><li>Study each attribute and its characteristics:<ul><li>Name</li><li>Type(categorical, int/float, bounded/unbounded, text, structured, etc.)</li><li>% of missing values</li><li>Noisiness and type of noise(stochastic, outliers, rounding errors, etc.)</li><li>Possibly useful for the tasks.</li><li>Type of distribution (Gaussian, uniform, logarithmic, etc.)</li></ul></li><li>For supervised learning tasks, identify the target attribute(s).</li><li>Visualize the data.</li><li>Study the correlations between attributes.</li><li>Study how you would solve the problem manually.</li><li>Identify the promising transformations you may want to apply.</li><li>Identify extra data that would be useful (go back to “Get the Data”).</li><li>Document what you have learned.</li></ul><h3 id="Prepare-the-Data-准备数据">Prepare the Data (准备数据)</h3><pre><code>Notes:    - Work on copies of the data (keep the original dataset intact).    - Write functins for all data transformations you apply, for five reasons:        - So you can easily prepare the data the next time you get a fresh dataset        - So you can apply these transformations in future projects        - To clean and prepare the test set         - To clean and prepare new data instances once your solution is live        - To make it easy to treat your preparation choices as hyperparameters</code></pre><ul><li>Data cleaning:<ul><li>Fix or remove outliters (optional).</li><li>Fill in missing values (e.g., with zero, mean, median…) or drop their rows (or columns).</li></ul></li><li>Feature selection (optimization):<ul><li>Drop the attributes that provide no useful information for the task.</li></ul></li><li>Feature engineering, where appropriate:<ul><li>Discretize continuous feature.</li><li>Decompose features (e.g., categorical, data/time, etc.).</li><li>Add promising transformations of features (e.g., log(x), squrt(x), x^2, etc.).</li><li>Adggregate features into promising new features.</li></ul></li><li>Feature scaling: standardize or normalize feature.</li></ul><h3 id="Short-List-Promising-Models-简要列出期望的模型">Short-List Promising Models (简要列出期望的模型)</h3><pre><code>  Notes:    - If the data is huge, you may want to sample smaller training sets so you can train many different models in a reasonable time (be aware that this penalizes complex models such as large neural nets or Random Forests).    - Once again, try to automate these steps as much as possible.</code></pre><ul><li>Train many quick and dirty models from different categories (e.g., linear, naive Bayes, SVM, Random Forests, neural net, etc.) useing standard parameters.</li><li>Measure and compare their performance.<ul><li>For each model, use N-fold cross-validation and compute the mean and standard deviation of the performance measure on the N folds.</li></ul></li><li>Analyze the most significant variables for each algorithm.</li><li>Analyze the types of errors the models make.<ul><li>What data would a human have used to avoid these errors?</li></ul></li><li>Have a quick round of feature selection and engineering.</li><li>Have one or two more quick iterations of the five previous steps.</li><li>Short-list the top three to five most promising models, preferring models that make different types of errors.</li></ul><h3 id="Fine-Tune-the-System-微调系统">Fine-Tune the System (微调系统)</h3><pre><code>Notes:    - You will want to use as much data as possible for this step, especially as you move thoward the end of fine-tuning.    - As always automate what you can.</code></pre><ul><li>Fine-tune the hyperparameters using cross-validation:<ul><li>Treat your data transformation choices as hyperparameters, especially when you are not sure about them (e.g., should I replace missing values with zero or with the median value? Or just drop the rows?).</li><li>Unless there are very few hyperparameter values to explore, prefer random search over grid search, If training is very long, you many prefer a Bayesian optimization approach (e.g., using Gaussian process priors, as described by Jasper Snoek, Hugo Larochelle, and Ryan Adams (<a href="https://goo.gl/PEFfGr" target="_blank" rel="noopener">https://goo.gl/PEFfGr</a>)).</li></ul></li><li>Try Ensemble methods. Combining your best models will often perform better than running them individually.</li><li>Once you are confident about your final model, measure its performance on the test set to estimate the generalization error.</li></ul><h3 id="Present-Your-Solution-展示解决方案">Present Your Solution (展示解决方案)</h3><ul><li>Document what you have done.</li><li>Create a nice presentation.<ul><li>Make sure you highlight the big picture first.</li></ul></li><li>Explain why your solution achieves the business objective.</li><li>Don’t forget to present interesting points you noticed along the way.<ul><li>Describe what worked and what did not.</li><li>List your assumptions and your system’s limitations.</li></ul></li><li>Ensure ypur key findings are communicated through beautiful visualizations or easy-to-remember statements (e.g., “the median income is the number-one predictor of housing prices”)</li></ul><h3 id="Lanch-启动">Lanch! (启动)</h3><ul><li>Get your solution ready for production (plug into production data inputs, write unit tests, etc.).</li><li>Write monitoring code to check your system’s live performance at regular intervals and trigger alerts when it drops.<ul><li>Beware of slow degradation too: models tend to “rot” as data evolves.</li><li>Measuring performance may require a human pipeline (e.g., via a crowdsourcing service).</li><li>Also monitor your inputs’ quality (e.g., a malfuctioning sensor sending random values, or another teams’ output becoming stale). This is particularly important for online learning systems.</li></ul></li><li>Retrain your models on a regular basis on fresh data (automate as much as possible).</li></ul><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://www.amazon.cn/dp/B07GSVW63X" target="_blank" rel="noopener">Hands-On Machine Learning with Scikit-Learn and TensorFlow</a></p>]]></content>
    
    <summary type="html">
    
      Guide you through your Machine Learning Projects.
    
    </summary>
    
    
      <category term="MachineLearning" scheme="https://neo1989.net/categories/MachineLearning/"/>
    
    
      <category term="DAE" scheme="https://neo1989.net/tags/DAE/"/>
    
      <category term="ML" scheme="https://neo1989.net/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>MachineLearning 的“最佳实践”</title>
    <link href="https://neo1989.net/MachineLearning/ML-a-few-useful-things-to-Know-about-machine-Learning/"/>
    <id>https://neo1989.net/MachineLearning/ML-a-few-useful-things-to-Know-about-machine-Learning/</id>
    <published>2020-09-14T02:48:21.000Z</published>
    <updated>2021-01-30T07:16:37.800Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Machine learning algorithms can figure out how to perform important tasks by generalizing from examples. This is often feasible and cost-effective where manual programming is not. As more data becomes available, more ambitious problems can be tackled.<br>Machine learning is widely used in computer science and other fields. However, developing successful machine learning applications requires a substantial amount of “black art” that is difficult to find in textbooks.<br>This article summarizes 12 key lessons that machine learning researchers and practitioners have learned. These include pitfalls to avoid, important issues to focus on, and answers to common questions.</p></blockquote><h2 id="Gists-摘要">Gists 摘要</h2><ul><li><p><strong>Learning = Representation (表征) + Evaluation (评估) + optimization (优化)</strong></p><table><thead><tr><th style="text-align:left">Representation</th><th style="text-align:left">Evaluation</th><th style="text-align:left">Optimization</th></tr></thead><tbody><tr><td style="text-align:left">Instances</td><td style="text-align:left">Accuracy/Error rate</td><td style="text-align:left">Combinatorial optimization</td></tr><tr><td style="text-align:left">  K-nearest neighbor</td><td style="text-align:left">Precision and recall (精准率&amp;召回率)</td><td style="text-align:left">  Greedy search (贪心搜索)</td></tr><tr><td style="text-align:left">  Support vector machines</td><td style="text-align:left">Squared error (平方误差)</td><td style="text-align:left">  Beam search (集束搜索)</td></tr><tr><td style="text-align:left">Hyperplanes</td><td style="text-align:left">Likelihood (似然)</td><td style="text-align:left">Branch-and-bound (分支界限法)</td></tr><tr><td style="text-align:left">  Naive Bayes</td><td style="text-align:left">Posterior probability (后验概率)</td><td style="text-align:left">Continuous optimization</td></tr><tr><td style="text-align:left">  Logistic regression</td><td style="text-align:left">Information gain (信息增益)</td><td style="text-align:left">  Unconstrained</td></tr><tr><td style="text-align:left">Decision trees</td><td style="text-align:left">K-L divergence (相对熵)</td><td style="text-align:left">    Gradient descent (梯度下降)</td></tr><tr><td style="text-align:left">Sets of rules</td><td style="text-align:left">Cost/Utility</td><td style="text-align:left">    Conjugate gradient (共轭梯度)</td></tr><tr><td style="text-align:left">  Propositional rules</td><td style="text-align:left">Margin</td><td style="text-align:left">Quasi-Newton methods (拟牛顿法)</td></tr><tr><td style="text-align:left">  Logic programs</td><td style="text-align:left"></td><td style="text-align:left">Constrained</td></tr><tr><td style="text-align:left">Neural networks</td><td style="text-align:left"></td><td style="text-align:left">  Linear programming (线性规划)</td></tr><tr><td style="text-align:left">Graphical models</td><td style="text-align:left"></td><td style="text-align:left">  Quadratic programming (二次规划)</td></tr><tr><td style="text-align:left">  Bayesian networks (贝叶斯网络)</td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">  Conditional random fields (条件随机场)</td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table></li><li><p><strong>It’s Generalization that counts (泛化能力是ML的核心)</strong><br>机器学习的基本目标是对训练集之外的样本进行泛化。</p></li><li><p><strong>Data alone is not enough</strong> (仅有数据是不够的)<br>先验知识</p></li><li><p><strong>Overfitting has many faces</strong> (过拟合具有多面性)</p><ul><li><p>理解过拟合的一种方法是将泛化的误差进行分解，分为偏差和方差。</p><ul><li>bias可以理解是预测或估计很多次的均值</li><li>variance表示很多次估计的方差</li><li>线性模型一般variance小，bias大</li><li>树模型一般variance大，bias小<br><img src="http://s3.mindex.xyz/blog/coder/027856ac555b11205f8cd408d43468c7.png" alt="Bias and variance in dart-throwing"></li></ul></li><li><p>下面几个思路可能减小过拟合</p><ul><li>交叉验证</li><li>加入正则项，避免模型过于复杂</li></ul></li><li><p>没有噪声也会出现过拟合</p></li></ul></li><li><p><strong>Intuition Fails in high Dimensions (直觉不适用于高纬度空间)</strong></p><ul><li>维数灾难</li><li>降维 (缺失值比率, 低方差滤波, 高相关滤波, 随机森林,  PCA, t-SNE, UMAP…)</li></ul></li><li><p><strong>Theoretical Guarantees are not What they seem (理论保证不一定可靠)</strong></p></li><li><p><strong>Feature engineering is the Key</strong><br>特征决定机器学习的上限，模型只是在逼近这个上限。</p></li><li><p><strong>More Data Beats a cleverer algorithm</strong><br>收集更多的数据、处理更多的数据</p></li><li><p><strong>Learn many models, not Just one</strong><br>bagging, boosting, stacking</p></li><li><p><strong>Simplicity Does not imply Accuracy (简单并不意味着准确)</strong></p></li><li><p><strong>Representable Does not imply Learnable (可表示并不意味着可学习)</strong></p></li><li><p><strong>Correlation Does not imply Causation (相关并不意味着因果)</strong></p></li></ul><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://homes.cs.washington.edu/~pedrod/papers/cacm12.pdf" target="_blank" rel="noopener">A Few Useful Things to Know About Machine Learning</a><br>[2] <a href="https://www.jiqizhixin.com/articles/Pedro-Domingos-12-useful-things-to-know-about-machine-learning" target="_blank" rel="noopener">Pedro Domingos总结机器学习研究的12个宝贵经验</a></p>]]></content>
    
    <summary type="html">
    
      folk knowledge
    
    </summary>
    
    
      <category term="MachineLearning" scheme="https://neo1989.net/categories/MachineLearning/"/>
    
    
      <category term="DAE" scheme="https://neo1989.net/tags/DAE/"/>
    
      <category term="ML" scheme="https://neo1989.net/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>Git Commit Message Conventions</title>
    <link href="https://neo1989.net/CheatSheet/CHEATSHEET-git-commit/"/>
    <id>https://neo1989.net/CheatSheet/CHEATSHEET-git-commit/</id>
    <published>2020-08-14T09:49:57.000Z</published>
    <updated>2020-09-14T02:43:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="格式">格式</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">type</span>&gt;</span>(<span class="tag">&lt;<span class="name">scope</span>&gt;</span>): <span class="tag">&lt;<span class="name">subject</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="type-必须">type (必须)</h3><ul><li>feat: 新功能, feature</li><li>fix: bugfix</li><li>docs: 文档</li><li>style: 代码格式化</li><li>refacotr: 重构</li><li>perf: 优化</li><li>test: 增加测试</li><li>chore: 维护</li><li>revert: 回滚</li><li>merge: 代码合并</li><li>sync: 同步主线或者分支</li></ul><h3 id="scope-可选">scope (可选)</h3><p>scope用于说明 commit 影响的范围</p><h3 id="subject-必须">subject (必须)</h3><p>subject是 commit 目的的简短描述</p><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y" target="_blank" rel="noopener">AngularJS Git Commit Message Conventions</a></p>]]></content>
    
    <summary type="html">
    
      Rules are rules.
    
    </summary>
    
    
      <category term="CheatSheet" scheme="https://neo1989.net/categories/CheatSheet/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
  </entry>
  
  <entry>
    <title>《精确表达》</title>
    <link href="https://neo1989.net/ReadingNotes/NOTE-precise-presentation/"/>
    <id>https://neo1989.net/ReadingNotes/NOTE-precise-presentation/</id>
    <published>2020-08-10T05:34:28.000Z</published>
    <updated>2021-01-26T15:46:26.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gists-摘要">Gists 摘要</h2><h3 id="何为逻辑">何为逻辑</h3><ul><li>为了让与我们背景不同的人们听懂我们的表达，有必要在讲话时注意逻辑。</li><li>所谓逻辑，是指把语言合理地组织气力啊。</li><li>要想把语言合理地组织到一起，只有 <em>纵向逻辑</em> 和 <em>横向逻辑</em> 两种组织方法。</li><li>当对方感到不理解时，无非有两种反应：“真的是这样吗” 和 “仅仅如此吗”。</li><li>当对方质疑“真的是这样吗”的时候，说明我们的纵向逻辑比较薄弱，也就是说，未能恰当的说明因果关系。</li><li>当对方质疑“仅仅如此吗”的时候，说明我们的横向逻辑比较薄弱，也就是说出现了遗落或者重复。</li><li>逻辑合理与否是由对方判断的，不要过于相信自己的逻辑。</li></ul><h4 id="建立纵向逻辑">建立纵向逻辑</h4><ul><li>所谓纵向逻辑，是指“因为A，所以B”，即该逻辑达到了“任何人都认同的状态”。</li><li>当对方质疑真假时，说明我们的纵向逻辑存在不合理的地方。</li><li>导致纵向逻辑薄弱的三个主要原因<ul><li>想当然地认为对方能够立即自己脑海里的隐性前提，没有吧所有的前提条件罗列出来。</li><li>把性质不同的东西混为一谈。</li><li>把偶然事件视为必然事件。</li></ul></li><li>只要解决上述三个因素，就不会再有人质疑“真的是这样吗”。</li></ul><h4 id="建立横向逻辑">建立横向逻辑</h4><ul><li>合理的横向逻辑是指合理定义整体，没有遗漏和重复。</li><li>由于现实世界相当复杂，人们对事务的看法各有不同，所以首先应该注意说话者与听话者的“语言的层次感”是否一致。</li><li>为把说话者与听话者的语言层次归到同一平面，应该考虑如下两点<ul><li>确认对方是以何种身份立场思考问题的。</li><li>确认对方设想的是何种场景。</li></ul></li><li>当我们把语言层次归到同一平面后，我们必须给“整体”下一个合适的定义。倘若未能正确定义“整体”，再怎么努力避免遗漏也是白费功夫。</li><li>利用已有的知名框架来把握整体无疑是个轻松省事的好办法，但应做到具体情况具体分析。<ul><li><a href="https://wiki.mbalib.com/wiki/5P%E8%90%A5%E9%94%80%E7%90%86%E8%AE%BA" target="_blank" rel="noopener">5P营销理论</a></li><li><a href="https://wiki.mbalib.com/wiki/3C%E6%88%98%E7%95%A5%E4%B8%89%E8%A7%92%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">3C战略三角模型</a></li><li><a href="https://wiki.mbalib.com/wiki/%E9%BA%A6%E8%82%AF%E9%94%A17S%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">麦肯锡7S模型</a></li><li><a href="https://wiki.mbalib.com/wiki/SWOT%E5%88%86%E6%9E%90%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">SWOT分析模型</a></li><li><a href="https://wiki.mbalib.com/wiki/AIDAS%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">AIDAS原理</a></li><li><a href="https://wiki.mbalib.com/wiki/PDCA%E5%BE%AA%E7%8E%AF" target="_blank" rel="noopener">PDCA循环</a></li></ul></li><li>在勾勒崭新的框架时，我们应发挥六度思维的想象力。<ul><li>眼前可看见的三维世界。</li><li>看不见的三维世界。</li></ul></li><li>避免遗漏之后，最后剩下的工序是消除重复。如果是复杂的概念，可以利用“MECE模型”进行查重。<br><img src="http://s3.mindex.xyz/blog/cure/f92ba84e968434964e09ce899fb331ea.png" alt="MECE模型"><ul><li>为了判断是否存在重复，“MECE模型”把两个命题分别排列在纵轴和横轴。纵轴和横轴又分别简单地划分为“是”和“否”两栏。</li></ul></li><li>一旦制作出完美的横向逻辑，肯定不会再有人质疑“仅仅如此吗”。</li><li>金字塔结构堪称逻辑思考的集大成者，然而它的构建绝非一蹴而就。</li><li>逻辑思考能力是假说验证能力、问题解决能力等所有能力的基础，也是最为重要的技能。</li></ul><h3 id="何为假说验证能力">何为假说验证能力</h3><ul><li>就算逻辑正确，对方也不见得会表示赞同。</li><li>回应对方质疑时需要验证假说型思考。</li><li>假说验证型思考必须经历如下五个步骤<ul><li>理解目的</li><li>把握论点</li><li>构建假说</li><li>实施验证</li><li>提取启发</li></ul></li></ul><h4 id="理解目的">理解目的</h4><ul><li>“理解交流的目的”包括两个要点，即：对“讨论的立场”进行确认；理解“对方的要求”。</li><li>讨论的立场不同，沟通方法就不同，沟通方法包括“逼迫型”和“引导型”这两种。</li><li>商务交流中往往需要采用“逼迫型”沟通法，要求对方对某事做出某项判断。</li><li>当你需要对方对某事做出某项判断时，请在提交方案时把具体要求作为结束语。</li><li>要做到理解对方的要求，必须学会倾听。</li><li>要想提高提案能力，不仅应该强化逻辑思考能力，还应该注重感性思维，时刻关注对方的心理。</li></ul><h4 id="把握论点">把握论点</h4><ul><li>论点就是影响到对方最终判断结果的判断项目。</li><li>偏离论点的情况无外乎四种类型。<ul><li>没能明确讲话的立场。</li><li>错误理解对方的要求。</li><li>未能找出对方所需判断的具体项目。</li><li>重复对方早已知晓的答案。</li></ul></li><li>避免讨论偏离的具体对策。<ul><li>明确立场。</li><li>正确理解目的。</li><li>磨炼构建横向逻辑的能力。</li><li>了解对方的知识及经验水平。</li></ul></li><li>当自己的论点与对方不一致时，应找出原因，并采取相应的措施。</li></ul><h4 id="构建假说">构建假说</h4><ul><li>假说是指针对论点做出的假设性回答。</li><li>理解假说需要注意如下三点。<ul><li>假说归根结底是指针对论点做出的假设性回答。没有论点就没有假说。</li><li>假说不是没有根据的瞎猜，是根据有限的信息做出的假设性回答。</li><li>由于假说缺乏客观事实根据，因此和答案不同。</li></ul></li><li>之所以需要假说，是因为它能缩小选项范围、提高讨论效率。</li><li>为了不让对方费脑子思考，构建假说相当重要。</li><li>构建假说需要以某些信息作为依据。假说不可能凭空出现。</li><li>在工作过程中，我们到底在构建假说，还是在验证假说？我们时常要思考这点。</li><li>构建假说需要经历三个步骤：牢记论点；时刻想着答案是什么；广泛阅读大量信息。</li><li>只要熟练掌握 <em>横向逻辑</em> 和 <em>纵向逻辑</em> ，就能扩大假说范围，提高假说的准确度。</li></ul><h4 id="实施验证">实施验证</h4><ul><li>验证是指用客观事实和逻辑来证明假说正确与否的过程。</li><li>“没有论点的假说” 和 “没有假说的验证” 都毫无意义。</li><li>验证没有明确的尽头，又是辛苦调查分析之后却只能推断出看似理所当然的答案。</li><li>尽管验证很难，但一旦成功进行了验证，就能中止争论、推进课题。</li><li>验证结果当中有80%证明了理所当然的答案，20%促成了新的发现。</li><li>在验证过程中，应当有意识地添加确凿的事实根据。</li><li>最具说服力的信息应当是 “定量、一手、第三方” 三剑合一。</li></ul><h4 id="提取启发">提取启发</h4><ul><li>所谓启发，就是“有益于把握论点核心的信息”。</li><li>启发既不是假说验证后得出的“答案”，也不是“随意的主张”。</li><li>虽然我们很少能取得完美的“答案”，但是只要我们能获得一些“启发”，就能推动事情的进展。</li><li>提取启发需注意如下三点<ul><li>正确理解目的和论点。</li><li>把握论点的核心。</li><li>不要设计无法验证的方案。</li></ul></li></ul><h3 id="何为会议设计">何为会议设计</h3><ul><li>会议之所以无聊，是因为没能“设计”好会议。</li><li>如下四种原因导致人们无法设计出气氛热烈的会议。<ul><li>缺乏“自己正在开会”的意识。</li><li>虽然准备了会议的“议题”，却没有准备会议的“论点”。</li><li>把“整体方案” 和 “本次方案”混为一谈。</li><li>未能顺着对方的逻辑解说。</li></ul></li><li>设计会议时应注意两个要素，即 “着陆点” 和 “着陆形式” 。</li><li>会议设计极大影响了方案的结构。</li></ul><h4 id="确定着陆点">确定着陆点</h4><ul><li>高清会议的“定位” 与 “输入/输出”, 有利于顺利找到会议的着陆点。</li><li>三种视角决定了会议的定位<ul><li>验证假说的视角。</li><li>沟通的视角。</li><li>解决问题的视角。</li></ul></li><li>如果我们无视会议的具体定位，即使拖拖拉拉地展开漫长的讨论，也不会总结出什么有效的内容。</li><li>搞错会议定位有时会造成严重的后果，我们的方案非但无法继续推进，反而会被要求重做。</li><li>充分意识到会议“输入/输出管理”的重要性。</li><li>会议的“输入/输出管理”应注意如下三点<ul><li>是否输入了“新鲜感”？</li><li>是否输入了“前进感”？</li><li>输出是否过于急躁？</li></ul></li></ul><h4 id="决定着陆形式">决定着陆形式</h4><ul><li>迎合对方的风格，顺着对方的理解方式及思考模式设计出来的方案更容易获得对方的理解。</li><li>把握对方风格的三种视角<ul><li>是 “阅读者” 还是 “倾听者”？</li><li>是 “全局纵观派” 还是 “连锁把握派”？</li><li>是 “自上而下派” 还是 “自下而上派”？</li></ul></li></ul><h3 id="何为制作商务文本的能力">何为制作商务文本的能力</h3><ul><li>把自己想表达的东西总结成书面形式需要经历五个步骤<ul><li>写成文字信息。</li><li>制作图表。</li><li>把文字信息和图表组合成幻灯片的样式。</li><li>把多张幻灯片组合成资料包，构成一个完整的“故事”。</li><li>把各种资料包组合成符合会议目的的资料群。</li></ul></li><li>使用模板制作商务文本，即用“组装零件法”来制作。</li><li>我们应当努力制作出“一目了然，不被误解”的商务文本。</li><li>制作的商务文本不要违反人类的阅读习惯。</li><li>要制作简洁易懂的商务文本，需要拥有删除三种内容的勇气。<ul><li>不必要的信息</li><li>不必要的文字</li><li>不必要的属性信息</li></ul></li><li>牢记“让对方思考就是我们的失败”，制作出一看就懂的商务文本。</li></ul><h4 id="文字信息应简洁易懂">文字信息应简洁易懂</h4><ul><li>文字信息是指我们在幻灯片上罗列的“最想传达给对方的内容”，长度大约三行。</li><li>文字信息主要包括三种内容，“说明”、“事实”、“启发”。</li><li>排列文字信息的地方有两处，开头句 和 总结句。</li><li>有内容的文字信息应具备四个要素<ul><li>目的性：是否符合目的及论点？</li><li>崭新性：是否给对方带来新的发现？</li><li>明确新：是否清楚说明了具体意思？</li><li>放心性：是否告知了对方行动方向？</li></ul></li><li>书写文字信息是的三个注意事项<ul><li>简洁表述</li><li>统一词汇</li><li><em>照顾对方的情绪</em></li></ul></li><li>简洁表述，即凝缩文字信息有四种手法<ul><li>把结论放在前面：先写结论，后写理由</li><li>删除多余的语句：删除不影响沟通的语句</li><li>避免词汇重复：同一词汇反复出现时，应进行概括总结</li><li>使用概括性词汇：长句短说，用成语、熟语进行概括</li></ul></li></ul><h4 id="把文字信息制作成图表">把文字信息制作成图表</h4><ul><li>我们应当用简单易懂的图表尽可能多地表达我们想说的内容。</li><li>可以把图表分为 “内容” 与 “排版” 这两个概念。<ul><li>内容：插图、统计图、文本三种。</li><li>排版：关联图、流程图、树状图、表格四种。</li></ul></li><li>要把图表制作的简单易懂，还需要从三个方面着手修饰<ul><li>尽量使用图形。</li><li>设计合适的标题。</li><li>在重点部分加以标识。</li></ul></li><li>明确自己所要传达的信息，在此基础上选择符合事根据的图表内容和符合逻辑的图表排版，然后组装制成图表。</li></ul><h4 id="配置幻灯片">配置幻灯片</h4><ul><li>制作幻灯片是需要注意如下两点<ul><li>幻灯片的上方必须添加文字信息。</li><li>文字信息和图表应相互呼应。</li></ul></li><li>灵活使用如下三个技巧，可以有效提高幻灯片的完成度。<ul><li>按照人类的阅读习惯，从左上方至右下方排列图表。</li><li>最大程度地利用纸张。</li><li>尽可能对齐行和列，整齐排列图表。</li></ul></li></ul><h4 id="完成资料包">完成资料包</h4><ul><li>资料包中必须包含启发。</li><li>根据对方的逻辑和使用场合来制作资料包<ul><li>自上而下纵观全体型：适合参会者理解程度较高、只需短时间重点介绍结论的会议。</li><li>自上而下连锁把握型：适合短时间内强调必要部分的会议。</li><li>自下而上纵观全体型：适合花时间慢慢解释来获得对方认同的会议。</li><li>自下而上连锁把握型：适合参会者理解能力较低，需要细细讲解的会议。</li></ul></li><li>分别采用三个切入点<ul><li>操作视点：能够清楚了解具体工作的进展情况。</li><li>项目视点：具有全局观。</li><li>论点视点：能够明确地传达信息。</li></ul></li></ul><h4 id="整合资料群">整合资料群</h4><ul><li>为了实现会议目的而把所有必要的资料包整合在一起，这就是资料群。</li><li>资料群由八个资料包构成。<ul><li>摘要：高度凝缩的天内容。</li><li>前提：会议的背景及目的。</li><li>全景：论点及验证任务的整体情况。</li><li>内容：关于本次会议议题的说明、事实以及启发。</li><li>论点清单：尤其需要强调的讨论事项。</li><li>问答卡：用于引导参会者参与讨论的答题用纸。</li><li>日程安排：日程表以及下次会议之前所需开展的行动项目。</li><li>参考数据：虽然不符合故事线，但是有可能会用到的幻灯片。</li></ul></li></ul><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://www.amazon.cn/dp/B07FYJH51B" target="_blank" rel="noopener">精准表达：让你的方案在最短的时间内打动人心</a></p>]]></content>
    
    <summary type="html">
    
      让你的方案在最短的时间内打动人心。
    
    </summary>
    
    
      <category term="ReadingNotes" scheme="https://neo1989.net/categories/ReadingNotes/"/>
    
    
      <category term="SoftSkills" scheme="https://neo1989.net/tags/SoftSkills/"/>
    
  </entry>
  
  <entry>
    <title>《Google工作法》</title>
    <link href="https://neo1989.net/ReadingNotes/NOTE-how-to-work/"/>
    <id>https://neo1989.net/ReadingNotes/NOTE-how-to-work/</id>
    <published>2020-06-08T15:10:10.000Z</published>
    <updated>2021-01-26T15:46:01.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gists-摘要">Gists 摘要</h2><ul><li><p>不依赖邮件</p><p>想办法“一次结束”<br>现将能够当场确定的事情定下来，切实地取得进展<br>思考不用邮件而让所有人一次做完的方法<br>给所有的工作都规定期限<br>将精力集中于“此时此刻”<br>选择一个能够让自己集中精神工作的环境</p></li><li><p>用集体智慧来进行思考</p><p>与逻辑分析相比“灵感”更加重要<br>灵活利用线索卡，大家一起进行思考<br>将企划会议变成大家一起思考的会议<br>积极听取其他部门和其他领域的人的意见</p></li><li><p>以10倍的速度思考</p><p>思考如何取得10倍的成果<br>为了取得10倍的成果必须要打破规则<br>为了进入下一个阶段，必须“让自己的工作消失”<br>像公司所有者那样思考</p></li><li><p>创建提高工作效率的人际关系</p><p>用“实物”说话可以使工作更有效率<br>取消多余的会议<br>与部下的交流每周一次就够了<br>在工作之外也建立起人际关系，可以使工作更有效率<br>优先与“新结识的人” “不断变化的人” “高水平的人”交流</p></li><li><p>迅速学习，向同事学习</p><p>学习 = 检索 + 询问专业人士·询问他人·询问同事<br>只有反馈远远不够，还要灵活利用“前馈”<br>预先建立一个能够轻松询问的交流关系<br>不断改变，坚持学习</p></li><li><p>简化心灵</p><p>偶尔关电脑<br>一分钟的冥想就能够改变注意力<br>在不同的时间段集中精力做一件事<br>不要尝试消灭感情，要保持中庸<br>休息也是自己的责任</p></li><li><p>破坏自己的工作</p><p>思考如何用IT代替自己工作<br>站在革新的一侧，不能袖手旁观<br>就算对技术细节不了解，也要跟上趋势<br>工作不能“和昨天一样”</p></li><li><p><strong>取得10倍成果的人的共同点</strong></p><ul><li>拥有预见性<br>预见机会与威胁<br>寻找周期、趋势以及规律<br>短期、中期和长期思考</li><li>换位思考</li><li>敢于提出自己的见解</li><li>敢于说真话</li><li>主动承担责任</li><li>积极参与交流</li><li>倾听自己内心的声音</li><li>打破常规</li><li>不害怕失败</li><li>勤于思考、保持怀疑</li><li>改变视角<br>整体视角<br>局部视角<br>反面视角<br>未来视角<br>顾客视角<br>竞争对手视角<br>特殊视角（一般情况下，更深层次的情况下，反常的情况下）</li></ul></li></ul><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://www.amazon.cn/dp/B07ZNJ49JD" target="_blank" rel="noopener">Google工作法</a></p>]]></content>
    
    <summary type="html">
    
      工作效率提升10倍。
    
    </summary>
    
    
      <category term="ReadingNotes" scheme="https://neo1989.net/categories/ReadingNotes/"/>
    
    
      <category term="SoftSkills" scheme="https://neo1989.net/tags/SoftSkills/"/>
    
  </entry>
  
  <entry>
    <title>《科学学习》</title>
    <link href="https://neo1989.net/ReadingNotes/NOTE-how-we-learn/"/>
    <id>https://neo1989.net/ReadingNotes/NOTE-how-we-learn/</id>
    <published>2020-02-26T07:50:03.000Z</published>
    <updated>2021-01-26T15:46:08.286Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gists-摘要">Gists 摘要</h2><ul><li><p><span id="A"><strong>A</strong>nalogy 归纳类比</span><br>从两个或两个以上、外表看似迥异的例子之间找到共通的规律。</p></li><li><p><span id="B"><strong>B</strong>elonging 归属感</span><br>归属感让学习者更加投入，减少对行为是否得当、自己是否合群等问题的困扰。</p></li><li><p><span id="C"><strong>C</strong>ontrasting Cases 对比组合</span><br>通过对比两个或多个看似相同的例子来找到其中的细微差别。</p></li><li><p><span id="D"><strong>D</strong>eliberate Practice 精修勤练</span><br>针对某个具体的技能或概念进行专注而努力的练习，从而超越自身的现有水平。</p></li><li><p><span id="E"><strong>E</strong>laboration 详细阐释</span><br>详细阐释的过程就是在新信息与已知事物之间建立明确的关系。详细阐释过的内容在过了一段时间后也更容易被回忆起来。</p></li><li><p><span id="F"><strong>F</strong>eedback 反馈</span><br>反馈让人们感受到实际结果与理想目标之间的差异，从而帮助调整下一步行动。</p></li><li><p><span id="G"><strong>G</strong>eneration 自我生成</span><br>将来需要回忆什么，现在就练习回忆什么：利用一部分线索作为提示来生成目标记忆，这种训练可以提升记忆效果，使日后回忆起目标内容变得更加容易。</p></li><li><p><span id="H"><strong>H</strong>ands On 实践体验</span><br>通过运动感知活动来理解抽象的概念。</p></li><li><p><span id="I"><strong>I</strong>maginative Play 现象玩耍</span><br>想象玩耍是创造与真实世界不一样的故事世界。在充满乐趣的扮演过程中，人们以物喻物，用一种事物代表另一种事物。</p></li><li><p><span id="J"><strong>J</strong>ust-in-Time Telling 适时讲解</span><br>让学习者先体验问题，再学习知识或提供解决方案。</p></li><li><p><span id="K"><strong>K</strong>nowledge 知识与创新</span><br>培养并运用高效率的知识来解决重复性问题；培养为适应全新环境而创造新知识的能力。<br>创新与效率目的合二为一。<br>在学习初期应当着重强调创新的机会，而学习后期则应当专注于效率的提升。</p></li><li><p><span id="L"><strong>L</strong>istening and Sharing 倾听与共享</span><br>倾听和共享是协作学习的基石。协作过程中，学习者们一起完成任务、解决问题、共同学习。</p></li><li><p><span id="M"><strong>M</strong>aking 动手创造</span><br>创造作品或是完成任务，然后接受反馈意见并设定新目标。</p></li><li><p><span id="N"><strong>N</strong>orms 规范</span><br>社会规范是指导人们社交行为的非正式规则。社交行为可以决定人们学习的内容与方式。</p></li><li><p><span id="O"><strong>O</strong>bervation 观察</span><br>通过观察来进行学习的过程涉及观看并模仿他人的行为与情绪反应，以及间接看到他人行为所带来的结果。</p></li><li><p><span id="P"><strong>P</strong>articipation 参与</span><br>通过参与社交情境中的实践活动，学习者可以切身感受到学习目标、结果、方法，以及学习的意义。其首要挑战在于如何找到合适的方式，帮助初学者迈出第一步。</p></li><li><p><span id="Q"><strong>Q</strong>uestion Driven 问题驱动</span><br>通过回答提出的问题来开展学习可以激发好奇心、增强学习的目的、集中学习注意力、让知识融会贯通，还有可能提高学习者解决问题的能力。</p></li><li><p><span id="R"><strong>R</strong>eward 奖励</span><br>奖励某种行为会促使人们重复该行为。人们在学习新行为的过程中，可以借助持续的奖励来提供源源不断的动力，直到他们成功完成目标行为。</p></li><li><p><span id="S"><strong>S</strong>elf-Explanation 自我解读</span><br>通过把学习内容给自己讲解一遍的过程来加深理解。</p></li><li><p><span id="T"><strong>T</strong>eaching 以教促学</span><br>教学的过程能够提升老师自身对知识的理解，边教边学、以教促学。</p></li><li><p><span id="U"><strong>U</strong>ndoing 纠正错误</span><br>识别并取代错误的认知观念与思考方式。</p></li><li><p><span id="V"><strong>V</strong>isualization 可视化</span><br>将信息的结构关系用视觉的方式表达出来，可以帮助我们整理信息与想法。具体形式包括，地图、图表、草图、图像、文氏图、树状图、矩阵图，等等。</p></li><li><p><span id="W"><strong>W</strong>orked Examples 参考样例</span><br>参考样例是将步骤型的任务一步步示范出来，供学习者参考的方法。</p></li><li><p><span id="X">e<strong>X</strong>citement 激动兴奋</span><br>激动能够促进生理兴奋，从而帮助集中注意力并提升记忆效果。</p></li><li><p><span id="Y"><strong>Y</strong>es I Can 我能行</span><br>帮助学习者相信他们自己拥有成功的能力，从而勇敢面对挑战、坚持得更持久，并在失败面前更加坚韧不拔，愿意主动迎接更多挑战，直到实现更大的成就。</p></li><li><p><span id="Z"><strong>Z</strong>zz 睡上一觉</span><br>睡眠能够帮助人们把短期记忆固化为长期记忆，并将学习内容与自身知识融为一体。</p></li></ul><h2 id="Indexes-问题索引">Indexes 问题索引</h2><table><thead><tr><th style="text-align:center">Q</th><th style="text-align:center">As</th></tr></thead><tbody><tr><td style="text-align:center">回避具有挑战性的事情</td><td style="text-align:center"><a href="#B">B</a> <a href="#R">R</a> <a href="#Y">Y</a></td></tr><tr><td style="text-align:center">学习习惯不好</td><td style="text-align:center"><a href="#N">N</a></td></tr><tr><td style="text-align:center">群体中存在对某一类人群的偏见</td><td style="text-align:center"><a href="#B">B</a> <a href="#N">N</a> <a href="#L">L</a> <a href="#P">P</a></td></tr><tr><td style="text-align:center">遇到困难总是埋怨别人</td><td style="text-align:center"><a href="#Y">Y</a></td></tr><tr><td style="text-align:center">演讲或讲座让人昏昏欲睡</td><td style="text-align:center"><a href="#J">J</a> <a href="#X">X</a></td></tr><tr><td style="text-align:center">团队讨论让人觉得无聊, 容易走神</td><td style="text-align:center"><a href="#L">L</a> <a href="#Q">Q</a></td></tr><tr><td style="text-align:center">团队意见不一</td><td style="text-align:center"><a href="#L">L</a> <a href="#N">N</a></td></tr><tr><td style="text-align:center">对学习内容的理解出现差错</td><td style="text-align:center"><a href="#S">S</a> <a href="#U">U</a></td></tr><tr><td style="text-align:center">概念出现混淆</td><td style="text-align:center"><a href="#C">C</a></td></tr><tr><td style="text-align:center">只会被动接受知识，不会主动学习</td><td style="text-align:center"><a href="#I">I</a> <a href="#M">M</a> <a href="#Q">Q</a></td></tr><tr><td style="text-align:center">需要纠正具体做法中的错误</td><td style="text-align:center"><a href="#F">F</a> <a href="#R">R</a></td></tr><tr><td style="text-align:center">需要端正学习行为</td><td style="text-align:center"><a href="#N">N</a> <a href="#P">P</a></td></tr><tr><td style="text-align:center">需要纠正思维上的错误</td><td style="text-align:center"><a href="#F">F</a> <a href="#F">U</a></td></tr><tr><td style="text-align:center">难以着手，不知如何开始学习</td><td style="text-align:center"><a href="#O">O</a> <a href="#P">P</a> <a href="#R">R</a> <a href="#W">W</a></td></tr><tr><td style="text-align:center">理解抽象概念是遇到困难</td><td style="text-align:center"><a href="#A">A</a> <a href="#C">C</a> <a href="#H">H</a></td></tr><tr><td style="text-align:center">团队合作时遇到困难</td><td style="text-align:center"><a href="#L">L</a> <a href="#N">N</a></td></tr><tr><td style="text-align:center">看不出事物或概念之间的内在联系</td><td style="text-align:center"><a href="#J">J</a> <a href="#M">M</a> <a href="#Q">Q</a></td></tr><tr><td style="text-align:center">不把学习当回事</td><td style="text-align:center"><a href="#M">M</a> <a href="#T">T</a> <a href="#U">U</a></td></tr><tr><td style="text-align:center">不知道何时应用所学内容</td><td style="text-align:center"><a href="#A">A</a> <a href="#C">C</a> <a href="#J">J</a> <a href="#Q">Q</a></td></tr><tr><td style="text-align:center">不善于在思维中建立知识点间的联系</td><td style="text-align:center"><a href="#E">E</a> <a href="#S">S</a> <a href="#T">T</a></td></tr><tr><td style="text-align:center">不善于监控自己的学习进程</td><td style="text-align:center"><a href="#F">F</a> <a href="#S">S</a> <a href="#T">T</a></td></tr><tr><td style="text-align:center">觉得自己无法融入集体中</td><td style="text-align:center"><a href="#B">B</a> <a href="#N">N</a></td></tr><tr><td style="text-align:center">记不住学过的内容</td><td style="text-align:center"><a href="#E">E</a> <a href="#G">G</a> <a href="#Z">Z</a></td></tr><tr><td style="text-align:center">在团队中浑水摸鱼</td><td style="text-align:center"><a href="#L">L</a> <a href="#N">N</a> <a href="#T">T</a></td></tr><tr><td style="text-align:center">面对挑战过早放弃</td><td style="text-align:center"><a href="#Y">Y</a></td></tr><tr><td style="text-align:center">难以激励学习行为</td><td style="text-align:center"><a href="#N">N</a> <a href="#R">R</a> <a href="#P">P</a></td></tr><tr><td style="text-align:center">提升技能水平是遇到瓶颈</td><td style="text-align:center"><a href="#D">D</a> <a href="#F">F</a></td></tr><tr><td style="text-align:center">不重视反馈</td><td style="text-align:center"><a href="#F">F</a> <a href="#R">R</a> <a href="#T">T</a></td></tr><tr><td style="text-align:center">理解不够精确，不够严谨</td><td style="text-align:center"><a href="#C">C</a> <a href="#E">E</a> <a href="#J">J</a> <a href="#V">V</a></td></tr><tr><td style="text-align:center">遇事缺乏思考，冲动行事</td><td style="text-align:center"><a href="#I">I</a> <a href="#R">R</a></td></tr><tr><td style="text-align:center">注意力难以集中</td><td style="text-align:center"><a href="#X">X</a></td></tr><tr><td style="text-align:center">问题问不到点上</td><td style="text-align:center"><a href="#F">F</a> <a href="#O">O</a> <a href="#Q">Q</a></td></tr><tr><td style="text-align:center">教学过程低效</td><td style="text-align:center"><a href="#K">K</a> <a href="#J">J</a> <a href="#W">W</a></td></tr><tr><td style="text-align:center">缺乏独立思考</td><td style="text-align:center"><a href="#I">I</a> <a href="#K">K</a> <a href="#M">M</a></td></tr><tr><td style="text-align:center">缺乏真知灼见，创意枯竭</td><td style="text-align:center"><a href="#V">V</a> <a href="#Z">Z</a> <a href="#I">I</a> <a href="#K">K</a></td></tr><tr><td style="text-align:center">对学习提不起兴趣</td><td style="text-align:center"><a href="#M">M</a> <a href="#P">P</a> <a href="#R">R</a> <a href="#T">T</a></td></tr><tr><td style="text-align:center">讲解的内容发挥不了作用</td><td style="text-align:center"><a href="#J">J</a> <a href="#X">X</a> <a href="#C">C</a></td></tr><tr><td style="text-align:center">在集体中感到孤独</td><td style="text-align:center"><a href="#B">B</a> <a href="#P">P</a></td></tr><tr><td style="text-align:center">学习时总是习惯看答案</td><td style="text-align:center"><a href="#G">G</a> <a href="#J">J</a></td></tr><tr><td style="text-align:center">自信不足</td><td style="text-align:center"><a href="#B">B</a> <a href="#Y">Y</a></td></tr><tr><td style="text-align:center">关键知识点被埋没</td><td style="text-align:center"><a href="#A">A</a> <a href="#C">C</a> <a href="#J">J</a> <a href="#X">X</a></td></tr><tr><td style="text-align:center">遇到记忆相关的问题</td><td style="text-align:center"><a href="#E">E</a> <a href="#G">G</a></td></tr><tr><td style="text-align:center">概念错误或混淆</td><td style="text-align:center"><a href="#A">A</a> <a href="#U">U</a></td></tr><tr><td style="text-align:center">(老师) 对学习者的潜能估计不准确</td><td style="text-align:center"><a href="#P">P</a></td></tr><tr><td style="text-align:center">抓不住大局，迷失学习目的</td><td style="text-align:center"><a href="#A">A</a> <a href="#P">P</a> <a href="#V">V</a></td></tr><tr><td style="text-align:center">脱离学习群体</td><td style="text-align:center"><a href="#B">B</a></td></tr><tr><td style="text-align:center">过于自信，导致学不进去新的东西</td><td style="text-align:center"><a href="#L">L</a> <a href="#S">S</a> <a href="#U">U</a> <a href="#V">V</a> <a href="#F">F</a></td></tr><tr><td style="text-align:center">信息量过大，认知过载</td><td style="text-align:center"><a href="#J">J</a> <a href="#V">V</a> <a href="#W">W</a></td></tr><tr><td style="text-align:center">情感汹涌， 情绪过载</td><td style="text-align:center"><a href="#B">B</a> <a href="#Y">Y</a> <a href="#X">X</a></td></tr><tr><td style="text-align:center">对细节的辨识力不足</td><td style="text-align:center"><a href="#C">C</a></td></tr><tr><td style="text-align:center">怎么读也读不懂</td><td style="text-align:center"><a href="#E">E</a> <a href="#G">G</a> <a href="#S">S</a></td></tr><tr><td style="text-align:center">学着学着就犯困</td><td style="text-align:center"><a href="#X">X</a> <a href="#Z">Z</a></td></tr><tr><td style="text-align:center">知识点都懂， 却在综合测试中发挥的不好</td><td style="text-align:center"><a href="#C">C</a> <a href="#J">J</a></td></tr><tr><td style="text-align:center">练习技能的时候不认真</td><td style="text-align:center"><a href="#D">D</a> <a href="#F">F</a></td></tr><tr><td style="text-align:center">只会套公式，不求甚解</td><td style="text-align:center"><a href="#H">H</a> <a href="#J">J</a> <a href="#K">K</a> <a href="#W">W</a></td></tr><tr><td style="text-align:center">表现不佳，发挥失常</td><td style="text-align:center"><a href="#B">B</a> <a href="#D">D</a></td></tr><tr><td style="text-align:center">没有动力去做出尝试</td><td style="text-align:center"><a href="#B">B</a> <a href="#R">R</a> <a href="#Y">Y</a></td></tr><tr><td style="text-align:center">做出不切实际的期望</td><td style="text-align:center"><a href="#D">D</a> <a href="#Y">Y</a></td></tr><tr><td style="text-align:center">遇到不常见的情况不知道该如何应对，或者不知该表达何种情绪</td><td style="text-align:center"><a href="#O">O</a> <a href="#R">R</a></td></tr><tr><td style="text-align:center">道理讲不明白</td><td style="text-align:center"><a href="#R">R</a></td></tr><tr><td style="text-align:center">用语言描述说也说不明白</td><td style="text-align:center"><a href="#H">H</a> <a href="#O">O</a></td></tr></tbody></table><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://www.amazon.cn/dp/B07D16LQKN" target="_blank" rel="noopener">科学学习：斯坦福黄金学习法则</a></p>]]></content>
    
    <summary type="html">
    
      活到老学到老。
    
    </summary>
    
    
      <category term="ReadingNotes" scheme="https://neo1989.net/categories/ReadingNotes/"/>
    
    
      <category term="SoftSkills" scheme="https://neo1989.net/tags/SoftSkills/"/>
    
  </entry>
  
  <entry>
    <title>Gianna and Kobe, 2.24</title>
    <link href="https://neo1989.net/SeizeTheDay/Bryant-2-and-24/"/>
    <id>https://neo1989.net/SeizeTheDay/Bryant-2-and-24/</id>
    <published>2020-02-24T07:45:54.000Z</published>
    <updated>2021-01-13T16:29:09.837Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://s3.mindex.xyz/blog/cure/4bbc4b6a10d50fb684da342e4883a8d2.png" alt="Farewell."></p>]]></content>
    
    <summary type="html">
    
      曼巴精神永存
    
    </summary>
    
    
      <category term="SeizeTheDay" scheme="https://neo1989.net/categories/SeizeTheDay/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员能力矩阵</title>
    <link href="https://neo1989.net/CheatSheet/CHEATSHEET-programmer-competency-matrix/"/>
    <id>https://neo1989.net/CheatSheet/CHEATSHEET-programmer-competency-matrix/</id>
    <published>2020-02-01T10:17:43.000Z</published>
    <updated>2021-01-26T15:02:50.558Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://s3.mindex.xyz/blog/coder/6bfd997477e99166c110e543662b7e81.png" alt="The Programmer's Life"></p><p>英文原文：<a href="http://sijinjoseph.com/programmer-competency-matrix/" target="_blank" rel="noopener">《Programmer Competency Matrix》</a></p><blockquote><p>Note that the knowledge for each level is cumulative.<br>Being at level n implies that you also know everything from the levels lower than n.</p></blockquote><h3 id="Computer-Science">Computer Science</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">$ 2^n$</th><th style="text-align:center">$n^2$</th><th style="text-align:center">$n$</th><th style="text-align:center">$log(n)$</th></tr></thead><tbody><tr><td style="text-align:center"><em>数据结构</em></td><td style="text-align:center">不知道数组和链表的差异</td><td style="text-align:center">能够解释和使用数据、链表、字典等，并能够用于实际的编程任务</td><td style="text-align:center">了解基本数据结构时间和空间的折中，比如数组vs链表，能够解释哈希表如何实现以及如何处理冲突，了解优先队列以及如何实现，等等</td><td style="text-align:center">高等数据结构知识，比如B树、二项堆、斐波那契堆、AVL树、红黑树、跳表、前缀树等</td></tr><tr><td style="text-align:center"><em>算法</em></td><td style="text-align:center">不能够找出一个数组的平均值</td><td style="text-align:center">排序、搜索、数据的结构遍历以及检索算法</td><td style="text-align:center">树，图，简单的贪婪算法和分治算法，有能力了解矩阵各层的相关性</td><td style="text-align:center">能够识别和编写动态规划方案，良好的图算法知识，良好的数值估算的知识，能够鉴定NP问题</td></tr><tr><td style="text-align:center"><em>系统编程</em></td><td style="text-align:center">不知道何为编译器、链接器、解释器</td><td style="text-align:center">对编译器、链接器、解释器有基本的了解。知道什么是汇编代码以及在硬件层如何工作。有一些虚拟内存和分页知识</td><td style="text-align:center">了解内核模式、用户模式、多线程、同步原语以及它们是怎么实现的，能够阅读汇编代码。了解网络协议和socket级别编程</td><td style="text-align:center">了解整个程序堆栈、硬件（CPU+内存+中断+微码）、二进制代码、汇编、静态和动态链接、编译、解释、JIT编译、GC、堆、栈、内存寻址 等</td></tr></tbody></table><h3 id="Software-Engineering">Software Engineering</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">$ 2^n$</th><th style="text-align:center">$n^2$</th><th style="text-align:center">$n$</th><th style="text-align:center">$log(n)$</th></tr></thead><tbody><tr><td style="text-align:center"><em>源码版本控制</em></td><td style="text-align:center">通过日期备份文件夹</td><td style="text-align:center">VSS和初级的CVS/SVN用户</td><td style="text-align:center">熟练地使用CVS和SVN特性。知道如何分支和归并，使用程序库补丁安装特性等</td><td style="text-align:center">有分布式VCS系统的知识。尝试过Bzr/Mecurial/Darcs/GIT</td></tr><tr><td style="text-align:center"><em>构建自动化</em></td><td style="text-align:center">只知道在IDE下编译</td><td style="text-align:center">知道如何在命令行下编译系统</td><td style="text-align:center">可以建立脚本以构建基础系统</td><td style="text-align:center">可以建立脚本以构建系统、文档、安装程序、生成发布概要并且在版本控制内打tag</td></tr><tr><td style="text-align:center"><em>自动化测试</em></td><td style="text-align:center">认为所有的测试都是测试员的工作</td><td style="text-align:center">能够编写自动化的单元测试，能够为正在编写的代码提出良好的测试用例</td><td style="text-align:center">按照TDD方式编写代码</td><td style="text-align:center">理解并能够设置自动化功能，自动加载、自动性能测试、自动UI测试等</td></tr></tbody></table><h3 id="Programming">Programming</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">$ 2^n$</th><th style="text-align:center">$n^2$</th><th style="text-align:center">$n$</th><th style="text-align:center">$log(n)$</th></tr></thead><tbody><tr><td style="text-align:center"><em>问题拆解</em></td><td style="text-align:center">只有复制黏贴才能复用的直线式代码</td><td style="text-align:center">能够把问题分散到多个函数中</td><td style="text-align:center">能够相处可以复用的函数/对象来解决整体的问题</td><td style="text-align:center">使用适宜的数据结构和算法，写出通用的面向对象代码来封装问题中易改变的层面</td></tr><tr><td style="text-align:center"><em>系统拆解</em></td><td style="text-align:center">无法跳到单一文件/类更高的层面</td><td style="text-align:center">在相同的平台/技术上能够分拆问题空间以及设计方案</td><td style="text-align:center">能够设计跨技术、跨平台的系统</td><td style="text-align:center">能够可视化和设计具有多种产品线和与外部系统集成的复杂系统。同时应该有能力设计支撑系统，比如监控、报告、故障恢复等等</td></tr><tr><td style="text-align:center"><em>交流</em></td><td style="text-align:center">无法向同伴表达想法、主意。拼写、语法欠缺</td><td style="text-align:center">同伴能了解你在说什么，有良好的拼写和语法能力</td><td style="text-align:center">能够和同伴进行高效的交流</td><td style="text-align:center">能够以明确的方式理解和交流思想、设计、创意、规范，并且适应各种上下文</td></tr><tr><td style="text-align:center"><em>单文件代码组织</em></td><td style="text-align:center">同一文件中组织没有依据</td><td style="text-align:center">按逻辑或可访问性分组方法</td><td style="text-align:center">代码分块，引用其他文件有良好的注释</td><td style="text-align:center">文档头部有许可声明，良好的注释，使用长空白。文档优雅</td></tr><tr><td style="text-align:center"><em>跨文件代码组织</em></td><td style="text-align:center">对跨文件代码组织一无所知</td><td style="text-align:center">相关文件在同一文件夹下</td><td style="text-align:center">每个文件有各自独立目的，比如一个类的定义、一个特性的实现</td><td style="text-align:center">在物理级别上的代码组织与设计密切匹配，查看文件名和文件夹分布可以深入了解设计</td></tr><tr><td style="text-align:center"><em>源码树组织</em></td><td style="text-align:center">一切都在一个文件夹下</td><td style="text-align:center">初步将代码分散进对应逻辑的文件夹</td><td style="text-align:center">没有循环依赖，二进制文件、库、文档、构建程序、第三方代码都组织进合适的文件夹内</td><td style="text-align:center">源码树的物理布局与逻辑层次、组织方式相匹配，可以通过目录名称合组织方式洞察设计理念</td></tr><tr><td style="text-align:center"><em>代码可读性</em></td><td style="text-align:center">单音节名称</td><td style="text-align:center">对文件名、变量、类、方法等有良好的的命名</td><td style="text-align:center">没有长功能，对不寻常代码、bug修复、代码假设等进行注释</td><td style="text-align:center">使用断言验证代码假设，自然的代码流（没有深度嵌套的方法或条件句）</td></tr><tr><td style="text-align:center"><em>防御式编程</em></td><td style="text-align:center">不知道这个概念</td><td style="text-align:center">检查代码中所有的参数，对关键的假设进行断言</td><td style="text-align:center">确保检查了返回值和处理了代码失败的异常</td><td style="text-align:center">有自己的库来帮助防御式编程，编写单元测试模拟故障</td></tr><tr><td style="text-align:center"><em>错误处理</em></td><td style="text-align:center">仅针对正常流程编码</td><td style="text-align:center">基本的对可能抛出异常/生成错误的代码进行错误处理</td><td style="text-align:center">确保错误/异常以正确的状态离开程序， 资源、连接、内存都被正确地清理</td><td style="text-align:center">在可能的异常进行编码检测， 在所有代码层级中维护一致的异常处理策略，具有对整个系统进行异常处理的指导方针</td></tr><tr><td style="text-align:center"><em>IDE</em></td><td style="text-align:center">基本用作文本编辑</td><td style="text-align:center">熟悉UI上的多种方式，能够通过菜单高效地使用IDE</td><td style="text-align:center">熟悉大部分常用操作的快捷键</td><td style="text-align:center">曾写过自定义宏</td></tr><tr><td style="text-align:center"><em>API</em></td><td style="text-align:center">需要经常查询文档</td><td style="text-align:center">能记住常用的API</td><td style="text-align:center">对API具有广度和深度的了解</td><td style="text-align:center">写过在 API 上的类库来帮助简化常用的任务以及给 API 填坑</td></tr><tr><td style="text-align:center"><em>框架</em></td><td style="text-align:center">除了核心平台没使用过其它任何框架</td><td style="text-align:center">听过但没用过平台上流行的框架</td><td style="text-align:center">精通多个框架，并精通这些框架的习语</td><td style="text-align:center">框架作者</td></tr><tr><td style="text-align:center"><em>需求分析</em></td><td style="text-align:center">拿到给定需求并按规格编码</td><td style="text-align:center">能够想到规格中缺失的问题</td><td style="text-align:center">理解完整的蓝图并产生整个需要被纳入规格的范围</td><td style="text-align:center">能够基于经验对给定需求建议更好的替代方案和流程</td></tr><tr><td style="text-align:center"><em>脚本处理</em></td><td style="text-align:center">不了解脚本工具</td><td style="text-align:center">BAT 文件/ shell 脚本</td><td style="text-align:center">Perl/Python/Ruby/VBScript/Powershell</td><td style="text-align:center">曾写过并发布过可重用代码</td></tr><tr><td style="text-align:center"><em>数据库</em></td><td style="text-align:center">认为 Excel 是数据库</td><td style="text-align:center">了解基本数据库概念、规范化、ACID、事务， 并能书写简单的 SELECT 语句</td><td style="text-align:center">能够设计良好的规范化的系统图式， 时时记住必须运行的查询,精通视图、存储过程、触发器和用户定义类型的使用， 了解集群和非集群索引间的差别， 精通 ORM 工具的使用</td><td style="text-align:center">可作为基本的数据库管理员， 性能优化， 索引优化， 编写高级 SELECT 查询， 能使用关系型 SQL 替换游标的使用， 理解数据在内部是如何存储的， 了解数据库应该如何做镜像、副本等， 理解两相提交如何运作</td></tr></tbody></table><h3 id="Experience">Experience</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">$ 2^n$</th><th style="text-align:center">$n^2$</th><th style="text-align:center">$n$</th><th style="text-align:center">$log(n)$</th></tr></thead><tbody><tr><td style="text-align:center"><em>专业语言经验</em></td><td style="text-align:center">命令式或面向对象</td><td style="text-align:center">命令式、面向对象和声明式(SQL)， 如果理解静态vs动态类型，弱类型vs强类型及静态推断类型有加分</td><td style="text-align:center">函数式， 如果理解惰性求值、柯里化、延续有加分</td><td style="text-align:center">并发(Erlang, Oz) 和逻辑(Prolog)</td></tr><tr><td style="text-align:center"><em>专业平台经验</em></td><td style="text-align:center">1</td><td style="text-align:center">2-3</td><td style="text-align:center">4-5</td><td style="text-align:center">6+</td></tr><tr><td style="text-align:center"><em>专业经验年限</em></td><td style="text-align:center">1</td><td style="text-align:center">2-5</td><td style="text-align:center">6-9</td><td style="text-align:center">10+</td></tr><tr><td style="text-align:center"><em>领域知识</em></td><td style="text-align:center">没有领域知识</td><td style="text-align:center">至少在该领域的一个产品上工作过</td><td style="text-align:center">在相同领域的多个产品上工作过</td><td style="text-align:center">领域专家， 在该领域设计并实现过多个产品/解决方案， 精通该领域使用的标准术语、协议</td></tr></tbody></table><h3 id="Knowledge">Knowledge</h3><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">$ 2^n$</th><th style="text-align:center">$n^2$</th><th style="text-align:center">$n$</th><th style="text-align:center">$log(n)$</th></tr></thead><tbody><tr><td style="text-align:center"><em>开发工具</em></td><td style="text-align:center">仅限于主要的IDE</td><td style="text-align:center">知道一些流行且符合标准的备选工具</td><td style="text-align:center">对编辑器、调试器、IDE、开源的备选方案有很好的了解。比如了解或熟悉<a href="https://www.hanselman.com/blog/ScottHanselmans2014UltimateDeveloperAndPowerUsersToolListForWindows.aspx" target="_blank" rel="noopener">《Scott Hanselman 的威力工具表》</a></td><td style="text-align:center">实际编写过工具和脚本, 发表过有加分</td></tr><tr><td style="text-align:center"><em>代码库知识</em></td><td style="text-align:center">从未阅读过代码库</td><td style="text-align:center">基本了解代码布局，知道如何构建系统</td><td style="text-align:center">熟悉代码库工作原理， 实现过几个 BUG 修复，可能也有几个小特性实现</td><td style="text-align:center">在代码库中实现多个大的特性， 能够很容易构想大多数特性或 BUG 修改会对代码库造成的变更</td></tr><tr><td style="text-align:center"><em>新兴技术的知识</em></td><td style="text-align:center">没听说过新兴技术</td><td style="text-align:center">偶尔听过新兴技术</td><td style="text-align:center">下载过 alpha 预览/CTP/beta 版本，并阅读过一些文章和手册</td><td style="text-align:center">玩过预览版，并利用它构建过一些实际的东西， 将其分享给其它人有加分</td></tr><tr><td style="text-align:center"><em>平台内部</em></td><td style="text-align:center">不了解平台内部</td><td style="text-align:center">对平台内部如果运作有基本了解</td><td style="text-align:center">深入了解平台内部， 能够想象出平台如何接受程序并将其转换为可执行代码</td><td style="text-align:center">给平台内部写过工具来增强或提供有用信息。 如反汇编、反编译、调试器等</td></tr><tr><td style="text-align:center"><em>书籍</em></td><td style="text-align:center">菜鸟系列，21天系列，24小时系列，蠢货系列…</td><td style="text-align:center">《代码大全》，《别让我思考》, 《精通正则表达式》</td><td style="text-align:center">设计模式》，《人件》，《代码珠玑》，《算法设计手册》，《程序员修炼之道》，《人月神话》</td><td style="text-align:center">《计算机程序设计与解释》，《事务处理:概念与技术》，《计算机程序设计模型》，《计算机程序设计艺术》，《数据库系统导论》 C.J Date版，《Thinking Forth》 ，《Little Schemer》</td></tr><tr><td style="text-align:center"><em>博客</em></td><td style="text-align:center">没时间看</td><td style="text-align:center">经常阅读技术/编程/软件工程相关博客及听播客</td><td style="text-align:center">维护收集的有用文章和工具的博客链接</td><td style="text-align:center">维护收集的有用文章和工具的博客链接</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      A programmer to be。
    
    </summary>
    
    
      <category term="CheatSheet" scheme="https://neo1989.net/categories/CheatSheet/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
  </entry>
  
</feed>
