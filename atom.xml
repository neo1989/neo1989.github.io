<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>愚苏记</title>
  
  <subtitle>To no avail but try.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://neo1989.net/"/>
  <updated>2023-02-13T06:47:37.395Z</updated>
  <id>https://neo1989.net/</id>
  
  <author>
    <name>Neo</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《为什么没人早点告诉我》</title>
    <link href="https://neo1989.net/Notes/NOTE-why-has-nobody-told-me-this-before/"/>
    <id>https://neo1989.net/Notes/NOTE-why-has-nobody-told-me-this-before/</id>
    <published>2023-02-13T01:59:49.000Z</published>
    <updated>2023-02-13T06:47:37.395Z</updated>
    
    <content type="html"><![CDATA[<h3 id="就是开心不起来怎么办">就是开心不起来怎么办</h3><h4 id="如何看待情绪低落">如何看待情绪低落</h4><ul><li>情绪有起伏波动是狠正常的，没有人能一直开兴。但我们不能被情绪控制，而应该去做一些有帮助的事情。</li><li>情绪低落并不是大脑出了问题，更可能是因为需求没有得到满足。</li><li>我们生活中的每一刻都可以拆解成体验的不同方面。</li><li>这些方面相互影响，向我们展示了我们是如何陷入情绪低落（甚至是抑郁）的恶性循环的。</li><li>我们的情绪是通过那些我们能影响的事情构建的。</li><li>情绪没有开关，我们也无法选择情绪，但我们可以利用可控的东西来改变自己的感受。</li><li>使用十字概念化这个工具（如下图所示）来培养觉察能力，注意哪些因素会影响我们的情绪，让我们深陷其中。</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/87e1ba72e2112f5c0b54a8843a4b41a7.png" alt="纠结于消极的想法很可能会让人情绪低落，而情绪低落又会催生出更多消极的想法。这张图很好地说明了我们是如何陷入情绪低落的恶性循环，同时也告诉我们，如何才能走出困境。"></p><h4 id="当心情绪陷阱">当心情绪陷阱</h4><ul><li>思维偏差是不可避免的，但对其负面影响，我们并不是无能为力。</li><li>我们会自然而然地寻找证据来证实自己的看法，并坚定地相信它，尽管有很多其他证据表明这种看法并不正确。</li><li>情绪低落是由什么引起的，都会让我们将注意力集中在威胁与消极因素上。</li><li>如果我们持续关注这些因素，并把它们当作事实，那么这种负面偏见就会中庸到我们身上，加剧情绪低落。</li><li>对抗这种恶性循环的策略就是要弄明白，感受并不能作为证据，它不能证明你的想法就是事实。</li><li>另一种策略是保持好奇、探究的态度。</li><li>通过了解常见的思维偏差类型，和这些想法保持距离，注意它们可能会在什么时候出现，时刻记住它们只是偏见，不是事实。</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/ee25c3fe40343a79901e40c4edefbebe.png" alt="思维偏差的种类及实例"></p><h4 id="怎么做才有用">怎么做才有用</h4><ul><li>我们无法控制突然出现在脑海中的想法，但我们可以控制注意力的聚焦点。</li><li>试图不去想某件事，只会让你想得更多。</li><li>允许所有想法的存在，但要确定哪些想法是值得投入时间和精力的，这对我们的情感体验有很大的影响。</li><li>正念练习与感恩练习能够训练我们转移注意力的能力。</li><li>当我们专注与一个问题的时候，也要关注我们前进的方向，以及我们想要如何感受，如何行动。</li><li>想法不是事实，想法只是大脑给出的意见，帮助我们理解这个世界。</li><li>一个想法对我们能有多大影响，取决于我们在多大程度上相信它是事实。</li><li>要从想法中汲取力量，就需要后退异步，与它保持一定的距离（元认知策略：注意到你的脑海中出现了哪些想法，并观察它们给你带来的感受的过程。），看清它的真实面目。</li></ul><h4 id="如何把糟糕的一天变成美好的一天">如何把糟糕的一天变成美好的一天</h4><ul><li>我们应该专注于做出好的决定，而不是完美的决定。以“足够好”为标准，会引导你做出真正的改变。完美主义会导致你瞻前顾后，难以做出选择，而要想改善情绪，你必须做出决定，采取行动。</li><li>改变可以从小事做起，要持之以恒。</li><li>别人情绪低落时，我们通常会表现得友好、体贴，因为我们知道这正是它们所需要的。所以当我们努力调节情绪和心理状态时，也应该练习自我关怀。</li><li>明白了这些，你就能以此为出发点，找到自己想要的方向，并专注于脚下的路。</li></ul><h4 id="防御，让你不被打倒的力量">防御，让你不被打倒的力量</h4><ul><li>守护心理健康的“守门员”为身心健康打下了基础。如果你每天都能照顾好它们，它们一定会给你丰厚的回报。</li><li>如果你今天只想给自己安排一件事，那就去运动吧。选择你喜欢的运动，这样更容易坚持。</li><li>睡眠与心理健康是相互作用的。高质量的睡眠对心理健康有益，改变心理状态也会促进睡眠。</li><li>你给大脑充电的方式会影响你的感受。研究表明，传统的地中海饮食、日本饮食与挪威饮食对心理健康有益。</li><li>人与人的连接是强化复原力的有力工具。人际关系会改变你的身心状态。</li></ul><h3 id="做事提不起精神，没有动力怎么办">做事提不起精神，没有动力怎么办</h3><h4 id="理解驱动力">理解驱动力</h4><ul><li>驱动力并不是与生俱来的。</li><li>那种充满动力，想要去做某事的感觉不会一直存在，所以你不能依赖它。</li><li>要掌控你的驱动力，就是培养这样一种能力：无论你有多么不想做，你也会自动去做那些对你最重要的事。</li><li>拖延症通常是为了逃避压力和不适感。</li><li>快感缺失指的是我们现在无法从过去喜欢做的事中找到乐趣，通常和情绪低落、抑郁症有关。</li><li>如果有些事对你很重要，同时又对你的健康有益，那么现在就去做，不要等到你想做的时候才行动。</li></ul><h4 id="如何培养动机感">如何培养动机感</h4><ul><li>虽然我们无法控制动机感，但我们可以做一些事情来让自己更多地体验到动机感。</li><li>要培养动机感，得先让身体动起来。哪怕是少量的运动，也比完全不运动好，能让你充满动力。</li><li>与目标保持连接有助于持续激发驱动力。</li><li>从微小而持续的行动开始。</li><li>在压力环境中学会休息，补充能量，能最大程度地锻炼意志力。</li><li>羞耻感并不像你想的那样，能够让你产生驱动力。你要做的是改变你与失败的关系。</li></ul><h4 id="不想做一件事时，怎样才能让自己去做呢">不想做一件事时，怎样才能让自己去做呢</h4><ul><li>驱动力不是永远存在的。</li><li>我们可以练习与冲动相反的行为，我们要按照自己的价值观做事，而不是根据当下的感受。</li><li>只要重复的次数足够多，一个新的行为就能成为习惯。</li><li>要想实现远大的目标，在前进的道路上就必须休息、充电，就像优秀的运动员那样，这非常重要。</li><li>在实现目标的过程中，不断给自己小小的奖励。</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/31cfde9c9f710898c3d6388cf1fd70f3.png" alt="做出改变与维持现状的利弊"></p><h4 id="重大的人生改变，应该从哪里开始">重大的人生改变，应该从哪里开始</h4><ul><li>我们有时候并不清楚应该改变什么以及如何去改变。</li><li>没有对自我的理解，就无法改变。</li><li>彻底了解你的问题所在，才能更容易确定下一步应该怎么做。</li><li>事情发生后，先反思一下。</li><li>准备好诚实地面对：你是如何导致问题的出现，又是如何让自己陷入困境的。</li><li>心理治疗的过程能为你提供支持，如果你没机会看心理医生，也可以从记日记开始。</li></ul><h3 id="陷入痛苦情绪怎么办">陷入痛苦情绪怎么办</h3><h4 id="让情绪全部消失">让情绪全部消失</h4><ul><li>情绪既不是敌人，也不是朋友。</li><li>我们对自己的情绪状态的影响力笔我们以为的要大的很多。</li><li>抗拒情绪只会带来更多问题，我们不如接纳情绪，顺其自然。</li><li>情绪不是事实，只是一个可能的视角。</li><li>如果你现在有痛苦的情绪，保持好奇心，提出问题——情绪能告诉你什么？</li></ul><h4 id="如何处理情绪">如何处理情绪</h4><ul><li>感受不能代表你，你也不能等同于你的感受。</li><li>情绪的感受就是经由你身体的体验。</li><li>每种情绪哦赌能给你提供信息，但这些信息并不全面。</li><li>情绪的作用就是告诉你，你需要什么。</li><li>当你感受到情绪时，就给它起个名字。情绪不仅包括快乐或悲伤，还应该有更细致的分类方式。</li><li>我们应该接纳情绪，而不是抗拒情绪。要学会自我安抚。</li></ul><h4 id="如何利用语言的力量">如何利用语言的力量</h4><ul><li>我们所使用的语言极大地影响这我们对世界的体验。</li><li>描述自己感受的词汇越多越好。</li><li>想不出合适的词语时，可以参考感受圆盘。</li><li>注意别人是如何用词的，你可以通过读书、看电影等多种凡是来扩大自己的情绪词汇量。</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/df5eae13d31c1027bd7bc01863922a4a.png" alt="在感受圆盘中找到能描述自己感受的词汇"></p><h4 id="当你关心的人陷入痛苦时">当你关心的人陷入痛苦时</h4><ul><li>当别人出现心理问题时，我们想去帮助他，但又觉得不知所措、力不从心，这是很正常的。</li><li>看到别人遭受痛苦，你想支持他，又怕自己说错话，这回让你很有压力，但一定不要因此回避他。</li><li>强有力的支持并不意味着要解决所有问题。</li><li>要照顾好自己，别让自己心力交瘁。维护自己的利益，设定清晰的界限。</li><li>永远不要低估倾听的力量。</li></ul><h3 id="无法走出悲伤怎么办">无法走出悲伤怎么办</h3><h4 id="理解悲伤">理解悲伤</h4><ul><li>那些对我们来说意义重大的事物的结束，都会引发悲伤——这种结束不一定是死亡。</li><li>悲伤是人类情感体验中很正常、自然的一部分。</li><li>痛苦可以是情绪上的，也可以是身体上的。</li><li>有帮助的事情并不会让痛苦小事，也不会迫使你放手。</li><li>完全回避悲伤可能会导致更深层次的问题。</li></ul><h4 id="悲伤的阶段">悲伤的阶段</h4><ul><li>否认能帮助我们承受住悲伤带来的痛苦。否认消退后，新的情绪会付出水面。</li><li>如果你无法控制愤怒的情绪，可以去做运动，利用生理唤醒，让身体暂时恢复平静。</li><li>反复思考“假如…现在会怎样”，很容易把自己引入自责的陷阱。</li><li>抑郁是失去亲人后的正常反应。</li><li>接受并不意味这你喜欢或认可现状。</li></ul><h4 id="哀悼的任务">哀悼的任务</h4><ul><li>治愈悲伤的第一步是允许自己感受痛苦。</li><li>我们需要时间来适应亲人已不复存在的生活。</li><li>我们需要找到一种方法，即使亲人不在了，也能继续和他们保持连接。</li><li>接受新的现实，我们才能继续去做那些对我们很重要的事。无论你有什么样的感受，都是正常的。</li><li>不要低估每一小步的作用，稳步前进。</li></ul><h4 id="力量的支柱">力量的支柱</h4><ul><li>时间、努力与坚持能帮合租你重建失去亲人后的生活。</li><li>通过新的方式与逝去的人保持连接，比如去你们一起去过的、有特殊意义的地方，或者去墓地悼念。</li><li>在整个过程中要尽可能地倾听自己的需求。</li><li>表达悲伤的方式无所谓对错。</li><li>不要规定自己必须多长时间走出悲伤。</li></ul><h3 id="低自尊人格，经常自我怀疑怎么办">低自尊人格，经常自我怀疑怎么办</h3><h4 id="如何看待别人的批评与否定">如何看待别人的批评与否定</h4><ul><li>学习正确地看待批评与否定，这是一项重要的生活技能。</li><li>我们天生就在乎别人对我们的看法，说“我不在乎任何人的想法”的人都不是真心的。</li><li>取悦被人绝不是表面上的与人为善，而是在任何情况下都把别人的需求置于自己的需求之上，甚至不惜损害自己的健康和幸福。</li><li>要理解为什么有些人总是吹毛求疵，这对你很有帮助。</li><li>你可以培养自尊感与羞耻感复原力，这能改变你的人生。</li></ul><h4 id="建立信心的关键">建立信心的关键</h4><ul><li>一个人只有在缺乏自信的情况下才会增加自信。</li><li>想要建立自信，就要走出舒适区。每天重复这样做，你的自信心会与日自增。</li><li>自信会根据情境而改变，当情境发生变化时，你要相信自己能客服畏惧，从而增强自信。</li><li>你不需要把自己置于最恶劣的环境中，可以从小的改变开始。</li><li>在建立自信的过程中，要做好自己的教练，而不是最苛刻的批评者。</li><li>先有勇气，再有自信。</li></ul><h4 id="你的错误不能代表你这个人">你的错误不能代表你这个人</h4><ul><li>大多数自我怀疑都与我们和失败的关系有关。</li><li>别人如何看待你的失败并不能说明你的个性，也不代表你作为人的价值。</li><li>失败带来的痛苦会驱使我们麻痹自己，自我封闭。就算你一开始没有觉察到自己的感受，你也可以觉察自己是通过哪些行为来屏蔽情绪的。</li><li>做自己的教练，把失败变成学习的机会，你才能不断进步，朝着你觉得最重要的方向努力。</li><li>失败会引发巨大的情绪反应，所以不要着急。</li></ul><h4 id="对自己更“狠”一些">对自己更“狠”一些</h4><ul><li>有一种误解，认为自我接纳会让人变得懒惰、自满、缺乏动力。</li><li>研究表明，那些能学着自我接纳、自我关怀的人不太可能惧怕失败，他们也更愿意再次尝试。</li><li>自我接纳不是被动地接受失败。</li><li>自我关怀也包括选择那条更难走但对你更有利的路。</li></ul><h3 id="极度焦虑，整天忧心忡忡怎么办">极度焦虑，整天忧心忡忡怎么办</h3><h4 id="消除焦虑">消除焦虑</h4><ul><li>人们希望消除焦虑是可以理解的，因为焦虑会令人不适。</li><li>要战胜恐惧，首先必须愿意面对它。</li><li>逃避只能短期缓解焦虑，长期来看，它只会加重焦虑。</li><li>我们为了控制和消除恐惧而做出的努力，正支配着我们的一举一动。</li><li>威胁应对系统会快速行动，你还来不及仔细思考，它就拉响了警报。</li></ul><h4 id="哪些做法会加重焦虑">哪些做法会加重焦虑</h4><ul><li>人在焦虑时最自然而然的反应就是逃避。</li><li>但逃避不会让焦虑消失。</li><li>仅仅告诉大脑某些东西是安全的还不够，你必须亲身体验，才能真正相信。</li><li>你需要一遍一遍重复这种行为，大脑才会被说服。</li><li>你做的最多的失去会成为你的舒适区。</li><li><strong>要想减轻对某件事的焦虑，就反复做这件事</strong>。</li></ul><h4 id="如何平复当下的焦虑">如何平复当下的焦虑</h4><ul><li>焦虑时，呼吸会变得急促、短浅。</li><li>想要让身体平静下来，请慢慢地深呼吸。</li><li>试着让呼气时间比吸气时间更长，呼气比吸气更有力。</li><li>要给它一些时间，焦虑反应会开始消退。</li></ul><h4 id="如何处理焦虑的想法">如何处理焦虑的想法</h4><ul><li>发现偏差并确定它是哪种类型的，这样才能与焦虑的想法保持距离。</li><li>记住，即使你还是会持续关注焦虑的想法，但你可以控制关注的焦点。</li><li>善意能减轻威胁反应，无论是来自他人的善意，还是我们对自己的善意。</li><li>将威胁重新定义为挑战，能让我们充满勇气。</li><li>行动要与价值观一致，你做决定应该根据什么对你最重要，而不是处于恐惧。</li></ul><h4 id="对不可避免的事情的恐惧">对不可避免的事情的恐惧</h4><ul><li>我们都惧怕死亡，包括它的已知和未知。</li><li>对于有些人来说，接近死亡会让他们成长，也会带来积极的生活转变。</li><li>接受死亡并不意味着放弃生命，而是恰恰相反。</li><li>接受死亡才能让我们赋予生命意义。</li></ul><h3 id="压力大到濒临崩溃怎么办">压力大到濒临崩溃怎么办</h3><h4 id="压力和焦虑有什么不同吗">压力和焦虑有什么不同吗</h4><ul><li>人们常把“压力”和“焦虑”这两个词混用</li><li>当我们的生理状态能够与外部需求相匹配时，即便有压力，我们也会把它解读为积极的感受。</li><li>当我们的大脑在为我们要做的事做准备时，我们就会感到压力。</li><li>大脑会释放能量，以提高警觉性，让我们对环境做出反应。</li><li>我们常把焦虑理解为基于恐惧而做出反应，实际上它是为了满足你的需求而产生的一种压力反应。</li></ul><h4 id="为什么减压不是唯一的答案">为什么减压不是唯一的答案</h4><ul><li>压力并不总是敌人，它也是最有价值的工具。</li><li>要学着在承受压力后充实身心，与试图消除压力相比，这个做法更实际。</li><li>压力能帮助你表现得更出色，也能驱使你做最重要的事，但我们不能一直处于压力状态。</li><li>适度的压力会让生活充满乐趣和挑战，但压力太大会让人无法感受到生活的美好。</li></ul><h4 id="当有益的压力变得有害">当有益的压力变得有害</h4><ul><li>短期的压力反应能激发出最好的状态。</li><li>长期压力就像在高速公路上开车挂二挡，用不了多长时间，就会出事故。</li><li>倦怠不仅仅是工作造成的。</li><li>没有万能的灵丹妙药。对其他人保持平衡有用的方法对你也许没有作用。</li><li>如果你出现倦怠的迹象，你要倾听它们并及时回应，要学着满足自己的需求。</li></ul><h4 id="把压力变成动力">把压力变成动力</h4><ul><li>改变一些简单的行为模式，比如呼吸模式，能改变你的压力水平。</li><li>科学表明，冥想对大脑和我们处理问题的方式有显著影响。</li><li>与他人建立连接能帮助我们从压力中恢复。社交隔离会让人身心俱疲，承受巨大压力。</li><li>以做出贡献为目标，而不是把竞争当成目标，这样在面对压力时，我们才有动力和毅力。</li><li>寻找能让自己产生敬畏之心的体验，以改变视角。</li></ul><h4 id="如何处理必须面对的压力">如何处理必须面对的压力</h4><ul><li>我们对压力的看法会影响我们在压力状态下的表现。</li><li>把压力看作一种财富，可以帮助你实现目标，你不需要花太多精力去摆脱压力，而是要专注于你被要求做到的事。</li><li>关注应该做什么，而不是不该做什么。</li><li>调整你的关注点可以改变压力水平。</li><li>改变你与失败的关系，培养羞耻感复原力，能帮助你应对高压环境。</li></ul><h3 id="觉得人生没有意义怎么办">觉得人生没有意义怎么办</h3><h4 id="关于“我只想要幸福”的问题">关于“我只想要幸福”的问题</h4><ul><li>我们经常被灌输的观念史，幸福才是常态，一个人要是觉得不幸福，那他肯定是有心理问题的。</li><li>有时我们会觉得不幸福，这恰恰是因为我们是人，而且，人生本就艰难。</li><li>让生命有价值的人或是带给我们的不仅仅是幸福感，也混杂了爱、快乐、恐惧、羞愧和伤害。</li><li>要弄清楚自己的价值观，因为它能引导我们去设定人生目标，而实现目标的过程是有意义、有价值的。</li><li>要把价值观放在第一位，因为它能帮助我们熬过人生的痛苦时刻，让我们知道自己走在正确的路上。</li></ul><h4 id="找到最重要的事">找到最重要的事</h4><ul><li>你可以通过一些简单的练习来弄清楚自己现阶段的价值观。</li><li>价值观会随着时间的推移而改变，我们的生活与价值观的一致程度也会改变，因此，有必要经常审视自己的价值观。</li><li>我们可以根据价值观进行大的目标设定，并确立日常的小目标。</li><li>重点不在于你希望会发生什么，而在于你想成为什么样的人，你想做出什么样的贡献，以及无论发生什么，你都会如何面对生活。</li></ul><p><img src="//s3.mindex.xyz/blog/Notes/5ee2743c032d16c193da31c6c6daae4b.png" alt="价值观——请圈出对你而言最重要、最有意义的价值观"><br><img src="//s3.mindex.xyz/blog/Notes/ba2d9900c52c6ccd737d32a3680d4b23.png" alt="这张表格中的示例能说明价值观与目标的区别，应该如何让目标与价值观一致，并转化为日常行为。"></p><h4 id="如何创造有意义的人生">如何创造有意义的人生</h4><ul><li>在下定决心要做出改变时，我们往往会给自己设立一个宏大的、激进的新目标。</li><li>只有一个目标并不足以保证我们能做出改变，更不能保证长久的改变。</li><li>花时间思考并想象你要成为怎样的人，并把这些想法转化为具体的、可持续的行动，这样你会觉得自己的努力更有意义。</li><li>将你行动的初衷与身份认同练习起来，这样最初的目标实现后，新的行为习惯也会持续下去。</li></ul><h4 id="关系">关系</h4><ul><li>当我们谈到幸福生活时，关系要比金钱、名誉、社会阶层、基因以及所有我们被告知要尽力争取的东西都要重要。</li><li>我们的关系以及我们在关系中感受到的幸福程度与我们的整体健康密不可分，关系是幸福和健康的核心。</li><li>改善自我有助于改善关系，而改善关系又有助于改善自我。</li><li>童年时期所形成的依恋关系通常会体现在成年后的关系中。</li></ul><h4 id="何时该寻求帮助">何时该寻求帮助</h4><ul><li>只要你关心自己的心理健康，你随时可以去寻求帮助。</li><li>如果你不确定自己需要多少帮助，专业人士可以帮助你做出决策。</li><li>在理想的世界，无论是谁，只要需要，就能得到专业的心理治疗。但理想的世界并不存在。</li><li>如果没有条件获得专业服务，那就抓住一切机会去了解关于心理疗愈的只是，并向你信任的人寻求支持。</li></ul>]]></content>
    
    <summary type="html">
    
      人生中的事分两类，你能控制的，你不能控制的。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="Health" scheme="https://neo1989.net/tags/Health/"/>
    
  </entry>
  
  <entry>
    <title>人格障碍</title>
    <link href="https://neo1989.net/Notes/NOTE-personality-disorder/"/>
    <id>https://neo1989.net/Notes/NOTE-personality-disorder/</id>
    <published>2023-01-31T04:24:53.000Z</published>
    <updated>2023-01-31T05:16:25.479Z</updated>
    
    <content type="html"><![CDATA[<h3 id="A类人格障碍">A类人格障碍</h3><p>表现为古怪的思想或行为。</p><h4 id="偏执型">偏执型</h4><ul><li>对他人的动机普遍表现出不信任和怀疑</li><li>毫无根据地认为他人试图伤害或欺骗自己</li><li>毫无根据地对他人的忠诚或诚信产生怀疑</li><li>由于无端地担心他人会利用获知的信息对付您，而不愿向他人倾诉</li><li>将无恶意言论或无威胁性情况视为人身侮辱或攻击</li><li>对察觉到的侮辱或轻蔑表现出愤怒或敌对反应</li><li>有怨恨倾向</li><li>毫无根据地反复怀疑配偶或性伴侣不忠</li></ul><h4 id="类精神分裂型">类精神分裂型</h4><ul><li>对社会或人际关系缺乏兴趣，喜欢独处</li><li>情感表达范围有限</li><li>在大多数活动中都无法获得乐趣</li><li>无法察觉社交暗示</li><li>看起来对别人很冷淡或漠不关心</li><li>几乎没有兴趣与他人发生性关系</li></ul><h4 id="精神分裂型">精神分裂型</h4><ul><li>穿着奇特、思想奇怪、有奇异的信念、言语怪异或行为怪癖</li><li>具有奇怪的感知经验，例如听到有声音在轻声呼唤自己的名字</li><li>表现出情绪平淡或不是当的情绪反应</li><li>社交焦虑、缺乏密切关系或对密切关系感到不适</li><li>表现出对他人冷淡」不当或怀疑的反应</li><li>“奇幻思维” —— 相信能用自己的思想影响身边的人和事</li><li>相信某些偶然时间具有仅对自己有意义的隐藏信息</li></ul><h3 id="B类人格障碍">B类人格障碍</h3><p>表现为戏剧性、过度情绪化或不可预测的思想或行为</p><h4 id="反社会型">反社会型</h4><ul><li>忽视他人的需求或感受</li><li>习惯撒谎、偷窃、使用别名和哄骗他人</li><li>反复违法</li><li>屡次侵犯他人的权利</li><li>经常有攻击和暴力行为</li><li>忽视自己或他人的安全</li><li>冲动行为</li><li>一贯不负责任</li><li>对自己的行为毫无悔意</li></ul><h4 id="边缘型">边缘型</h4><ul><li>表现出冲动和危险行为，例如不安全性行为、赌博或暴饮暴食</li><li>自我形象不稳定或脆弱</li><li>关系不稳定且紧张</li><li>心情起伏不定，往往是对人际压力的反应</li><li>自杀行为或自残威胁</li><li>强烈恐惧孤独或被抛弃</li><li>持续的空虚感</li><li>频繁且强烈地表现出愤怒</li><li>压力引起的妄想症，时有时无</li></ul><h4 id="表演型">表演型</h4><ul><li>不断寻求关注</li><li>用过度情绪化、戏剧化或性挑逗行为引起注意</li><li>固执己见，但几乎没有事实或细节支持</li><li>容易受他人影响</li><li>头脑简单，情绪变化太快</li><li>过度关注外表</li><li>过度乐观估计与他人的关系</li></ul><h4 id="自恋型">自恋型</h4><ul><li>认为自己很特别，且比他人更重要</li><li>对权力、成功和吸引力抱有幻想</li><li>不能认识到他人的需求和感受</li><li>对自己的成就或才能夸大其词</li><li>期望得到不断的赞美和欣赏</li><li>傲慢自大</li><li>不合理地期望得到利益和好处，经常利用他人</li><li>嫉妒他人，或认为被他人嫉妒</li></ul><h3 id="C类人格障碍">C类人格障碍</h3><p>表现为焦虑和恐惧的思想或行为</p><h4 id="回避型">回避型</h4><ul><li>对批评或拒绝太过敏感</li><li>感觉能力不足、自卑或缺乏吸引力</li><li>回避需要人际交往的工作活动</li><li>在社交上压抑、胆怯和孤立，不愿意参加新的活动或与陌生人见面</li><li>在社交场合和人际关系中极为害羞</li><li>害怕不被认可、尴尬或受到嘲笑</li></ul><h4 id="依赖型">依赖型</h4><ul><li>过度依赖他人，感觉自己需要被照顾</li><li>对他人表现出顺从或粘人的行为</li><li>害怕独自一人时不得不照顾自己</li><li>缺乏自信，即使做出很小的决定也需要别人的过度建议和肯定</li><li>因缺乏自信而难以独自开始或完成项目</li><li>难以与他人持不同意见，担心不被认可</li><li>即使有其他选择，也会容忍粗暴或虐待行为</li><li>当一段亲密关系结束时，迫切需要开始一段新的关系</li></ul><h4 id="强迫型">强迫型</h4><p>强迫型人格障碍不同于强迫症。</p><ul><li>对于细节、秩序和规则的先占观念</li><li>极端的完美主义，当未能达到完美时，例如因为没有达到自己的严格标准而无法完成一个项目，会导致身体机能障碍和痛苦</li><li>渴望控制他人、任务和局势，却无法委派任务</li><li>对工作或项目过度投入。从而忽视朋友和娱乐活动</li><li>无法丢弃破损或毫无价值的东西</li><li>刻板而固执</li><li>在道德、伦理或价值观方面过于死板</li><li>在控制预算和花钱方面很严格且吝啬</li></ul>]]></content>
    
    <summary type="html">
    
      如果您有任何一种人格障碍的体征和症状，请咨询您的医生、其他初级保健专家或心理健康专家。如果不加以治疗，人格障碍会给您的生活带来严重问题，并且情况可能变得越来越糟。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="Health" scheme="https://neo1989.net/tags/Health/"/>
    
  </entry>
  
  <entry>
    <title>Building a cool chatbot</title>
    <link href="https://neo1989.net/HandMades/HANDMADE-build-a-cool-chatbot-step-by-step/"/>
    <id>https://neo1989.net/HandMades/HANDMADE-build-a-cool-chatbot-step-by-step/</id>
    <published>2022-12-06T08:43:27.000Z</published>
    <updated>2023-01-06T08:11:24.807Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Concepts">Concepts</h2><p><strong>Natural Language Processing (NLP)</strong> is a field of Artificial Intelligence that enables computers to analyze and understand the human language.</p><p><strong>Natural Language Understanding (NLU)</strong> is a subset of a bigger picture of NLP, just like machine learning, deep learning, NLP, and data mining are a subset of a bigger picture of Artificial Intelligence (AI), which is an umbrella term for any computer program that does something smart.</p><p><strong><a href="https://spacy.io/" target="_blank" rel="noopener">spaCy</a></strong> is an open-source software library for advanced NLP, written in Python and Cython. It provides intuitive APIs to access its methods trained by deep learning models.</p><h2 id="Cornerstones">Cornerstones</h2><p>Before we actually dive into spaCy and code snippets, make sure we have the necessary setup ready.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/chatBot &amp;&amp; <span class="built_in">cd</span> ~/chatBot</span><br><span class="line">pyenv virtualenv 3.8.5 chatBot</span><br><span class="line">pyenv <span class="built_in">local</span> chatBot</span><br><span class="line">pip install spacy==3.4.3</span><br></pre></td></tr></table></figure><p><a href="https://spacy.io/models" target="_blank" rel="noopener">spaCy models</a> are just like any other machine learning or deep learning models. A model is a yield of an algorithm or, say, an object that is created after training data using a machine learning algorithm. spaCy has lots of such models that can be placed directly in our program by downloading it just like any other Python package.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python -m spacy download zh_core_web_lg</span><br><span class="line">python -m spacy download en_core_web_lg</span><br></pre></td></tr></table></figure><h3 id="POS-Tagging">POS Tagging</h3><p>Part-of-speech (POS) tagging is a process where you read some text and assign parts of speech to each word or token, such noun, verb, adjective, etc.<br>POS tagging becomes extremely important when you want to identify some entity in a given sentence. The first step is to do POS tagging and see what our text contains.<br>Let’s get our hands dirty with some of the examples of real POS tagging.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'zh_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">'明天的天气如何？'</span>)</span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">    print(token.text, token.pos_)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">明天 NOUN</span><br><span class="line">的 PART</span><br><span class="line">天气 NOUN</span><br><span class="line">如何 VERB</span><br><span class="line">？ PUNCT</span><br></pre></td></tr></table></figure><h3 id="Stemming-and-Lemmatization">Stemming and Lemmatization</h3><p><strong>Stemming</strong> is the process of reducing inflected words to their word stem, base form.<br>A stemming algorithm reduces the words “saying” to the root word “say”, whereas “presumable” becomes “presum”. As you can see, this may or may not always be 100% correct.<br><strong>Lemmatization</strong> is closely related to <strong>stemming</strong>, but lemmatization is the algorithmic process of determining the lemma of a word based on its intended meaning.<br>spaCy doesn’t have any in-built stemmer, as lemmatization is considered more correct and productive. (spaCy 没有内置的词干提取器，因为词形还原被认为更加准确和有效。)<br>Difference between Stemming and lemmatization:</p><ul><li><strong>Stemming</strong> does the job in a crude, heuristic way that chops off the ends of words, assuming that the remaining word is what we are actually looking for, but it often includes the removal of derivational affixes.</li><li><strong>Lemmatization</strong> tries to do the job more elegantly with the use of a vocabulary and morphological analysis of words. It tries its best to remove inflectional endings only and return the dictionary form of a word, konwn as the lemma.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> nltk.stem.porter <span class="keyword">import</span> PorterStemmer</span><br><span class="line">stemmer = PorterStemmer()</span><br><span class="line"><span class="keyword">for</span> w <span class="keyword">in</span> [<span class="string">'went'</span>, <span class="string">'goes'</span>]:</span><br><span class="line">    print(w, stemmer.stem(w))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">went went</span><br><span class="line">goes goe</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'en_core_web_lg'</span>)</span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> nlp(<span class="string">'went goes'</span>):</span><br><span class="line">    print(token.text, token.lemma_)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">went go</span><br><span class="line">goes go</span><br></pre></td></tr></table></figure><p>Since you are pretty much aware what a stemming or lemmatization does in NLP, you should be able to understand that whenever you come across a situation where you need the root form of the word, you need to do lemmatization there. For example, it is often used in building search engines. You must have wondered how Google gives you the articles in search results that you meant to get even when the search text was not properly formulated.<br>This is where one makes use of lemmatization.<br>Imageine you search with the text, “When will the next season of Game of Thrones be releasing?”<br>Now, suppose the search engine does simple document word frequency matching to give you search results. In this case, the aforementioned query probably won’t match an article with a caption “Game of Thrones next season release date”.<br>If we do the lemmatization of the orginal question before going to matchh the input with the documents, then we may get better results.</p><h3 id="Named-Entity-Recognition">Named-Entity Recognition</h3><p><strong>NER</strong>, also known by other names like <strong>entity identification</strong> or <strong>entity extraction</strong>, is a process of finding and classifying <a href="https://en.wikipedia.org/wiki/Named_entity" target="_blank" rel="noopener">named entities</a> existing in the given text into pre-defined categories.<br>The NER task is hugely dependent on the knowledge base used to train the NE extraction algorithm, so it may or may not work depending upon the provided dataset it was trained on.<br>spaCy comes with a very fast entiry recognition model that is capable of identifying entity phrases from a given document. Entities can be of different types, such as person, location, organization, dates, numerals, etc. These entities can be accessed through .ents property of the doc object.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'zh_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">"欧盟拟向东南亚投资100亿欧元"</span>)</span><br><span class="line"><span class="keyword">for</span> ent <span class="keyword">in</span> doc.ents:</span><br><span class="line">    print(ent.text, ent.label_)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">欧盟 ORG</span><br><span class="line">东南亚 LOC</span><br><span class="line"><span class="number">100</span>亿欧元 MONEY</span><br></pre></td></tr></table></figure><h3 id="Stop-Words">Stop Words</h3><p>Stop words are high-frequency words like a, an, the, to and also that we sometimes want to filter out of a document before further processing. Stop words usually have little lexical content and do not hold much of meaning.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> spacy.lang.zh.stop_words <span class="keyword">import</span> STOP_WORDS</span><br><span class="line">print(list(STOP_WORDS)[:<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">[<span class="string">'岂止'</span>, <span class="string">'当即'</span>, <span class="string">'纵'</span>, <span class="string">'▲'</span>, <span class="string">'几经'</span>, <span class="string">'上来'</span>, <span class="string">'什麽'</span>, <span class="string">'假使'</span>, <span class="string">'×'</span>, <span class="string">'『'</span>]</span><br></pre></td></tr></table></figure><p>Tosee if a word is a stop word or not, you can use the nlp object of spaCy. We can use the nlp object’s is_stop attribute.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nlp.vocab[<span class="string">"的"</span>].is_stop</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="Dependency-Parsing">Dependency Parsing</h3><p>Dependency parsing is one of the more beautiful and powerful features of spaCy that is fast and accurate. The parser can also be used for sentence boundary detection and lets you iterate over base noun phrases, or “chunks”.<br>This feature of spaCy gives you a parsed tree that explains the parent-child relationship between the words or phrases and is indenpendent of the order in which words occur.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'en_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">"Book me a flight from Bangalore to Goa"</span>)</span><br><span class="line">print(doc[<span class="number">5</span>], list(doc[<span class="number">5</span>].ancestors))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">Bangalore [<span class="keyword">from</span>, flight, Book]</span><br></pre></td></tr></table></figure><p>Ancestors are the rightmost token of this token’s syntactic descendants.<br>To check if a doc object item is an ancestor of another <em>doc</em> object item programmactically, we can do the following:<br><code>doc[3].is_ancestor(doc[5])</code><br>The above returns <code>True</code> because doc[3] (i.e., flight) is an ancestor of doc[5] (i.e., Bangalore).</p><p>Children are immediate syntactic dependents of the token. We can see the children of a word by using children attribute just like we used ancestors.<br><code> list(doc[3].children)</code> will output <code>[a, from, to]</code></p><p>Dependency parsing is one the most important parts when building chatbots from scratch. It becomes far more important when youn want to figure out the meaning of a text input from your user to your chatbot. There can be cases when you haven’t trained your chatbots, but still you don’t want to lose your customer or reply like a dumb machine.<br>In these cases, dependency parsing really helps to find the relation and explain a bit more about what the user may be asking for.<br>If we were to list things for which dependency parsing helps, some might be:</p><ul><li>It helps in finding relationships between words of grammatically correct sentences.</li><li>It can be used for sentence boundary detection.</li><li>It is quite useful to find out if the user is talking about more than one context simulationeously.<br>You need to write your own custom NLP to understand the context of the user or your chatbot and, based on that, identify the possible grammatical mistakes a user can meke.</li></ul><p>All in all, you must b ready for such scenarious where a user will input garbage values or grammatically incorrect sentences. You can’t handle all such scenarios at once, but you can keep improve you chatboot by adding custom NLP code or by limiting user input by design.</p><h3 id="Noun-Chunks">Noun Chunks</h3><p>Noun chunks or NP-chunking are basically “base noun phrases”. We can say they are flat phrases that have anoun as their head. You can think of noun chunks as a noun with the words describing the noun.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'en_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">"Boston Dynamics is gearing up to produce thousands of robot dogs"</span>)</span><br><span class="line">print(list(doc.noun_chunks))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">[Boston Dynamics, thousands, robot dogs]</span><br></pre></td></tr></table></figure><p><strong>The ‘noun_chunks’ syntax iterator is not implemented for language 'zh’</strong></p><h3 id="Finding-Similarity">Finding Similarity</h3><p>Finding similarity between two words is a use-case you will find most of the time working with NLP. Sometimes it becomes fairly important to find if two words are similar. While building chatbots you will often come to situations where you don’t have to just find similar-lokking words but also how closely related two words are logically.<br>spaCy uses high-quality word vectors to find similarity between two words using <strong>GloVe algorithm</strong> (Global Vectors for Word Representation).<br>GloVe is an unsupervised learning algorithm for obtaining vector representations for words. GloVe algorithm uses aggregated global word-word co-occurrence statistics from a corpus to train the model.</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'zh_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">"美团小贷注册资本增至75亿元"</span>)</span><br><span class="line"><span class="keyword">for</span> token <span class="keyword">in</span> doc:</span><br><span class="line">     print(token.text, token.vector[:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Output #</span><br><span class="line">美团 [<span class="number">-0.78366</span>  <span class="number">0.31008</span> <span class="number">-1.0793</span>  <span class="number">-0.87563</span>  <span class="number">0.56224</span>]</span><br><span class="line">小贷 [ <span class="number">1.0563</span>  <span class="number">-2.695</span>   <span class="number">-0.44203</span>  <span class="number">0.98277</span> <span class="number">-4.8158</span> ]</span><br><span class="line">注册 [ <span class="number">3.4941</span> <span class="number">-2.8909</span> <span class="number">-4.572</span>  <span class="number">-2.0436</span> <span class="number">-1.9986</span>]</span><br><span class="line">资本 [ <span class="number">3.8849</span>  <span class="number">0.3031</span> <span class="number">-2.382</span>   <span class="number">2.8471</span> <span class="number">-2.7938</span>]</span><br><span class="line">增至 [ <span class="number">1.469</span>   <span class="number">1.0054</span>  <span class="number">5.4963</span>  <span class="number">1.8396</span> <span class="number">-3.7624</span>]</span><br><span class="line"><span class="number">75</span>亿 [ <span class="number">0.3056</span>   <span class="number">0.69498</span>  <span class="number">1.4444</span>   <span class="number">0.91454</span> <span class="number">-0.97031</span>]</span><br><span class="line">元 [ <span class="number">2.8509</span>  <span class="number">-0.53181</span> <span class="number">-2.646</span>   <span class="number">-0.5862</span>  <span class="number">-4.0398</span> ]</span><br></pre></td></tr></table></figure><p>Seeing this output, it doesn’t make much sense and meaning. From an application’s perspective, what matters the most is how similar the vectors of different words are – that is, the word’s meaning itself.<br>In order to find similarity between two words in spaCy, we can do the following.</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'en_core_web_lg'</span>)</span><br><span class="line"><span class="builtin-name">print</span>(nlp(<span class="string">"car"</span>).similarity(nlp(<span class="string">"truck"</span>)))</span><br><span class="line"><span class="builtin-name">print</span>(nlp(<span class="string">"car"</span>).similarity(nlp(<span class="string">"plane"</span>)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line">0.7760473774094219</span><br><span class="line">0.4592993678544094</span><br></pre></td></tr></table></figure><p>The word ‘car’ is more related and similar to the word ‘truck’ than the word ‘plane’.<br>We can also get the similarity between sentences.</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> spacy</span><br><span class="line"><span class="attr">nlp</span> = spacy.load('en_core_web_lg')</span><br><span class="line"><span class="attr">str1</span> = nlp(<span class="string">"When will next season of Game of Thrones be releasing?"</span>)</span><br><span class="line"><span class="attr">str2</span> = nlp(<span class="string">"Game of Thrones next season release date?"</span>)</span><br><span class="line">print(str1.similarity(str2))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output #</span></span><br><span class="line"><span class="number">0.8226084934378249</span></span><br></pre></td></tr></table></figure><p>As we can see in this example, the similarity between both of the sentences is about 82%, which is good enough to say that both of the sentences are quite similar, which is true. This can help us save a lot of time for writing custom code when build chatbots.</p><h3 id="Tokenization">Tokenization</h3><p>Tokenization is one of the simple yet basic concepts of NLP where we split a text into meaningful segments. spaCy first tokenizes the text (i.e., segments it into words and then punctuation and other things). A question might come to your mind: Why can’t I just use the built-in split method of Python language and do the tokenization? Python’s split method is just a raw method to split the sentence into tokens given a sepatator. It doesn’t take any meaning into account, whereas tokenization tries to preserve the meaning as well.</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> spacy</span><br><span class="line">nlp = spacy.load(<span class="string">'zh_core_web_lg'</span>)</span><br><span class="line">doc = nlp(<span class="string">"告诉我处女座今天的运势"</span>)</span><br><span class="line">for tk <span class="keyword">in</span> doc:</span><br><span class="line">    print(tk.text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Output #</span><br><span class="line">告诉</span><br><span class="line">我</span><br><span class="line">处女座</span><br><span class="line">今天</span><br><span class="line">的</span><br><span class="line">运势</span><br></pre></td></tr></table></figure><p>If you are not satisfied with spaCy’s tokenization, you can use its <em>add_special_case</em> method to add your own rules before relying completely on spaCy’s tokenization method.</p><h3 id="Regular-Expressions">Regular Expressions</h3><p>You must already know about regular expressions and their usage.<br>Text analysis and processing is a big subject in itself. Sometimes words play together in a way that makes it extremely difficult for machines to understand and get trained upon.<br>Regular expression can come handy for some fallback for a machine learning model. It has the power of pattern-matching, which can ensure that the data we are processing is correct or incorrect. Most of the early chatbots were hugely dependent on pattern-matching.<br>Given the power of machine learning these days, regular expression and pattern-matching has taken a back step, but make sure you brush up a bit about it as it may be needed at any time to parse specific details from words, sentences, or text documents.</p><h2 id="The-Hard-Way">The Hard Way</h2><p>“Building Chatbots the Hard Way” is not to hard to learn. It’s the hard way of building chatbots to have full control over your own chatbots. If you want to build everything yourself, then you take the hard route. The harder route is hard when you go through it but beautiful and clear when you look back.</p><blockquote><p>It is a rough road that leads to the heights of etness. – Lucius Annaeus Seneca</p></blockquote><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install rasa==<span class="number">3.4</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><h3 id="构建Rasa机器人的步骤">构建Rasa机器人的步骤</h3><ul><li>初始化项目</li><li>准备NLU训练数据</li><li>准备故事story</li><li>定义领域domain</li><li>定义规则rule</li><li>定义动作action</li><li>配置config</li><li>训练模型</li><li>测试机器人</li><li>发布机器人</li></ul><h3 id="Building-a-Simple-Horoscope-Bot">Building a Simple Horoscope Bot</h3><p>Let’s decide the scope of this chatbot and see what it does and can do.</p><ul><li>The Horoscope Bot should be able to understand greetings and reply with a greeting.</li><li>The bot should be able to understand if there user is asking for horoscope.</li><li>The bot should be able to ask the horoscope sign of the user if the user doesn’t provide it.</li><li>The bot should learn from existing responses to formulate a new response.<br>It is pretty simple what our bot is supposed to do here.</li></ul><p>Possible intents</p><ul><li>Greeting Intent: User starting with a greeting</li><li>Get Horoscope Intent: User asking for horoscope</li><li>User’s Horoscope Intent: User telling the horoscope sign</li></ul><p>We’ll try to build the bot that does the basic task of giving a horoscope.<br>Let’s create a possible conversation script between our chatbot and the user.</p><pre><code>User: HelloBot: 你好，有什么能帮到你？User: 看一下今年的运势Bot: 想查哪个星座的运势?User: 双鱼的Bot: 由于天王星的逆行，可能会打乱双鱼座的节奏，所以双鱼座本年要懂得韬光养晦，要努力的去沉淀自己...</code></pre><p>This conversation is just to have a fair idea of how our chatbot conversation is going to look.<br>We can have our chatbot model itself trained to prepare a valid response instead of writing a bunch of <code>if ... else</code> statements.</p><h4 id="Initializing-the-bot">Initializing the bot</h4><p>Let’s init our bot.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/chatBot</span><br><span class="line">rasa init --no-prompt</span><br></pre></td></tr></table></figure><h4 id="Preparing-data">Preparing data</h4><p>First, prepare the <strong>nlu</strong> data. (nlu负责意图提取和实体提取)<br>The following is what my <strong><code>nlu.yml</code></strong> under <strong>data</strong> folder looks like:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">nlu:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">greet</span></span><br><span class="line">    <span class="attr">examples:</span> <span class="string">|</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hi</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">hello</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">goodbye</span></span><br><span class="line">    <span class="attr">examples:</span> <span class="string">|</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">bye</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">goodbye</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">    <span class="attr">examples:</span> <span class="string">|</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">查一下[今天](date_time)的运势</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">看一下[狮子座](horoscope_sign)如何</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">info_date_time</span></span><br><span class="line">    <span class="attr">examples:</span> <span class="string">|</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">[今日](date_time)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">[明天](date_time)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">info_horoscope_sign</span></span><br><span class="line">    <span class="attr">examples:</span> <span class="string">|</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">[白羊](horoscope_sign)</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">[金牛](horoscope_sign)</span></span><br></pre></td></tr></table></figure><p>Then, prepare the <strong>stories</strong> data (Rasa是通过学习story的方式来学习对话管理知识).<br>The following is what my <strong><code>stories.yml</code></strong> under <strong>data</strong> folder looks like:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stories:</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">story:</span> <span class="string">greet</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">greet</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">utter_greet</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">story:</span> <span class="string">say</span> <span class="string">goodbye</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">goodbye</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">utter_goodbye</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">story:</span> <span class="string">get</span> <span class="string">horoscope</span></span><br><span class="line">  <span class="attr">steps:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">or:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">      <span class="attr">entities:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">horoscope_sign:</span> <span class="string">双鱼</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">      <span class="attr">entities:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">date_time:</span> <span class="string">今天</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">      <span class="attr">entities:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">horoscope_sign:</span> <span class="string">双鱼</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">date_time:</span> <span class="string">今天</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">horoscope_form</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="string">horoscope_form</span></span><br></pre></td></tr></table></figure><p>Then, prepare the <strong>domain</strong> data (domain定义了chatbot需要知道的所有信息，包括intent, entity, slot, action, form, response).<br>The following is what my <strong><code>domain.yml</code></strong> under project root looks like:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">intents:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">greet</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">goodbye</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">get_horoscope</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">info_date_time</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">info_horoscope_sign</span></span><br><span class="line"></span><br><span class="line"><span class="attr">entities:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">date_time</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">horoscope_sign</span></span><br><span class="line"></span><br><span class="line"><span class="attr">slots:</span></span><br><span class="line">  <span class="attr">date_time:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">text</span></span><br><span class="line">    <span class="attr">influence_conversation:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">mappings:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">entity:</span> <span class="string">date_time</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">from_entity</span></span><br><span class="line">        <span class="attr">conditions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="string">horoscope_form</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">horoscope_sign:</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">text</span></span><br><span class="line">    <span class="attr">influence_conversation:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">mappings:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">entity:</span> <span class="string">horoscope_sign</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">from_entity</span></span><br><span class="line">        <span class="attr">conditions:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="string">horoscope_form</span></span><br><span class="line"><span class="attr">responses:</span></span><br><span class="line">  <span class="attr">utter_greet:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">text:</span> <span class="string">"你好，有什么能帮到你？"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">utter_goodbye:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">text:</span> <span class="string">"再见"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">utter_ask_horoscope_sign:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">text:</span> <span class="string">"想查哪个星座的运势?"</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">utter_ask_date_time:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">text:</span> <span class="string">"想查今天、明天、本周、本月还是今年的运势？"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">actions:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">utter_greet</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">utter_goodbye</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">utter_ask_horoscope_sign</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">utter_ask_date_time</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">action_get_horoscope</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">action_default_fallback</span></span><br><span class="line"></span><br><span class="line"><span class="attr">forms:</span></span><br><span class="line">  <span class="attr">horoscope_form:</span></span><br><span class="line">    <span class="attr">ignored_intents:</span> <span class="string">[]</span></span><br><span class="line">    <span class="attr">required_slots:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">date_time</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">horoscope_sign</span></span><br><span class="line"></span><br><span class="line"><span class="attr">session_config:</span></span><br><span class="line">  <span class="attr">session_expiration_time:</span> <span class="number">60</span></span><br><span class="line">  <span class="attr">carry_over_slots_to_new_session:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>Then, prepare the <strong>rule</strong> (rule负责将问题分类映射到对应的动作上).<br>The following is what my <strong><code>rules.yml</code></strong> under <strong>data</strong> folder looks like:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">"3.1"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">rule:</span> <span class="string">activate</span> <span class="string">horoscope</span> <span class="string">form</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">intent:</span> <span class="string">get_horoscope</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">horoscope_form</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="string">horoscope_form</span></span><br><span class="line"></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">rule:</span> <span class="string">submit</span> <span class="string">form</span></span><br><span class="line">    <span class="attr">condition:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="string">horoscope_form</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">horoscope_form</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">active_loop:</span> <span class="literal">null</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">slot_was_set:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">requested_slot:</span> <span class="literal">null</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">action:</span> <span class="string">action_get_horoscope</span></span><br></pre></td></tr></table></figure><p>Then, prepare the <strong>action</strong> (action接收用户输入和对话状态信息，按照业务逻辑进行处理，并输出改变对话状态的事件和回复用户的消息).<br>The following is what my <strong><code>actions.py</code></strong> under <strong>actions</strong> folder looks like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionGetHoroscope</span><span class="params">(Action)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span> -&gt; Text:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"action_get_horoscope"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, dispatcher: CollectingDispatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">            tracker: Tracker,</span></span></span><br><span class="line"><span class="function"><span class="params">            domain: Dict[Text, Any])</span> -&gt; List[Dict[Text, Any]]:</span></span><br><span class="line"></span><br><span class="line">        date_time = tracker.get_slot(<span class="string">"date_time"</span>)</span><br><span class="line">        horoscope_sign = tracker.get_slot(<span class="string">"horoscope_sign"</span>)</span><br><span class="line"></span><br><span class="line">        dispatcher.utter_message(</span><br><span class="line">            text=json_object.get(horoscope_sign, &#123;&#125;) \</span><br><span class="line">                            .get(date_time, <span class="string">"抱歉，我目前无法找到您的运势"</span>)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ActionDefaultFallback</span><span class="params">(Action)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span> -&gt; Text:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"action_default_fallback"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        self,</span></span></span><br><span class="line"><span class="function"><span class="params">        dispatcher: CollectingDispatcher,</span></span></span><br><span class="line"><span class="function"><span class="params">        tracker: Tracker,</span></span></span><br><span class="line"><span class="function"><span class="params">        domain: Dict[Text, Any],</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span> -&gt; List[Dict[Text, Any]]:</span></span><br><span class="line">        dispatcher.utter_message(text=<span class="string">"我不明白您说的内容，请换个说法。"</span>)</span><br><span class="line">        <span class="keyword">return</span> [UserUtteranceReverted(), ]</span><br></pre></td></tr></table></figure><p>Then, prepare the <strong>config</strong>.<br>The following is what my <strong>config.yml</strong> under project root looks like:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">recipe:</span> <span class="string">default.v1</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh</span></span><br><span class="line"><span class="attr">pipeline:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SpacyNLP</span></span><br><span class="line">    <span class="attr">model:</span> <span class="string">zh_core_web_lg</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">SpacyTokenizer</span></span><br><span class="line">    <span class="attr">intent_tokenization_flag:</span> <span class="literal">False</span></span><br><span class="line">    <span class="attr">intent_split_symbol:</span> <span class="string">"_"</span></span><br><span class="line">    <span class="attr">token_pattern:</span> <span class="string">None</span></span><br><span class="line">  <span class="comment"># - name: WhitespaceTokenizer</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RegexFeaturizer</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">LexicalSyntacticFeaturizer</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CountVectorsFeaturizer</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">CountVectorsFeaturizer</span></span><br><span class="line">    <span class="attr">analyzer:</span> <span class="string">char_wb</span></span><br><span class="line">    <span class="attr">min_ngram:</span> <span class="number">1</span></span><br><span class="line">    <span class="attr">max_ngram:</span> <span class="number">4</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">DIETClassifier</span></span><br><span class="line">    <span class="attr">epochs:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">constrain_similarities:</span> <span class="literal">true</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">EntitySynonymMapper</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ResponseSelector</span></span><br><span class="line">    <span class="attr">epochs:</span> <span class="number">100</span></span><br><span class="line">    <span class="attr">constrain_similarities:</span> <span class="literal">true</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">FallbackClassifier</span></span><br><span class="line">    <span class="attr">threshold:</span> <span class="number">0.3</span></span><br><span class="line">    <span class="attr">ambiguity_threshold:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">policies:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">MemoizationPolicy</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">TEDPolicy</span></span><br><span class="line">    <span class="attr">max_history:</span> <span class="number">5</span></span><br><span class="line">    <span class="attr">epochs:</span> <span class="number">200</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">RulePolicy</span></span><br><span class="line">    <span class="attr">core_fallback_threshold:</span> <span class="number">0.5</span></span><br><span class="line">    <span class="attr">core_fallback_action_name:</span> <span class="string">action_default_fallback</span></span><br><span class="line">    <span class="attr">enable_fallback_prediction:</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h4 id="Training">Training</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rasa train</span><br></pre></td></tr></table></figure><h4 id="Test">Test</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rasa <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>Ok, if everything goes well, we’ve got a simple chatbot out there.</p><h4 id="Run">Run</h4><p>Run an action server.</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rasa <span class="built_in">run</span> actions <span class="comment">--actions actions.actions</span></span><br></pre></td></tr></table></figure><p>Run a shell</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rasa <span class="keyword">shell</span></span><br></pre></td></tr></table></figure><p>Let’s play with it in that shell.</p><p><img src="http://s3.mindex.xyz/blog/HandMades/5f12e717d8eb6d73616a80621a19ef31.png" alt="Test Case"></p><p>Try it out for yourself.</p><h2 id="References">References</h2><ul><li><a href="https://www.amazon.com/Building-Chatbots-Python-Language-Processing/dp/1484240952/" target="_blank" rel="noopener">Building Chatbots with Python</a></li><li><a href="https://www.amazon.cn/dp/B09T353ZJF" target="_blank" rel="noopener">RASA实战</a></li><li><a href="https://github.com/neo1989/chatbot" target="_blank" rel="noopener">chatbot-github</a></li></ul>]]></content>
    
    <summary type="html">
    
      Learn from what you&#39;ve done.
    
    </summary>
    
    
      <category term="HandMades" scheme="https://neo1989.net/categories/HandMades/"/>
    
    
      <category term="NLP" scheme="https://neo1989.net/tags/NLP/"/>
    
  </entry>
  
  <entry>
    <title>《AI 3.0》</title>
    <link href="https://neo1989.net/Notes/NOTE-AI3.0/"/>
    <id>https://neo1989.net/Notes/NOTE-AI3.0/</id>
    <published>2022-11-01T03:39:11.000Z</published>
    <updated>2023-01-13T03:01:21.750Z</updated>
    
    <content type="html"><![CDATA[<h2 id="若想对未来下注，先要厘清人工智能为何仍然无法超越人类智能">若想对未来下注，先要厘清人工智能为何仍然无法超越人类智能</h2><h3 id="智能是个手提箱">智能是个手提箱</h3><p>对于任何谈论人工智能的人来说，定义“人工智能”都是一个挑战。因为人工智能的核型概念——智能，仍然没有明晰的定义。针对蕾丝“智能”及其引申义，如“思想” “认知” “意识” “情感” 这样的词语，明斯基肠燥了 “手提箱式词汇” 这一术语，其意思是：每个词语就像是打包封装了不通含义的手提箱。人工智能就经过了“打包”，在不同的上下文中承担不同的含义。</p><p>大多数人会认同人类是智能的，而尘埃颗粒不是。同样的道理，我们普遍认为人类比虫子更加智能。对于人类智能，智商是在单一尺度上衡量的，但我们也会探讨智能的不同纬度，如情感、语言、空间、逻辑、艺术、社交等。因此，智能的定义可能是二元的（一个物体是或不是智能的）、在一个<a href="https://zh.m.wikipedia.org/zh-hans/%E8%BF%9E%E7%BB%AD%E7%BB%9F" target="_blank" rel="noopener">连续统</a>上（一个物体比另一个物体更智能），或者是多维的（一个人可以具有高语言智能和低情感智能）。确实，“智能”这个词语是一个满载的手提箱，而拉链就在随时可能撑破的边缘上。</p><h3 id="神经网络是现代人工智能的基础">神经网络是现代人工智能的基础</h3><p>20世纪80年代中期，依赖人类创建并反映特定领域专家知识规则的符号人工智能方法——专家系统，越来越暴露出自身的脆弱性：容易出错，且在面对新情况时往往无法进行一般化或适应性的处理。在分析这些系统的局限性时，研究人员发现，便携规则的人类专家实际上或多或少依赖于常识以便明智地行动。这种常识通常难以通过程序化的规则或逻辑推理来获取，而这种常识的缺乏严重限制了符号人工智能方法的广泛应用。简而言之，在经历了过度承诺、巨额的资金支持和媒体炒作的一轮周期之后，符号人工智能又将面临另一个人工智能的寒冬。</p><p>根据联结主义的支持者观点，智能的关键在于构建一个合适的计算结构以及系统从数据或现实世界的行为中进行学习的能力，这是受到了大脑的启发。突然之间，神经网络又流行起来。</p><h3 id="强弱人工智能之争">强弱人工智能之争</h3><p>尽管深度学习近年来取得了很大成功，但和迄今为止所有的人工智能实例一样，这些程序仍然只是所谓的“狭义”或“弱”人工智能的例子。此处的“狭义”和“弱”是用来形容哪些仅能执行一些狭义任务或一组相关任务的系统。AlphaGo可能是世界上最好的围棋玩家，但除此之外什么也做不了，它甚至不会玩跳棋、井字棋等游戏。谷歌翻译可以把英文的影评翻译成中文，但它无法告诉你影评者是否喜欢这部电影，更不用说让它自己来观看和评论电影了。</p><p>“狭义”和“弱”人工智能往往是与“强” “人类水平” “通用” 或 “全面” 人工智能（有时候也称作AGI，即通用人工智能）对比而言的，后者即那种我们在电影中常看到的，可做我们人类所能做的几乎所有的使其，甚至更多事情的智能。通用人工智能是人工智能领域研究最初的目标，但至今还没有创建出任何能够在通用意义上被称为“智能”的人工智能程序。该领域最近的一项研究表明：“一堆狭义智能永远也不会堆砌成一种通用人工智能。通用人工智能的实现不在于单个能力的数量，而在于这些能力间的整合。“</p><h2 id="视觉识别：始终是“看”起来容易“做”起来难">视觉识别：始终是“看”起来容易“做”起来难</h2><h3 id="从大脑识别到ConvNets识别">从大脑识别到ConvNets识别</h3><p><strong>大脑识别模式：</strong> 当人的眼镜聚焦于一个场景是，眼睛接收到的是有场景中的物体发出或其表面反射的不同波长的光，这些光线激活了视网膜上的细胞，本质上说是激活了眼睛后面的一个神经元网格。这些神经元通过位于眼睛后面的纤长的视觉神经来交流彼此的激活信息并将其传入大脑，最终激活位于大脑后部视皮层的神经元。视皮层大致是由一系列按层排列的神经元组成，就像婚礼蛋糕那样一层一层堆在一起，每一层的神经元都将其激活信息传递给下一层的神经元。</p><p><strong>ConvNets识别模式：</strong> C哦女N额头上由一些列模拟神经元组成，在这里，我还是将这些模拟神经元称为单元。每层中的单元为下一层的单元提供输入，当一个ConvNets处理一张图像时，每个单元都有一个特定的激活值——根据单元的输入及其连接权重计算所得的真实的数值。ConvNets的输入是一幅图像，即与图像每个像素的颜色和亮度一一对应的一个数值组。它的最终输出是网络对于每种类别（狗或猫）的置信度（0～100%）。我们的目标是让网络学会对输入图像所属的正确类别输出高置信度，对其他类别输出低置信度。这样，网络将了解输入图像的哪些特征对完成这项任务最有帮助。</p><h3 id="机器视觉智能的3个致命短板">机器视觉智能的3个致命短板</h3><p>如今，机器智能在ImageNet上的目标识别能力是否已经超越人类的争论众说纷纭。这一论断是基于人类的错误率约为5%，而机器的错误率接近2%的一个声明，这难道无法证明计算机在这项任务上的表现比人类更好吗？答案是否定的。</p><p>第一，当你读到“一台机器正确地识别了目标”时，你会认为，给定一张篮球的图像，机器会输出“篮球”这一结果；但在ImageNet竞赛中，正确地识别仅意味着正确类别出现在机器给出的前5个输出类别中。如果给机器输入一张篮球的图像，机器按顺序输出的是门球、比基尼、疣猪、篮球和搬家货车，即可被判定是正确识别。</p><p>第二，对于“人类在ImageNet上的识别错误率为5%”这个声明，其中的“人类”一词实际上表述得并不是非常准确，因为这一结果来自被试只有一个实验。</p><p>第三，当一个人说照片中有一条狗时，我们认为这是因为人类在图像中实际上看到了一条狗，但是如果ConvNets“说”图像中有狗时，也许知识图像中有一些其他对象，如网球、飞盘、被叼住的鞋子，这些对象在训练图像中往往与狗有关，而ConvNets在识别这些对象时就会假设图像中有一条狗。这类关联的结果往往会愚弄程序，使其做出误判。</p><h3 id="难以避免的长尾效应">难以避免的长尾效应</h3><p>知名的深度学习专家本吉奥说：“实事求是地讲，我们不可能对世界上的所有食物都进行标注，并一丝不苟地把每一个细节都解释给计算机听。” 这一情况由于长尾效应的存在而进一步恶化：人工智能系统可能要面临各种可能的意外情况，自动驾驶汽车在一天的行驶期间可能会遇到各种假设情况的可能性可以很好地说明这一现象。遇到红色交通灯或停车标志等都是常见的情况，被评定为具有高可能性；中等可能性的情况包括遇到碎玻璃或者风吹过来的塑料袋；不太常见的情况是自动驾驶汽车遇到了被水淹没的道路或者被雪遮挡住的车道标志，等等。</p><p>“长尾”这个术语来自统计学，其中包含的一长串可能性低，但却可能发生的情况被称为一个概率分布的“尾巴”，尾巴上的情况优势被称为“边缘情况”。人工智能在先是世界的大多数领域中都会面对这种长尾效应；现实世界的大部分时间通常是可预测的，但仍有一长串地概率的意外事件发生。如果我们的单纯依靠监督学习来提升人工智能系统对世界的认知，那么就会存在一个问题：尾部的情况并不经常出现在训练数据中，所以当遇到这些意外情况时，系统就会更容易出错。</p><h3 id="“新机器人三定律”">“新机器人三定律”</h3><ol><li><p>有用的人工智能<br>在考虑人工智能在我们社会中的作用时，我们很容易把注意力集中在不利的一面，但是，有必要记住，人工智能系统已经为社会带来了巨大好处，并且它们有潜力发挥更大的作用。</p></li><li><p>可解释的人工智能<br>在人工智能“自动决策制定”的情况下，任何一个影响公民的决策都需要提供其中所涉及的与逻辑有关的有意义信息，并且这些信息需要使用清晰明了的语言，以简洁、透明、易懂和易于访问的形式来沟通和传达，这打开了有关解释问题的闸门。</p></li><li><p>可信的人工智能<br>在赋予计算机“道德智能”方面的进展不能与其他类型智能的进展分开，真正的挑战是创造出能够真正理解它们所面临的场景的机器。换句话说，可信任的道德理性的一个先决条件时通用的尝试，而这，正如我们所见，即使在当今最好的人工智能系统中也是缺失的。</p></li></ol><h2 id="游戏与推理：开发具有更接近人类水平的学习和推理能力的机器">游戏与推理：开发具有更接近人类水平的学习和推理能力的机器</h2><h3 id="强化学习，让AlphoGo名声大噪的幕后推手">强化学习，让AlphoGo名声大噪的幕后推手</h3><p>在最纯粹的形势下，强化学习不需要任何被标记的训练样本。代替它的是一个智能体，既学习程序，在一种特定环境（通常是计算机仿真环境）中执行一些动作，并偶尔从环境中获得奖励，这些间歇出现的奖励是智能体从学习中获得的唯一反馈。</p><p>强化学习的目标是：让智能体自己学习并获得能对即将到来的奖励进行更好的预测的值，前提是智能体在采取相关行动后一直在做正确的选择。正如我们阿奎那道德，习得给定状态下特定动作的值通常需要经过许多次试错。</p><p>尽管计算机程序可能不会对一个吻或一局热情的“你是最棒的”做出反应，但是它可以被设置为能够对与这种赞美等价的奖励做出响应，比如向机器的内存中添加正数，然后算法会高速机器如何从自己的经验中学习。</p><p>强化学习的实践者几乎都会构建机器人和环境的模拟，然后在模拟世界而非在现实世界中执行所有的学习片段，然而，环境愈复杂和不可预测，讲机器人在模拟中学到的技能转移到现实世界的尝试就愈加难以成功。迄今为止强化学习最大的成功不是在机器人领域，而是在那些能够在计算机上进行完美模拟的领域，特别是游戏领域。</p><h3 id="好的游戏，可以从更好的猜测中学习猜测">好的游戏，可以从更好的猜测中学习猜测</h3><p>如果你是那个学习智能体，当前状态下某个动作是对你在选择某一动作并持续选择高价值动作的条件下，本片段结束后你将获得多少奖励的估计，那么，越接近这一片段的结尾，估值就越准确，因为在一个片段的结尾处，你能计算出你将获得的实际讲理！其中的诀窍是：假设网络在当前迭代的输出比上一次迭代的输出更接近于正确值，然后，通过反向传播学习调整网络权重，从而使得当前与先前迭代输出之间的差异最小化。</p><p>理查德·萨顿是这种方法的鼻祖之一，他把该方法称为：从猜测中学习猜测。我把它修改为：从更好的猜测中学习猜测。简而言之，强化学习不是将其输出与人类给定的标签进行比较，而是假设后续迭代给出的值比前面迭代给出的值更好，网络学习的是使其输出在一次迭代到下一次迭代的过程中保持一致。</p><h3 id="像人一样学会迁移">像人一样学会迁移</h3><p>在机器学习领域，迁移学习是一个充满前景的学习方法，它是指一个程序将其所学的关于一项任务的知识进行迁移，以帮助其获得执行不同的相关任务的能力。对于人类来说，迁移学习是自动进行的，比如，学会打乒乓球之后，我们就能讲其中的一些技巧进行迁移来帮助我们学习打羽毛球和网球；知道如何下西洋跳棋，也有助于我们学习国际象棋。</p><p>人类这种从一种任务到另一种任务的能力迁移看起来好不费劲，我们对所学知识进行泛化的能力正式思考的核心部分。因而，我们可以说，迁移学习的另一种表达就是学习本身。</p><p>与人类形成鲜明对比的是，当今人工智能领域中的大多数学习算法在相关的任务之间是不可迁移的。在这一点上，该领域离哈萨比斯所说的通用人工智能仍然有很远的距离。尽管迁移学习是目前机器学习从业者最活跃的研究领域之一，但这方面的研究仍然处于初级阶段。</p><h2 id="自然语言：让计算机理解它所“阅读”的内容">自然语言：让计算机理解它所“阅读”的内容</h2><h3 id="理解语言，理解我们赖以生存的隐喻">理解语言，理解我们赖以生存的隐喻</h3><p>理解语言，特别是理解其中隐含的部分，是人类智能的一个基本部分。图灵把他著名的图灵测试，构造为一场关于语言之生成和理解的比赛，这决非偶然。</p><p>语言常常是充满歧义的，极度依赖语境，而且通常语言沟通的各方需要具备大量共同的背景知识。与人工智能的其他领域一样，自然语言处理相关的研究在最初的几十年集中在符号化的、基于规则的方法上，就是那种给定语法和其他语言规则，并把这些规则应用到输入语句上的方法。这些方法并没有取得很好的效果，看来通过使用一组明确的规则来捕捉语言的微妙是行不通的。自动语音识别是深度学习在自然语言处理中的第一个重大成就，并且我敢说，这是迄今为止人工智能在所有领域中取得的最重要的成就。</p><p>在深度网络开始在计算机视觉和语音识别上“得心应手”后不久，自然语言处理的研究者就开始试着把它们应用于情感分析。</p><h3 id="破解机器翻译，攀登人工智能的天梯">破解机器翻译，攀登人工智能的天梯</h3><p>在线翻译系统可以为人们提供全天候的即时翻译服务，而且通常可以处理100多种不同的语言，但是，其水平仍然远低于优秀的人类翻译员。</p><p>机器翻译的原始方法依赖于人类制定规则的复杂集合，所以，它们相当脆弱，需要面对来自自然语言处理领域所面临的所有挑战。</p><p>从20世纪90年代开始，一种被称为“统计机器翻译”的新方法开始占据主导地位，此方法依赖于从数据而非从人类制定的规则中学习。</p><p>谷歌翻译可能是目前最为广泛使用的自动翻译程序，使用的是一种更加优越的基于深度学习的翻译方法，也就是神经机器翻译。</p><p>深度学习时代的机器翻译所取得的巨大成功是由大数据和快速计算造就的，但这种成功完全是基于对单个句子翻译水平的评估，而非篇幅更长的文章。</p><h3 id="阅读理解的关键不仅在于“提取答案”，还在于“具备常识”">阅读理解的关键不仅在于“提取答案”，还在于“具备常识”</h3><p>《星际迷航》或许给我们许多人都编织了一个梦想：能够向计算机询问任何事情，并且它可以做出准确、简洁和有用的回应。如果你使用过当今任意一款人工智能语音助手，如Siri、Alexa、Cortana、Google Now，你就会知道这个梦想还尚未实现——这些系统并不能理解我们所问的问题的含义。</p><p>虽然计算机目前已经可以准确地转述我们的请求，但我们的终极目标是：让计算机真正理解我们所问的问题的含义。这本质上是一种阅读理解任务，但目前计算机其实并不能完全读懂一个特定文本中字里行间的意思，也无法做到真正的推理，比起阅读理解，计算机能做到的应该叫做“答案提取”。答案提取对机器来说是一项有用的技能，事实上，答案提取也正是Alexa、Siri以及其他数字助理软件所需要做的：将接收道德问题转换为一个搜索引擎查询序列，然后从搜索结果中提取答案。</p><p>“提问-回答”的话题一直是自然语言处理研究的一个重点。若想正确回答这些问题，不仅需要答案提取的技能，还需要具备自然语言处理和常识推理的集成能力，以及一些必要的背景知识。尽管深度学习已近在语音识别、语言翻译、情感分析及自然语言处理的其他领域取得了一些非常显著的进展，但人类水平的语言处理能力仍然是一个遥远的目标。</p><h2 id="常识——人工智能打破意义障碍的关键">常识——人工智能打破意义障碍的关键</h2><h3 id="理解力是一种预测力，而预测力与我们的经历息息相关">理解力是一种预测力，而预测力与我们的经历息息相关</h3><p>我们都拥有心理学家所说的关于世界的重要方面的“心智模型”，这个模型基于的是我们掌握的物理学和生物学上的事实、因果关系和人类行为的知识，并揭示了世界是如何运作的。心智模型不仅能够使你预测在特定情况下可能会发生什么，还能让你想象如果特定事件发生将会引发什么。</p><p>我们通过核心物理知识来理解抽象概念。如果物理意义上的“温暖”概念在心理上被激活，例如，通过手持一杯热咖啡，这也会激活更抽象、隐喻层面上的“温暖”概念。如果我们对概念和情境的理解是使用心智模型来进行模拟的，那么，也许意识以及我们对自我的全部概念，都来自我们构建并模拟自己的心智模型的能力。</p><p>我们拥有的与物理感觉相关的概念可能会激活关于自我的抽象概念，后者通过神经系统的反馈，产生一种对自我的物理感知，你也可以将这里的“自我”称为意识。这种循环因果关系类似侯世达所说的意识的“怪圈”：“符号和物理层面相互作用，并颠倒了因果关系，符号似乎拥有了自由意志，并获得了推动例子运动的自相矛盾的能力。” 我们所谓的感知、分类、识别、泛化和联想都涉及我们对所经历过的情境进行抽象的行为。</p><h3 id="我们是否可以为机器赋予常识">我们是否可以为机器赋予常识</h3><p>在人工智能发展的早期阶段，机器学习和神经网络还尚未在该领域占主导地位，那时候，人工智能研究人员还在人工地对程序执行任务所需要的规则和知识编码，对他们来说，通过“内在构建”的方法来捕捉足够的人类常识以在机器中实现人类水平的只能，看起来是完全合理的。</p><p>当深度学习开始展示其一系列非凡的成功时，不管是人工智能领域的内行还是外行，大家都乐观地认为我们即将实现通用的、人类水平的人工智能了。然而，正如本书中反复强调的那样，随着深度学习系统的应用愈加广泛，其智能正逐渐露出“破绽”。即便是最成功的系统，也无法在其狭窄的专业领域之外进行良好的泛化、形成抽象概念或者学会因果关系。此外，它们经常会犯一些不像是人类会犯的错误，以及在对抗样本上表现出的脆弱性都表明：它们并不真正理解我们教给它们的概念。</p><p>要想令人工智能实现真正的进步，就需要让及其具备常识，但是，很多处于我们潜意识里的知识，我们甚至不知道自己拥有这些知识，或者说常识，却是我们人类所共有的，而且是在任何地方都没有记载的知识。这包括我们在物理学、生物学和心理学上的许多核心直觉知识，这些知识是所有我们关于世界的更广泛的知识的基础。如果你没有有意识地认识到自己知道什么，你就不能成为向一台计算机明确地提供这些知识的专家。</p><h2 id="思考6个关键问题，激发人工智能的终极潜力">思考6个关键问题，激发人工智能的终极潜力</h2><ol><li>自动驾驶汽车还要多久才能普及？</li><li>人工智能会导致人类大规模失业吗？</li><li>计算机能够具有创造性吗？</li><li>我们距离创建通用的人类水平AI还有多远？</li><li>我们应该对人工智能感到多恐惧？</li><li>人工智能中有哪些激动人心的问题还尚未解决？</li></ol><h2 id="Reference">Reference</h2><p>[1] <a href="https://book.douban.com/subject/35351678/" target="_blank" rel="noopener">AI 3.0</a></p>]]></content>
    
    <summary type="html">
    
      “现在的人工智能可以做什么，以及在未来几十年我们能从它们身上期待什么”。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>常见的记忆法</title>
    <link href="https://neo1989.net/CheatSheet/CHEATSHEET-memorization-techniques/"/>
    <id>https://neo1989.net/CheatSheet/CHEATSHEET-memorization-techniques/</id>
    <published>2022-09-23T06:56:52.000Z</published>
    <updated>2023-01-06T08:06:00.132Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">记忆法</th><th style="text-align:center">概述</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">反复出声读</td><td style="text-align:center">反复出声读自己想记的内容</td><td style="text-align:center">无须准备，简单易行</td><td style="text-align:center">过程中一旦出错，就会不小心把错误的内容给记下来。单单使用这种方法无法确定自己究竟有没有记住</td></tr><tr><td style="text-align:center">反复抄写</td><td style="text-align:center">反复抄写自己想记的内容</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">反复读同时抄写</td><td style="text-align:center">上述两种方法的结合</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">留出时间来复习</td><td style="text-align:center">确认一下自己之前记忆的是否牢固</td><td style="text-align:center">防止“一旦记住就再也不管了”的情况</td><td style="text-align:center">很容易忘记去复习</td></tr><tr><td style="text-align:center">记忆唤起</td><td style="text-align:center">遮住正确答案，努力会想，然后立刻确认自己的回答是否正确。多次重复这一过程。单词卡就是该方法的一种应用</td><td style="text-align:center">一旦记忆出现偏差，可以立刻修正。不会出现“自以为记住了但是其实没记住”的情况</td><td style="text-align:center">很难用来记忆那些无法一次性处理的信息，例如比较长的单词和文章</td></tr><tr><td style="text-align:center">SAFMEDS法</td><td style="text-align:center">全称为 Say All Fast Minute EveryDay Suffle，把问题卸载卡片的正面，答案写在卡片的背面，没图打乱卡片顺序后，在一分钟內用最快的速度回答卡片上的问题，并记录自己答对的题数，制作成图表</td><td style="text-align:center">能够一眼看出自己记住了多少内容，有助于提升积极性</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">间隔复习法</td><td style="text-align:center">逐渐拉长复习的间隔</td><td style="text-align:center">比单纯的复习记忆的更牢固</td><td style="text-align:center">需要安排并且记住复习的时间点，比较麻烦</td></tr><tr><td style="text-align:center">DWM(Day-Week-Month)法</td><td style="text-align:center">复习一天前、一周前和一个月前记忆过的内容</td><td style="text-align:center">复习的时间点更好记</td><td style="text-align:center">需要想一想一个月后的复习要如何安排</td></tr><tr><td style="text-align:center">35分钟模拟法</td><td style="text-align:center">以35分钟为一个模块，结合DWM法来复习</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">SRS笔记</td><td style="text-align:center">用一个笔记本来管理间隔复习的时间点和想要记忆的内容</td><td style="text-align:center">同上</td><td style="text-align:center">随着想要记忆的内容不断增加，笔记本会变得越来越厚</td></tr><tr><td style="text-align:center">SRS软件</td><td style="text-align:center">使用Anki、Logseq等SRS软件来记忆</td><td style="text-align:center">App会自动帮我们设定时间，且不会变厚</td><td style="text-align:center">需要电脑或手机</td></tr><tr><td style="text-align:center">短间隔复述法</td><td style="text-align:center">听到或看到想要记忆的内容，反复出声复述，并逐渐拉长复述的间隔时间</td><td style="text-align:center">无须准备，简单易行</td><td style="text-align:center">过程中一旦出错，就会不小心把错误的内容给记下来。单单使用这种方法无法确定自己究竟有没有记住</td></tr><tr><td style="text-align:center">自我测试法</td><td style="text-align:center">自己出一份试卷，然后自己作答</td><td style="text-align:center">一旦记忆出现偏差，可以立刻修正。不会出现“自以为记住了但是其实没记住”的情况</td><td style="text-align:center">出试卷很费功夫</td></tr><tr><td style="text-align:center">反复答题法</td><td style="text-align:center">反复回答简单的问题，达到记忆的目的</td><td style="text-align:center">能够发现自己记错或是记忆不准确的部分，及时修正。适合用力啊提高记忆的精确性和回想的速度</td><td style="text-align:center">容易厌烦。正确率提升后会逐渐失去动力</td></tr><tr><td style="text-align:center">LowFirst</td><td style="text-align:center">按照错误率从高到低的顺序来复习。剔除低错误率的项目以提高复习效率</td><td style="text-align:center">比间隔复习法的效率高</td><td style="text-align:center">计算错误率，安排复习时间的过程比较麻烦</td></tr><tr><td style="text-align:center">影像记忆法</td><td style="text-align:center">在脑中将想记的内容转换成影像来记忆</td><td style="text-align:center">记忆会更容易在脑内扎根</td><td style="text-align:center">不一定适合所有人。对于不熟练的人来说，想象的过程可能会很费时间</td></tr><tr><td style="text-align:center">联想记忆法</td><td style="text-align:center">想一想自己看到这些内容后首先联想到了什么，将二者联系起来记忆</td><td style="text-align:center">利用自己脑内产生的联想来记忆，会更容易一些</td><td style="text-align:center">不一定适合所有人。对于不熟练的人来说，联想的过程可能会很费时间</td></tr><tr><td style="text-align:center">谐音记忆法</td><td style="text-align:center">把想记的内容换成其他发音相似的字，变成不通的意思</td><td style="text-align:center">在记忆数字时使用这种方式，会比直接记忆更有效</td><td style="text-align:center">想谐音会比较麻烦</td></tr><tr><td style="text-align:center">关键词记忆法</td><td style="text-align:center">找到母语中发音比较相似的词，在想象中将二者联系起来</td><td style="text-align:center">在记忆数字和外语单词时是用这种方式，会比直接记忆更有效</td><td style="text-align:center">有时很难从母语中找到发音相似的词</td></tr><tr><td style="text-align:center">利用韵律来记忆</td><td style="text-align:center">-</td><td style="text-align:center">在记忆数字和外语单词时是用这种方式，会比直接记忆更有效</td><td style="text-align:center">对押韵不熟悉的人很难应用</td></tr><tr><td style="text-align:center">自我关联记忆法</td><td style="text-align:center">把想记的内容写到一篇与自己相关的文章中</td><td style="text-align:center">与自己相关的事物记忆起来会更容易</td><td style="text-align:center">写文章比较麻烦</td></tr><tr><td style="text-align:center">故事记忆法</td><td style="text-align:center">把想记的内容编成一个故事</td><td style="text-align:center">故事记忆起来会更容易一些</td><td style="text-align:center">编故事比较麻烦</td></tr><tr><td style="text-align:center">歌词记忆法</td><td style="text-align:center">把想记的内容编成一首歌</td><td style="text-align:center">伴随着旋律去记忆，印象会更深刻</td><td style="text-align:center">编歌词和旋律的过程比较麻烦</td></tr><tr><td style="text-align:center">首字母记忆法</td><td style="text-align:center">把想记的内容的首字母提取出来，串联成一个单词</td><td style="text-align:center">更好记一些，回想起来也更容易</td><td style="text-align:center">首字母组成的新单词有时候会很难拼写</td></tr><tr><td style="text-align:center">记忆桩</td><td style="text-align:center">把已知的事物（记忆桩）和想记的内容在想象中联系起来</td><td style="text-align:center">更好记一些，回想起来也更容易</td><td style="text-align:center">刚开始还不熟练的适合，这个想象的过程会花费不少时间</td></tr><tr><td style="text-align:center">系统化记忆法</td><td style="text-align:center">通过重新归纳整理来记忆</td><td style="text-align:center">经过处理的信息很难忘记，还易于应用</td><td style="text-align:center">由于需要先理解，所以比较花时间</td></tr><tr><td style="text-align:center">类推记忆法</td><td style="text-align:center">通过上下文推测单词的意思，从而达到记忆的目的</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">记忆树</td><td style="text-align:center">以记忆的主题为树干，将相关的内容写到枝叶的位置上</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">凝缩笔记法</td><td style="text-align:center">像打小抄一样，把考试范围內的活字典全部都总结到一张小纸片上</td><td style="text-align:center">同上</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">康奈尔笔记法</td><td style="text-align:center">把笔记本上的一页分成三栏（正文、标题-评论、摘要），利用评论和摘要来复习</td><td style="text-align:center">同上，加入了复习机制，十分有效</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">互测法</td><td style="text-align:center">两个人分别出一份试卷，然后交换作答</td><td style="text-align:center">比自测法更高效</td><td style="text-align:center">需要一个学习伙伴</td></tr><tr><td style="text-align:center">交互式教学</td><td style="text-align:center">两个人一遍对话，一边使用预测、提问、总结和析疑四种策略来理解文章</td><td style="text-align:center">经过处理的信息很难忘记，还易于应用。在社会性相互作用下，使用过的信息会记得更牢固一些</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">情感关联法</td><td style="text-align:center">将内容与情感联系起来记忆</td><td style="text-align:center">情感越是强烈，与之相关的记忆就越牢固</td><td style="text-align:center">激发感情是一件难事</td></tr><tr><td style="text-align:center">情景记忆法</td><td style="text-align:center">将能够用到这些内容的场景还原出来，在场景下记忆</td><td style="text-align:center">还原的场景与实际场景越相似，回忆起来就越容易</td><td style="text-align:center">如果还原不出相似的场景，那就能难使用这个方法</td></tr><tr><td style="text-align:center">早期学习状态重置法</td><td style="text-align:center">回想第一次学汉子、骑自行车、背乘法口诀时的场景，将自己还原到当时的状态中</td><td style="text-align:center">这样能够重拾记忆力旺盛的心理状态</td><td style="text-align:center">效果具体如何尚不明确</td></tr><tr><td style="text-align:center">极端状态法</td><td style="text-align:center">把自己放到一种极端的状态下</td><td style="text-align:center">当自己所拥有的只是在新的环境完全派不上用场时，为了能够生存，学习效率会大幅提升</td><td style="text-align:center">可能对注意力的集中有危害</td></tr><tr><td style="text-align:center">张贴记忆法</td><td style="text-align:center">把想记的内容贴在自己平时经常会看到的地方</td><td style="text-align:center">把记忆需要付出的努力最小化</td><td style="text-align:center">效率不高，需要做一定的准备</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      理解是最棒的记忆法
    
    </summary>
    
    
      <category term="CheatSheet" scheme="https://neo1989.net/categories/CheatSheet/"/>
    
    
      <category term="SoftSkills" scheme="https://neo1989.net/tags/SoftSkills/"/>
    
  </entry>
  
  <entry>
    <title>《软件架构师的12项修炼》</title>
    <link href="https://neo1989.net/Notes/NOTE-12-more-essential-skills-for-software-architects/"/>
    <id>https://neo1989.net/Notes/NOTE-12-more-essential-skills-for-software-architects/</id>
    <published>2022-02-08T08:32:37.000Z</published>
    <updated>2023-01-13T02:59:38.641Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Project-Skills">Project Skills</h2><h3 id="Partnership">Partnership</h3><p>The road to partnerships begins with</p><ul><li>Establishing alignment<ul><li>Finding the right partners</li><li>Finding the thought leaders</li><li>Knowing the influencers</li><li>Establishing trusted advisers</li><li>Leveraging community review</li><li>Aligning a shared vision</li></ul></li><li>Establishing trust<ul><li>Establishing open disclosure</li><li>Avoiding overcommitment</li><li>Learning to occasionally say no</li></ul></li><li>Establishing context<ul><li>Understanding the nature of the partnership</li><li>Being knowledgeable of the business context</li><li>Framing technical decisions with a partnership</li><li>Realizing that technical decisions are political decisions</li><li>Learning to sell with a context</li><li>Having your partners’ backs</li><li>Realizing there is safety in numbers</li></ul></li><li>Establishing collaboration<ul><li>Bringing value to the table</li><li>Being willing to be a mentor and knowing when to seek a mentor</li><li>Recognizing oppourtunities</li><li>Enabling ideation</li></ul></li><li>Establishing relationships<ul><li>Being more than just about business</li><li>Making deposits before you begin withdrawing</li><li>Leveraging external relationships</li><li>Overcoming bad experiences from the past</li><li>Avoiding caustic members of the organization</li></ul></li></ul><h3 id="Discovery">Discovery</h3><p>The road to discovery begins with</p><ul><li>Understanding your customer<ul><li>Partnering with sales, marketing, and new product development</li><li>Visualizing your products from the vantage point of the customer</li><li>Preparing for customer visits</li><li>Meeting with customers</li><li>Recapping information learned from customer visits</li><li>Focusing on capturing the voice of the customer</li><li>Seeking to delight the customer</li></ul></li><li>Understanding the market in which your products compete<ul><li>Learning about your customers’ customers</li><li>Discovering where your customers are willing to spend money</li><li>Keeping an eye on the competition</li><li>Listening for themes across customers</li></ul></li><li>Understanding your business<ul><li>Learning what your business wants to do</li><li>Personalizing your company’s goal</li><li>Developing a business context for decision making</li></ul></li></ul><h3 id="Conceptualization">Conceptualization</h3><p>The road to conceptualization begins with</p><ul><li>Ideation with bussiness partnerships</li><li>Getting involved as early as possible in the process</li><li>Concept formulation<ul><li>Understanding the language of the customer</li><li>Developing domain models</li><li>Understanding the context of the customer</li><li>Committing cautiously when you are the new kid on the block</li><li>Visualizing the concept</li></ul></li><li>Concept reification<ul><li>Developing a minimum viable product</li><li>Experimenting with prototypes</li><li>Establishing assumptions</li><li>Establishing essential capabilities and customer roles</li><li>Reifying with customers</li></ul></li><li>Concept evolution<ul><li>Being a student of history</li><li>Embracing multiple perspectives</li><li>Recognizing adjacent opportunities</li></ul></li></ul><h3 id="Estimation">Estimation</h3><p>The road to estimation begins with</p><ul><li>Understanding the purpose of the estimate being sought</li><li>Understanding the project context</li><li>Understanding the estimating process</li><li>Developing an architectural approach</li><li>Knowing the estimating strategies and principles</li><li>Knowing how to bring it all together</li></ul><h3 id="Management">Management</h3><p>The road to management begins with</p><ul><li>Striving toward technology excellence</li><li>Delivering projects</li><li>Resolving issue</li><li>Partnering with executives</li><li>Managing your time</li><li>Grooming technical talent</li><li>Enhancing your skill set</li></ul><h2 id="Technology-Skills">Technology Skills</h2><h3 id="Platform-development">Platform development</h3><p>The road to platform development begins with</p><ul><li>Managing platform capabilities<ul><li>Defining the set of platform objectives</li><li>Defining the set of platform capabilities</li><li>Focusing on leverageable capabilities</li><li>Developing a strong conceptual model</li><li>Embracing APIs, configuration, and eventing as the keys to the platform</li></ul></li><li>Focusing on the platform ecosystem<ul><li>Konwing the platform users</li><li>Understanding platform ownership</li><li>Understanding platform management</li><li>Driving platform development</li><li>Acknowledging platform costs</li><li>Managing platform quality</li><li>Understanding platform integration</li></ul></li><li>Guiding the platform growth through principles</li></ul><h3 id="Architetectural-Perspective">Architetectural Perspective</h3><p>The road to architectural perspective begins with</p><ul><li>Knowing and understanding architectural principles</li><li>Knowing and understanding key areas of architectural concern</li><li>Creating architectural artifacts to bring clarity to what is being created</li></ul><h3 id="Governance">Governance</h3><p>The road to governance begins with</p><ul><li>Getting management support and sponsorship to do governance activities</li><li>Understanding and embrancing the governance and the underlying principles</li><li>Using governance as a mechanism to help guide both the architecture and its associated systems</li><li>Focusing on creating value for the business, not undue process</li></ul><p>The key is to find the right balance of governance and help mitigate risks, help reduce costs, and help promote leverage for the business.</p><h3 id="Know-how">Know-how</h3><p>The road to konw-how begins with</p><ul><li>Engaging in activities that increase your know-how</li><li>Expanding the basis of your knowledge</li><li>Staying current with the directions of the industry</li><li>Filling in any gaps that are critical to your area of responsibility</li><li>Staying passionate about software</li></ul><p>Software architecture is a great job and requires broad, active know-how to be successful in decision making. The great challenge is to balance the incessant demands on your time with the need to stay relevant. There will always be far more things to do than you can possibly get done. The keys are to</p><ul><li>Focus on what will provide high value to the business</li><li>Avoid major misses that will make executives unhappy</li><li>Follow the areas you are naturally passionate about</li><li>Surround yourself with experts and maintain a strong professional network</li></ul><h2 id="Visionary-Skills">Visionary Skills</h2><h3 id="Techology-Innovation">Techology Innovation</h3><p>The road to technology innovation begins with</p><ul><li>Being aware of the trends</li><li>Aligning with the business</li><li>Engaging in strategic research</li><li>Using innovation principles</li><li>Being a pragmatic technology innovator<br>Watching and following trends can be fun and exciting. They can easily distract you from the job at hand. However, they are also the eyes into the future that may provide opportunity or peril. Architects need to be familiar with the trends that are swirling around them and approach them with caution.<br>Technology innovation is a critical aspect of soft ware architecture. Learning when and where to introduce new and potentially disruptive technologies into the business is essential for business growth and operational stability.</li></ul><h3 id="Strategic-Roadmapping">Strategic Roadmapping</h3><p>The path to roadmapping begins with</p><ul><li>Understanding the elements of roadmapping</li><li>Leveraging the roadmapping strategies</li><li>Understanding the roadmapping principles</li><li>Knowing where roadmaps are best used</li><li>Being observant of new risks</li><li>Socializing the roadmap</li><li>Knowing your role in roadmap development</li><li>Celebrating milestone successes<br>For architects, roadmaps are an essential communication tool for helping to establish a vision of what needs to be accomplished and its approximate sequencing. When the business and architecture are on the same page regarding where a product or platform is going, this partnership can help propel the success of the business.</li></ul><h3 id="Entrepreneurial-Execution">Entrepreneurial Execution</h3><p>The road to entrepreneurial execution begins with</p><ul><li>Understanding the elements of entrepreneurial execution<ul><li>Entrepreneurial spirit</li><li>Calculated risk taking</li><li>Delivering results</li></ul></li><li>Using entrepreneurial execution principles as guidance<ul><li>Affordable Loss Principle</li><li>Lemonade Principle</li><li>Patchwork Quilt Principle</li><li>Bird-in-the-Hand Principle</li><li>Pilot-in-the-Plane Principle</li><li>Seize the moment</li><li>Follow your passion</li><li>Learn to pivot</li><li>Learn by doing and making mistakes</li><li>Seek feedback</li><li>Seek leverage</li></ul></li><li>Architecting with entrepreneurial execution</li></ul>]]></content>
    
    <summary type="html">
    
      The most complicated skill is to be simple.
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="SoftSkills" scheme="https://neo1989.net/tags/SoftSkills/"/>
    
  </entry>
  
  <entry>
    <title>The End Is Not the End, 2021</title>
    <link href="https://neo1989.net/SeizeTheDay/SUMMARY-2021/"/>
    <id>https://neo1989.net/SeizeTheDay/SUMMARY-2021/</id>
    <published>2021-12-31T14:12:00.000Z</published>
    <updated>2022-11-19T03:26:18.057Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>和喜欢的人，做喜欢的事，过喜欢的生活。</p></blockquote><h3 id="〖-2021-〗">〖 2021! 〗</h3><ul><li>第一次在上海过春节</li><li>三月去了趟甘南，司司不小心得急性肠胃炎</li><li>五月去了汤汕头南澳岛，司司不小心得感染(UTI)</li><li>拍到沪牌，入手Volvo V60</li><li>开始疯狂露营，疯狂收集落日</li><li>刻意<a href="/SeizeTheDay/FFF-weight-management/"><strong>低碳水饮食</strong></a>，狂瘦至62.0KG</li><li>着手幸会app的系统架构及AI端开发</li><li>上手opencv、ffmpeg，构建幸会app上的拍立得拼图及相遇视频自动生成</li><li>幸会app落地</li><li>国庆自驾了一圈西北环线</li><li>第一次乌镇戏剧节，参与《晚饭花》深夜诗歌朗诵，体验一般</li><li>年底连续长跑18次，尝试了一次10KM，似乎可以坚持</li></ul><h3 id="〖-2022-〗">〖 2022? 〗</h3><ul><li>继续深入AI方向</li><li>继续去探索世界</li></ul>]]></content>
    
    <summary type="html">
    
      The summary of 2021 and new year&#39;s resolution.
    
    </summary>
    
    
      <category term="SeizeTheDay" scheme="https://neo1989.net/categories/SeizeTheDay/"/>
    
    
  </entry>
  
  <entry>
    <title>认知偏差</title>
    <link href="https://neo1989.net/Notes/NOTE-cognitive-bias/"/>
    <id>https://neo1989.net/Notes/NOTE-cognitive-bias/</id>
    <published>2021-12-15T06:21:45.000Z</published>
    <updated>2023-01-13T03:01:29.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="决策、信念与行为偏差">决策、信念与行为偏差</h2><p>⚠️  这些偏差多半会影响信念的形成、商业与经济决策，以及其他一般的人类行为它们是可复制与再现的，面临特定情景时，一半可预期人们会有相应的偏差倾向。</p><h3 id="不明确效应-Ambiguity-Effect">不明确效应 Ambiguity Effect</h3><p>我们倾向于避免未知，决策时避开资讯不足的选项，通过添加明确的细节来最大程度地减少歧义，从而提高转化率。</p><h3 id="锚定效应-Anchoring-Effect">锚定效应 Anchoring Effect</h3><p>人类在进行决策时，会过度偏重先前取得的资讯（这称为锚点），即使这个资讯与这项决定无关。在进行决策时，人类倾向于利用此段资讯（锚点），快速做出决定。</p><h3 id="注意力偏差-Attention-Effect">注意力偏差 Attention Effect</h3><p>在检查所有可能的结果时，我们倾向于关注一些看起来合理且熟悉的事物，从而忽略了其他结果。</p><h3 id="获得性启发-Availability-Heuristic">获得性启发 Availability Heuristic</h3><p>我们认为那些迅速跃入脑海的事情比那些不容易想起的事情更为常见和重要。因此，最近发生的、频繁发生的、极端的、被记住的事情比大多数信息更有影响力。</p><h3 id="可获性层叠-Availability-Cascade">可获性层叠 Availability Cascade</h3><p>这个心理效用有一个更简单的描述，叫做三人成虎，也就是一件事越常被公开讨论，人们就越相信这件事情。</p><h3 id="逆火效应-Backfire-Effect">逆火效应 Backfire Effect</h3><p>我们不能轻易改变人们的信念：与根深蒂固的信念相反的证据和论据无济于事，只会巩固信念的地位。</p><h3 id="从众效应-Bandwagon-Effect">从众效应 Bandwagon Effect</h3><p>我们经常会因为大多数人以同一种方式思考，而改变我们自己的想法。</p><h3 id="信念偏差-Belief-Bias">信念偏差 Belief Bias</h3><p>我们更倾向于接受与我们的先验知识相符的论点，而拒绝对该论点的反驳。</p><h3 id="选择支持偏差-Choice-Supporitive-Bias">选择支持偏差 Choice-Supporitive Bias</h3><p>做出决定后，我们倾向于称赞我们选择的选项，然后降级其他选项。</p><h3 id="确认偏差-Confirmation-Bias">确认偏差 Confirmation Bias</h3><p>当人本来就持有某种观点时，对这种观点的感知和注意度会被放大，会选择性地会议或手机关于它的实例。人们对于自己原本就相信的观点会更容易接受，而把反面观点搁置在一旁。</p><h3 id="知识的诅咒-Curse-of-Knowledge">知识的诅咒 Curse of Knowledge</h3><p>当我们是某个领域的专家时，会不知不觉假设其他人和我们具有相同的理解能力，尤其是对于专业术语的使用。</p><h3 id="诱饵效应-Decoy-Effect">诱饵效应 Decoy Effect</h3><p>引入第三个选项来加强旧选项的吸引力。</p><h3 id="差异偏差-Distinction-Bias">差异偏差 Distinction Bias</h3><p>在有比较项存在时，我们对微小的差异变得敏感，而实际上，这些差异并不是很大。</p><h3 id="禀赋效应-Endowment-Effect">禀赋效应 Endowment Effect</h3><p>和没有拥有的物品相比，用户更倾向于保留自己拥有的物品。他们倾向于高估自己拥有的东西，而忽略其客观的市场价值。</p><h3 id="功能固有-Functional-Fixedness">功能固有 Functional Fixedness</h3><p>指个体在解决问题时往往只看到某种事物的通常功能，而看不到其他方面可能有的功能。这是人们长期以来形成的对某些事物的功能或用途的固定看法。</p><h3 id="巴纳姆效应-Barnum-Effect">巴纳姆效应 Barnum Effect</h3><p>也称佛瑞效应。人们会对于他们认为是为自己量身定制的一些人格描述给予高度准确的评价，而这些描述往往十分模糊及普遍，以致能够放诸四海而皆准适用于很多人身上。</p><h3 id="框架效应-Framing-Effect">框架效应 Framing Effect</h3><p>框架效应的意义是，面对同一个的问题，在使用不同的描述后，人们会选择乍听只在较有利或顺耳的描述作为方案。<br>（大多数情况下，正向表达的转化率更高）</p><h3 id="频率错觉-Frequency-Illusion">频率错觉 Frequency Illusion</h3><p>首次引起我们注意后，我们很快就会从很多地方注意到相关信息。<br>（如果某人想买一辆新车，通常会突然发现到处都是这辆车）</p><h3 id="后见之明偏差-Hindsight-Bias">后见之明偏差 Hindsight Bias</h3><p>后视偏见会让人沉迷与“我早就料到了”这种感受当中，无法真正从事件中汲取到有用的经验，也难以用公平的眼光来评判客观事物和他人，主观上也很容易选择性地忽略许多客观事实。</p><h3 id="当下偏差-Current-Moment-Bias">当下偏差 Current Moment Bias</h3><p>又称限时偏差，人们更倾向于获取即时收益，而非未来的更大收益。</p><h3 id="可辨识受害者效应-Identifiable-Victim-Effect">可辨识受害者效应 Identifiable Victim Effect</h3><p>我们倾向于同情一个特定的人而不是匿名的某一个人。</p><h3 id="宜家效应-IKEA-Effect">宜家效应 IKEA Effect</h3><p>宜家效应是指人们倾向于高度评价他们参与创造的产品，消费者对于一个物品付出的劳动（情感）越多，就越容易高估该物品的价值。</p><h3 id="影响力偏差-Impact-Bias">影响力偏差 Impact Bias</h3><p>我们倾向于高估未来情绪状态的持续时间或强度。</p><h3 id="资讯偏差-Information-Bias">资讯偏差 Information Bias</h3><p>因测量误差多导致的一种偏误现象，有时亦称为观察偏误或分组错误。</p><h3 id="沉默成本谬误-Sunk-Cost-Fallacy">沉默成本谬误 Sunk Cost Fallacy</h3><p>我们在某件事上投入越多就越难放弃它。因此，我们往往会继续执行这个走向失败的行动，仅仅是因为我们过去已经在此投入了过多的事件、金钱或精力。</p><h3 id="损失趋避-Loss-Aversion">损失趋避 Loss Aversion</h3><p>指人们面对同样数量的收益和损失时，认为损失更加令他们难以忍受。损失带来的负效用为收益正效用的2至2.5倍。损失厌恶反映了人们的风险偏好并不是一致的，当涉及的是收益时，人们表现为风险厌恶；当涉及的是损失时，人们则表现为风险寻求。</p><h3 id="单纯接触效应-Mere-Exposure-Effect">单纯接触效应 Mere Exposure Effect</h3><p>人们会单纯因为自己熟悉某个事物而产生好感。它表名某一外在刺激，仅仅因为呈现的次数越频繁（使个体能够接触到该刺激的机会越多），个体对该刺激就越喜欢。</p><h3 id="负面偏差-Negativity-Bias">负面偏差 Negativity Bias</h3><p>相比于中性或者积极的事物，具有负面影响的事物对人们的心理影响更大。<br>（通过解决负面体验来说明你的产品价值，如果希望自己的故事能够产生更大的影响，就要尝试多展现情感上负面的内容）</p><h3 id="忽略可能性-Neglect-of-Probability">忽略可能性 Neglect of Probability</h3><p>当我们承受压力时，我们没有想到风险发生的可能性。结果，较小的风险可能被高估或被忽略。</p><h3 id="乐观偏差-Optimism-Bias">乐观偏差 Optimism Bias</h3><p>与别人相比，我们经常高估自己成功的几率。</p><h3 id="鸵鸟效应-Ostrich-Effect">鸵鸟效应 Ostrich Effect</h3><p>我们故意避免负面信息（或与我们的期望不一致的反馈），认为如果我们把头埋在沙子里，它们就会消失。</p><h3 id="规划谬误-Planning-Fallacy">规划谬误 Planning Fallacy</h3><p>我们倾向于低估完成一项任务所需要的事件，通常规划谬误会导致时间超支，成本超支或收益不足。将大型任务分解为较小的部分有助于解决问题。</p><h3 id="对抗心理-Reactance">对抗心理 Reactance</h3><p>当我们感到某人（或某物）试图剥夺或限制我们的选择时，对抗心理就会发生。当他们发生时，我们有一种抵制它并采取相反行动的冲动。<br>（当你与用户“争论”他的选择时要小心，说服对方时必须循循善诱，永远不要与用户直接对抗。）</p><h3 id="自制偏差-Restraint-Bias">自制偏差 Restraint Bias</h3><p>人们经常会高估自己控制冲动行为的能力。<br>（我们都认为“标题党”属于旁门左道，但我们还是容易陷入其中，不是吗？）</p><h3 id="韵律当理由效应-Rhyme-as-Reason-Effect">韵律当理由效应 Rhyme as Reason Effect</h3><p>大部分广告语朗朗上口，非常洗脑。<br>（所以，尽可能的把你的产品文案变得有韵律感，这样更容易说服用户。）</p><h3 id="风险补偿-Risk-Compensation">风险补偿 Risk Compensation</h3><p>当我们感觉到更大的风险时，我们会变得更加谨慎，而当我们收到更多保护时，我们就会没那么多谨慎。所以当我们知道在已经采取了很多安全措施以后，我们更有可能采取冒险的方式行事。<br>（在购买或注册前让用户对产品产生尽可能的安全感）</p><h3 id="选择性知觉-Selective-Perception">选择性知觉 Selective Perception</h3><p>我们对事物的看法很大程度上受到期望的影响，当人们集中注意力时，人们会从环境中过滤掉事物。</p><h3 id="幸存者偏差-Survivorship-Bias">幸存者偏差 Survivorship Bias</h3><p>过度关注幸存下来的人或事物，忽略哪些被筛选掉的人或事物（可能因为无法观察到），从而得出错误的结论。</p><h3 id="零风险偏差-Zero-Risk-Bias">零风险偏差 Zero-Risk Bias</h3><p>我们喜欢确定性，即使它适得其反。在有其他方案可以降低整个风险的情形下，仍倾向于完全消除某一项风险的偏见。一个例子是可以降低个人负责领域的风险，可是代价是整个组织风险的上升。</p><h3 id="感知价值偏差-Perceived-Value-Bias">感知价值偏差 Perceived Value Bias</h3><p>我们根据产品的外观或服务方式来感知其价值。正如人们所说：全部在包装中！</p><h3 id="分析瘫痪-Analysis-Paralysis">分析瘫痪 Analysis Paralysis</h3><p>又称选择超载。当出现太多选择时，我们的大脑就会瘫痪，很难进行选择。<br>（选择太多 = 转换率低）</p><h3 id="稀缺效应-Scarcity-Effect">稀缺效应 Scarcity Effect</h3><p>我们将稀缺物品的价值提高，将高可用性物品的价值降低。 害怕错过（FOMO）是我们更容易收到诱惑和冲动，并促使我们做出轻率的决定。<br>（使用“限时优惠”，“有限数量”等修辞来形容你的产品或服务。）</p><h3 id="流畅性启发-Fluency-Heuristic">流畅性启发 Fluency Heuristic</h3><p>我们认为那些处理速度更快、更流畅、更顺利的事物具有更高的价值。有时不合逻辑的论点在沟通良好的情况下（由有权威和经验的人提出）也可能会赢得胜利。</p><h2 id="社会偏差">社会偏差</h2><p>⚠️  这些偏差大多是由归因偏差导致。</p><h3 id="行动者-观察者偏差-Actor-Observer-Bias">行动者-观察者偏差 Actor-Observer Bias</h3><p>行动者喜欢将他们自己的行为归因于情境性因素，而观察者喜欢将同样的行为归因于行动者稳定的人格素质。</p><h3 id="达克效应-Dunning-Kruger-Effect">达克效应 Dunning-Kruger Effect</h3><p>我们无法认识到我们缺乏能力，并且由于无法分辨能力好与能力差的不同，因而认为大家都一样。</p><h3 id="错误共识效应-False-Consensus-Effect">错误共识效应 False Consensus Effect</h3><p>人们倾向于高估别人对自己的认同程度，想象其他人像我们一样，并分享我们的观点，信念，偏好，价值观和习惯，认为所有人以同样的方式思考。</p><h3 id="基本归因谬误-Fundamental-Attribution-Error">基本归因谬误 Fundamental Attribution Error</h3><p>解释他人行为时，归因于内在特质（一定是他有这样的人格，才做出这样的行为），而非外在情景（也许是情势所迫，或这个场所特有的潜规则）。基本归因谬误是矛盾和问题的常见来源，而且这种认知偏差存在于用户也同样存在于设计师本身。</p><h3 id="晕轮效应-Halo-Effect">晕轮效应 Halo Effect</h3><p>晕轮效应是指使用一个人（或事物）的一种品质来对该人或事物进行整体判断，换句话说，我们对一个人、一个产品、一家公司或一个品牌的最初印象会影响我们对其整体特征的解读。</p><h3 id="群内效应-Ingroup-Effect">群内效应 Ingroup Effect</h3><p>群内偏差常被用来引导用户决策，它是指人们会在认知傻姑娘倾向于自己所属的群体。在体验设计中利用群内偏差的关键点在于打造群体归属感，借由小群体的力量影响用户的决策。</p><h3 id="权威偏见-Authority-Bias">权威偏见 Authority Bias</h3><p>我们认为权威人士给出的建议准确性更高，并且更容易受到该建议的影响（即使事物主题与该任务的权威性无关）</p><h3 id="得寸进尺法-Foot-in-the-Door-Technique">得寸进尺法 Foot-in-the-Door Technique</h3><p>通过先提出一个简单的小请求来说服用户同意一个较大请求的劝说。</p><h2 id="记忆错误与偏差">记忆错误与偏差</h2><p>⚠️  在心理学和认知科学中，记忆偏差是一种认知偏差，导致记忆的强化、弱化（包括能否想起的机会、想起所需的时间，或两者皆有），或者记忆内容的改变。</p><h3 id="谷歌效应-Google-Effect">谷歌效应 Google Effect</h3><p>我们会容易忘记可以从网上轻松找到的信息。</p><h3 id="幽默效应-Humor-Effect">幽默效应 Humor Effect</h3><p>当信息被认为是有趣或幽默时，我们会更好地记住信息。这可以帮助提高产品的转化率，并有助于整体业务的提升。</p><h3 id="真相错觉效应-Illusion-of-Truth-Effect">真相错觉效应 Illusion of Truth Effect</h3><p>重复的事情越多，我们就越相信。</p><h3 id="峰终法则-Peak-End-Rule">峰终法则 Peak-End Rule</h3><p>用户不仅仅根据平均或所有体验的综合来评估体验，取而代之的是，他们的大脑会严重地偏向峰值（高或低）和体验的终点，峰值如果是愉悦的话，通常对应了用户旅程中令人难忘的愉悦感。</p><h3 id="图片优势效应-Picture-Superiority-Effect">图片优势效应 Picture Superiority Effect</h3><p>图片和图像比一千个单词更容易被记住。</p><h3 id="首因效应-Primacy-Effect">首因效应 Primacy Effect</h3><p>又称近时效应、序位效应。列表开头和结尾的项目比中间的项目更容易被用户记住。</p><h3 id="雷斯多夫效应-Von-Restorff-Effect">雷斯多夫效应 Von Restorff Effect</h3><p>当很多信息一起呈现时，醒目的信息和被特变强调的信息会比其他信息更容易被人们记住。</p><h3 id="蔡格尼效应-Zeigarnik-Effect">蔡格尼效应 Zeigarnik Effect</h3><p>进行中的任务会产生特定于任务的张力。当任务完成时，这种压力可以缓解，但是如果任务被终端，它将保持不变，这种张力使相关信息更易于访问和记忆。<br>（显示一个不完整的进度栏，以鼓励用户实现自己的目标）</p><h2 id="统计与几率偏差">统计与几率偏差</h2><p>⚠️  几率性推论是指根据有关几率的资讯推论事情的可能，而几率的估算通常来自统计资料，因此两者密不可分。</p><h3 id="基本比率谬误-Base-Rate-Fallacy">基本比率谬误 Base Rate Fallacy</h3><p>我们倾向于忽略一般信息，而只关注特定案例。</p><h3 id="赌徒谬误-Gambler’s-Fallacy">赌徒谬误 Gambler’s Fallacy</h3><p>我们错误的认为，如果在给定时期内某件时期频繁发生，那么这件事情在将来发生的几率就会很小。</p><h3 id="热手谬误-Hot-Handy-Fallacy">热手谬误 Hot-Handy Fallacy</h3><p>错误地认为经历过成功的人更有可能在其他尝试中进一步获得成功。一般是在某人近来做某事很成功时，认为他未来做同一件事也会成功，而忽略其成功可能只是随机与巧合导致。</p><h3 id="对样本数不敏锐-Insensitivity-to-Sample-Size">对样本数不敏锐 Insensitivity to Sample Size</h3><p>我们经常忽略样本大小并贸然下结论，即使样本数量还未达到足够的统计量。</p><h2 id="实验与研究偏差">实验与研究偏差</h2><p>⚠️  这是一些科学实验与统计研究容易发生的偏差。</p><h3 id="取样偏差-Sampling-Bias">取样偏差 Sampling Bias</h3><p>某些类型的用户被无意中从研究参与者池中提出了。亦可以理解为以偏概全，即以局部事例解释整体原因。</p><h3 id="观察者期望效应-Observer-Expectancy-Effect">观察者期望效应 Observer-Expectancy Effect</h3><p>研究者有时可能会期望出现某种结果，他们无意识地操纵了实验过程，或者错误地解释实验结果，导致研究结果严重歪曲。</p><h3 id="社会期许偏差-Social-Desirability-Bias">社会期许偏差 Social Desirability Bias</h3><p>我们倾向于多表达复合社会期许的事情，而隐瞒那些不符合社会预期的事情。例如在询问是否有不良嗜好、性伴侣数量时，大家会有意无意地隐瞒或淡化实情。</p><h3 id="遗漏变数偏差-Omitted-Variable-Bias">遗漏变数偏差 Omitted-Variable Bias</h3><p>当获得的奖励出乎意料之外，我们获得奖励的喜悦感就会增加。</p><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://zh.wikipedia.org/wiki/%E8%AA%8D%E7%9F%A5%E5%81%8F%E8%AA%A4%E5%88%97%E8%A1%A8" target="_blank" rel="noopener">认知偏差列表</a><br>[2] <a href="https://s75w5y7vut.feishu.cn/docs/doccn3BatnScBJe7wD7K3S5poFf" target="_blank" rel="noopener">认知偏差知识手册</a></p>]]></content>
    
    <summary type="html">
    
      心理学词条。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
  </entry>
  
  <entry>
    <title>低碳水饮食实践</title>
    <link href="https://neo1989.net/SeizeTheDay/FFF-weight-management/"/>
    <id>https://neo1989.net/SeizeTheDay/FFF-weight-management/</id>
    <published>2021-09-05T03:02:34.000Z</published>
    <updated>2022-11-19T03:18:53.352Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="/SeizeTheDay/HEALTH-low-carb-diet/"><strong>低碳水饮食方法论</strong></a></p></blockquote><p><img src="http://s3.mindex.xyz/blog/SeizeTheDay/88a71e64f2b8bac8fc2b4aa5d33c2c5b.png" alt="Congrats!"></p>]]></content>
    
    <summary type="html">
    
      深度实践低碳水饮食
    
    </summary>
    
    
      <category term="SeizeTheDay" scheme="https://neo1989.net/categories/SeizeTheDay/"/>
    
    
      <category term="Health" scheme="https://neo1989.net/tags/Health/"/>
    
  </entry>
  
  <entry>
    <title>《Effective Python》</title>
    <link href="https://neo1989.net/Notes/NOTE-effective-python/"/>
    <id>https://neo1989.net/Notes/NOTE-effective-python/</id>
    <published>2021-08-10T11:00:20.000Z</published>
    <updated>2023-01-13T03:01:36.076Z</updated>
    
    <content type="html"><![CDATA[<h2 id="培养Pythonic思维">培养Pythonic思维</h2><h3 id="查询自己使用的Python版本">查询自己使用的Python版本</h3><ul><li>Python3是最新版的Python，而且受到了很好的支持，大家应该用Python3开发项目。</li><li>在操作系统的命令行界面运行Python时，要确认该Python的版本是否跟你要使用的版本相同。</li><li>不要再使用Python2做开发了，该版本已于2022年1月1日停止更新维护。</li></ul><h3 id="遵循PEP8风格指南">遵循PEP8风格指南</h3><ul><li>编写Python代码时，总是应该遵循PEP8风格指南。</li><li>与广大Python开发者同时采用同一套代码风格，可以使项目更利于多人协作。</li><li>采用一致的风格编写代码，代码的后续修改跟容易。</li></ul><h3 id="了解bytes与str的区别">了解bytes与str的区别</h3><ul><li>bytes包含的是由8bits所组成的序列，str包含的是由Unicode码点所组成的序列。</li><li>我们可以编写辅助函数来确保程序收到的字符序列确实是期望要操作的类型（要知道自己想操作的到底是Unicode码点，还是原始的8位值。用UTF-8标准给字符串编码，得到的就是这样的一系列8位值）。</li><li>bytes与str这两种实例不能再某些操作符（如&gt;、==、+、%等）上面混用。</li><li>从文件中读取二进制数据（或者写入二进制数据到文件）时，应该用’rb’ (‘wb’) 这样的二进制模式打开文件。</li><li>如果要从文件中读取（或者写入）的是Unicode数据，那么必须注意系统默认的文件编码方案。若无法肯定，可通过encoding参数明确指定。</li></ul><h3 id="用支持插值的f-string取代C风格的格式字符串与str-format方法">用支持插值的f-string取代C风格的格式字符串与str.format方法</h3><ul><li>采用%操作符把值填充到C风格的格式字符串时会遇到许多问题，而且这种写法比较繁琐。</li><li>str.format方法专门用一套迷你语言来定义它的格式说明符，这套语言给我们提供了一些有用的概念，但是在其他方面，这个方法还是存在与C风格的格式字符串一样的多种缺点，所以我们也应该避免使用它。</li><li>f-string是个简洁而强大的机制，可以直接在格式说明符里嵌入任意Python表达式。</li></ul><h3 id="用辅助函数取代复杂的表达式">用辅助函数取代复杂的表达式</h3><ul><li>Python的语法很容易把复杂的额意思挤到同一行表达式里，这样写很难懂。</li><li>复杂的表达式，尤其是那种需要重复使用的复杂表达式，应该写到辅助函数里面。</li><li>用if/else结构写成的条件表达式，要比用or与and写成的Bollean表达式更好懂。</li></ul><h3 id="把数据结构直接拆分到多个变量里，不要专门通过下表访问">把数据结构直接拆分到多个变量里，不要专门通过下表访问</h3><ul><li>unpacking是一种特殊的Python语法，只需要一行代码，就能把数据结构里面的多个值分别赋给相应的变量。</li><li>unpacking在Python中应用广泛，凡是可迭代的对象都能拆分，无论它里面还有多少层迭代结构。</li><li>尽量通过unpacking来拆解序列之中的数据，而不是通过下标访问，这样可以让代码更简洁、更清晰。</li></ul><h3 id="尽量用enumerate取代range">尽量用enumerate取代range</h3><ul><li>enumerate函数可以用简洁的代码迭代iterator，而且可以指出当前这轮循环的序号。</li><li>不要先通过range指定下标的取值范围，然后用下标去访问序列，而是应该直接用enumerate函数迭代。</li><li>可以通过enumerate的第二个参数指定起始序号（默认为0）。</li></ul><h3 id="用zip函数同时遍历两个迭代器">用zip函数同时遍历两个迭代器</h3><ul><li>内置的zip函数可以同时遍历多个迭代器。</li><li>zip会创建惰性生成器，让它每次只生成一个元组，所以无论输入的数据有多长，它都是一个一个处理的。</li><li>如果提供的迭代器的长度不一致，那么只要其中任何一个迭代完毕，zip就会停止。</li><li>如果想按最长的那个迭代器来遍历，那就改用内置的itertools模块中的zip_logngest函数。</li></ul><h3 id="不要在for与while的循环后面鞋else块">不要在for与while的循环后面鞋else块</h3><ul><li>Python有种特殊的语法，可以把else块紧跟在整个for循环或while循环的后面。</li><li>只有在整个循环没有因为break提前跳出的情况下，else块才会执行。</li><li>把else块紧跟在整个循环后面，会让人不太容易看出这段代码的意思，所以要避免这样写。</li></ul><h3 id="用赋值表达式减少重复代码">用赋值表达式减少重复代码</h3><ul><li>赋值表达式通过海象操作符（:=）给变量赋值，并且让这个值成为这条表达式的结果，于是，我们可以利用这项特性来缩减代码。</li><li>如果赋值表达式是大表达式里的一部分，就得用一对括号把它括起来。</li><li>虽说Python不支持switch/case与do/while，但可以利用赋值表达式清晰地模拟出这种逻辑。</li></ul><h2 id="列表与字典">列表与字典</h2><h3 id="学会对序列做切片">学会对序列做切片</h3><ul><li>切片要尽可能写得简单一些：如果从头开始选取，就省略起始下标0；如果选到序列序列末尾，就省略终止下标。</li><li>切片允许起始下标或终止下标越界，所以很容易就能表达“取开头多少个元素”（如a[:10]） 或 “取末尾多少个元素”（如a[-10:0]）等含义，而不用担心切片是否真有这么多元素。</li><li>把切片放在赋值符号的左侧可以将原列表中这段范围内的元素用赋值符号右侧的元素替换掉，但可能会改变原列表的长度。</li></ul><h3 id="不要在切片里同时指定起止下标与步进">不要在切片里同时指定起止下标与步进</h3><ul><li>同时指定切片的起止下标与步进值理解起来会很困难。</li><li>如果要指定步进值，那就省略起止下标，而且最好采用正数作为步进值，尽量别用负数。</li><li>不要把起始位置，终止位置与步进值全都写在同一个切片操作里。如果必须同时使用这三项指标，那就分两次来做（其中一次隔位选取，另一次做切割），也可以改用itertools内置模块里的islice方法。</li></ul><h3 id="通过带星号的unpacking操作来捕获多个元素，不要用切片">通过带星号的unpacking操作来捕获多个元素，不要用切片</h3><ul><li>拆分数据结构并把其中的数据赋给变量时，可以用带星号的表达式，将结构中无法与普通变量相匹配的内容捕获到一份列表里。</li><li>这种带星号的表达式可以出现在赋值符号左侧的任意位置，它总会形成一份含有零个或多个值的列表。</li><li>在把列表拆解成互相不重叠的多个部分时，这种带星号的unpacking方式比较清晰，而通过下标与切片来实现的方式则容易出错。</li></ul><h3 id="用sort方法的key参数来表示复杂的排序逻辑">用sort方法的key参数来表示复杂的排序逻辑</h3><ul><li>列表的sort方法可以根据自然顺序给其中的字符串、整数、元组等内置类型的元素进行排序。</li><li>普通对象如果通过特殊方法定义了自然顺序，那么也可以用sort方法来排列，但这样的对象并不多见。</li><li>可以把辅助函数传给sort方法的key参数，让sort根据这个函数所返回的值来排列元素顺序，而不是根据元素本身来排列。</li><li>如果排序时要依据的指标有很多项，可以把它们放在一个元组中，让key函数返回这样的元组。对于支持一元减操作符的类型来说，可以单独给这项指标取反，让排序算法在这项指标上按照相反的方向处理。</li><li>如果这些指标不支持一元减操作符，可以多次调用sort方法，并在每次调用时分别指定key函数与reverse参数。最次要的指标放在第一轮处理，然后逐步处理更为重要的指标，首要指标放在最后一轮处理。</li></ul><h3 id="不要过分依赖给字典添加条目时所用的顺序">不要过分依赖给字典添加条目时所用的顺序</h3><ul><li>从Python3.7版开始，我们就可以确信迭代标准的字典时所看到的顺序跟这些键值对插入字典时的顺序一致。</li><li>在Python代码中，我们很容易就能定义跟标准的字典很像但本身并不是dict实例的对象。对于这种类型的对象，不能假设迭代时看到的顺序必定与插入时的顺序相同。</li><li>如果不想把这种跟标准字典很相似的类型也当成标准字典来处理，那么可以考虑这样三种办法。<br>第一，不要依赖插入时的顺序编写代码；<br>第二，在程序运行时明确判断它是不是标准的字典；<br>第三，给代码添加类型注解并做静态分析。</li></ul><h3 id="用get处理键不在字典中的情况，不要使用in与KeyError">用get处理键不在字典中的情况，不要使用in与KeyError</h3><ul><li>有四种办法可以处理键不在字典中的情况：in表达式、KeyError异常、get方法与setdefault方法</li><li>如果跟键相关联的值是像计数器这样的基本类型，那么get方法就是最好的方案；如果是那种构造起来开销比较大，或是容易出异常的类型，那么可以把这个方法与赋值表达式结合起来使用。</li><li>即使看上去最应该使用setdefault方案，也不一定要真的使用setdefault方案，而是可以考虑用defalutdict取代普通的dict。</li></ul><h3 id="用defaultdict处理内部状态中缺失的元素，而不要用setdefault">用defaultdict处理内部状态中缺失的元素，而不要用setdefault</h3><ul><li>如果你管理的字典可能需要添加任意的键，那么应该考虑能否用内置的collections模块中的defaultdict实例来解决问题。</li><li>如果这种键名比较随意的字典是别人传给你的，你无法把它创建成defaultdict，那么应该考虑通过get方法访问其中的键值。然而，在个别情况下，也可以考虑改用setdefault方法，因为那样写更短。</li></ul><h3 id="学会利用-missing-构造依赖键的默认值">学会利用__missing__构造依赖键的默认值</h3><ul><li>如果创建默认值需要较大的开销，或者可能抛出异常，那就不适合用dict类型的setdefault方法实现。</li><li>传给setdefault的函数必须是不需要参数的函数，所以无法创建出需要依赖键名的默认值。</li><li>如果要构造的默认值必须根据键名来确定，那么可以定义自己的dict子类并实现__missing__方法。</li></ul><h2 id="函数">函数</h2><h3 id="不要把函数返回的多个数值拆分到三个以上的变量中">不要把函数返回的多个数值拆分到三个以上的变量中</h3><ul><li>函数可以把多个值合起来通过一个元组返回给调用者，以便利用Python的unpacking机制取拆分。</li><li>对于函数返回的多个值，可以把普通变量没有捕获到的那些值全都捕获到一个带星号的变量里。</li><li>把返回的值拆分到四个或四个以上的变量是很容易出错的，所以最好不要那么写，而是应该通过小类或namedtuple实例完成。</li></ul><h3 id="遇到意外状况时应该抛出异常，不要返回None">遇到意外状况时应该抛出异常，不要返回None</h3><ul><li>用返回值None表示特殊情况是很容易出错的，因为这样的值在条件表达式里面，每办法与0和空白字符串之类的值区分，这些值都想当与False。</li><li>用异常表示特殊的情况，而不要返回None。让调用这个函数的程序根据文档里写得异常情况做出处理。</li><li>通过类型注解可以明确禁止函数返回None，即便在特殊情况下，它也不能返回这个值。</li></ul><h3 id="了解如何在闭包里面使用外围作用域中的变量">了解如何在闭包里面使用外围作用域中的变量</h3><ul><li>闭包函数可以引用定义它们的那个外围作用域之中的变量。</li><li>按照默认的写法，在闭包里面给变量赋值并不会改写外围作用域中的同名变量。</li><li>出特别简单的函数外，尽量少用nonlocal语句。</li></ul><h3 id="用数量可变的位置参数给函数设计清晰的参数列表">用数量可变的位置参数给函数设计清晰的参数列表</h3><ul><li>用def定义函数时，可以通过 *args 的写法让函数接受数量可变的位置参数。</li><li>调用函数时，可以在序列左边加上 * 操作符，把其中的元素当成位置参数传给 *args 所表示的这一部分。</li><li>如果 * 操作符加在生成器前，那么传递参数时，程序有可能因为耗尽内存而崩溃。</li><li>给接受 *args 的函数添加新位置参数，可能导致难以排查的bug。</li></ul><h3 id="用关键字参数来表示可选行为">用关键字参数来表示可选行为</h3><ul><li>函数的参数可以按位置指定，也可以用关键字的形式指定。</li><li>关键字可以让每个参数的作用更加明了，因为在调用函数时只按位置指定参数，可能导致这些参数的含义不够明确。</li><li>应该通过带默认值的关键字参数来扩展函数行为，因为这部会影响原有的函数调用代码。</li><li>可选关键字参数总是应该通过参数名来传递，而不应按位置传递。</li></ul><h3 id="用None和docstring来描述默认值会变得参数">用None和docstring来描述默认值会变得参数</h3><ul><li>参数的默认值只会计算一次，也就是在系统把定义函数的那个模块加载进来的时候。所以，如果默认值将来可能由调用放修改（例如{}， []）或者要随着调用时的情况变化（例如datetime.now()），那么程序就会出现奇怪的效果。</li><li>如果关键字参数的默认值属于这种会发生变化的值，那就应该写成None，并且要在docstring里面描述函数此时的默认行为。</li><li>默认值为None的关键字参数，也可以添加类型注解。</li></ul><h3 id="用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表">用只能以关键字指定和只能按位置传入的参数来设计清晰的参数列表</h3><ul><li>Keyword-Only Arguments是一种只能通过关键字指定而不能通过位置指定的参数。这迫使调用者必须指明，这个值是传给哪一个参数的。在函数的参数列表中，这种参数位于 * 符号的右侧。</li><li>Positional-Only Arguments是这样一种参数，它不允许调用者通过关键字来指定，而是要求必须按照位置传递。这可以降低调用代码与参数名称之间的耦合程度。在函数的参数列表中，这些参数位于/符号的左侧。</li><li>在参数列表中，位于 / 与 * 之间的参数，可以按位置指定，也可以用关键字来指定。这也是Python普通参数的默认指定方式。</li></ul><h3 id="用functools-wraps定义函数修饰器">用functools.wraps定义函数修饰器</h3><ul><li>修饰器是Python中的一种写法，能够把一个函数封装在另一个函数里面，这样程序在执行原函数之前与执行完毕之后，就有机会执行其他一些逻辑了。</li><li>修饰器可能会让那些利用instropection机制运作的工具（例如调试器）产生奇怪的行为。</li><li>Python内置的functools模块里有个叫wraps的修饰器，可以帮助我们正确定义自己的修饰器，从而避开相关的问题。</li></ul><h2 id="推导与生成">推导与生成</h2><h3 id="用列表推导取代map与filter">用列表推导取代map与filter</h3><ul><li>列表推导要比内置的map与filter函数清晰，因为它不用另外定义lambda表达式。</li><li>列表推导可以很容易地跳过原列表中的某些数据，加入改用map实现，那么必须搭配filter才能实现。</li><li>字典与集合也可以通过推导来创建。</li></ul><h3 id="控制推导逻辑的子表达式不要超过两个">控制推导逻辑的子表达式不要超过两个</h3><ul><li>推导的适合可以使用多层循环，每层循环可以带有多个条件。</li><li>控制推导逻辑的子表达式不要超过两个，否则代码很难读懂。</li></ul><h3 id="用赋值表达式消除推导中的重复代码">用赋值表达式消除推导中的重复代码</h3><ul><li>编写推导式与生成器表达式时，可以在描述条件的那一部分通过赋值表达式定义变量，并在其他部分复用该变量，可使程序简单易读。</li><li>对于推导式与生成器表达式来说，虽然赋值表达式也可以出现在描述条件的那一部分之外，但最好别这么写。</li></ul><h3 id="不要让函数直接返回列表，应该让它逐个生成列表里的值">不要让函数直接返回列表，应该让它逐个生成列表里的值</h3><ul><li>用生成器来实现比让函数把结果收集到列表里再返回，要更加清晰一些。</li><li>生成器函数所返回的迭代器可以产生一系列值，每次产生的那个值都是由函数体的下一条yield表达式所决定的。</li><li>不管输入的数据量有多大，生成器函数每次都只需要根据其中的一小部分来计算当前这次的输出值。它不用把整个输入值全都读取进来，也不用一次就把所有的输出值全都算好。</li></ul><h3 id="谨慎地迭代函数所收到的参数">谨慎地迭代函数所收到的参数</h3><ul><li>函数和方法如果要把收到的参数遍历很多遍，那就必须特别小心。因为如果这些阐述为迭代器，那么程序可能得不到预期的值，从而出现奇怪的效果。</li><li>Python的迭代器协议确定了容器与迭代器应该怎样跟内置的iter及next函数、for循环及相关的表达式交互。</li><li>要想让自定义的容器类型可以迭代，只需要把__iter__方法实现为生成器即可。</li><li>可以把值传给iter函数，检测它返回的是不是那个值本身。如果是，就说明这是个普通的迭代器，而不是一个可以迭代的容器。另外也可以用内置的isinstance函数判断该值是不是collections.abc.Iteration类的实例。</li></ul><h3 id="考虑用生成器表达式改写数据量较大的列表推导">考虑用生成器表达式改写数据量较大的列表推导</h3><ul><li>通过列表推导来处理大量的输入数据，可能会占用许多内存。</li><li>改用生成器表达式来做，可以避免内存使用量过大的问题，因为这种表达式所形成的迭代器每次只会计算一项结果。</li><li>生成器表达式所形成的迭代器可以当成for语句的子表达式出现在另一个生成器表达式里面。</li><li>把生成器表达式组合起来使用，能够写出执行速度快且占用内存少的代码。</li></ul><h3 id="通过yield-from把多个生成器连起来用">通过yield from把多个生成器连起来用</h3><ul><li>如果要连续使用多个生成器，那么可以通过yield from表达式来风别使用这些生成器，这样做能够免去重复的for结构。</li><li>yield from的性能要胜过那种在for循环里手工编写yield表达式的方案。</li></ul><h3 id="不要用send给生成器注入数据">不要用send给生成器注入数据</h3><ul><li>send方法可以把数据注入生成器，让它成为上一条yield表达式的求值结果，生成器可以把这个结果赋给变量。</li><li>把send方法与yield from表达式搭配起来使用，可能导致奇怪的结果，例如会让程序在本该输出有效值的地方输出None。</li><li>通过迭代器向组合起来的生成器输入数据，要比采用send方法的那种方案好，所以尽量避免使用sendfangfa。</li></ul><h3 id="不要通过throw变换生成器的状态">不要通过throw变换生成器的状态</h3><ul><li>throw方法可以把异常发送到生成器刚执行过的那条yield表达式那里，让这个异常在生成器下次推进时重新抛出。</li><li>通过throw方法注入异常，会让代码变得难懂，因为需要用多成嵌套的模板结构来抛出并捕获这种异常。</li><li>如果确实遇到了这样的特殊情况，那么应该通过类的__iter__方法实现生成器，并且专门提供一个方法，让调用者通过这方法来触发这种特殊的状态变换逻辑。</li></ul><h3 id="考虑用itertools拼装迭代器与生成器">考虑用itertools拼装迭代器与生成器</h3><ul><li>itertools包里面有三套函数可以拼装迭代器与生成器，它们分别能够连接多个迭代器，过滤源迭代器中的元素，以及用源迭代器中的元素合成新元素。</li><li>通过help(itertools)查看文档，了解这些函数所支持的其他参数，以及许多更为高级的函数和实用的代码范例。</li></ul><h2 id="类与接口">类与接口</h2><h3 id="用组合起来的类来实现多层结构，不要用嵌套的内置类型">用组合起来的类来实现多层结构，不要用嵌套的内置类型</h3><ul><li>不要在字典里嵌套字典、长元组，以及用其他内置类型构造的复杂结构。</li><li>namedtuple能够实现出轻量级的容器，以存放不可变的数据，而且将来可以灵活地转化成普通的类。</li><li>如果发现用字典来维护内部状态的那些代码已经越写越复杂了，呢么就应该考虑改用多个类来实现。</li></ul><h3 id="让简单的接口接受函数，而不是类的实例">让简单的接口接受函数，而不是类的实例</h3><ul><li>如果想设计简单的Python接口，让组件之间能够通过接口交互，那么可以考虑让接口接受挂钩函数，而不一定非得定义新类，并要求使用者传入这种类的实例。</li><li>Python的函数与方法都是头等对象，这意味者它们可以像其他类型那样，用在表达式里。</li><li>某个类如果定义了__call__特殊方法，那么它的实例就可以像普通的Python函数那样调用。</li><li>如果想用函数来维护状态，那么可以考虑定义一个带有__call__方法的新类，而不要用有状态的闭包去实现。</li></ul><h3 id="通过-classmethod多态来构造同一体系中的各类对象">通过@classmethod多态来构造同一体系中的各类对象</h3><ul><li>Python只允许每个类有一个构造方法，也就是__init__方法。</li><li>如果想在超类中用通用的代码构造子类实例，那么可以考虑定义@classmethod方法，并在里面用cls(…)的形式构造具体的子类对象。</li><li>通过类方法多态机制，我们能够以通用的形式构造并拼接具体的子类对象。</li></ul><h3 id="通过super初始化超类">通过super初始化超类</h3><ul><li>Python有标准的方法解析顺序（MRO）规则，可以用来判定超类之间的初始化顺序，并解决菱形继承问题。</li><li>可以通过Python内置的super函数正确触发超类的__init__逻辑。一般情况下，不需要给这个函数指定参数。</li></ul><h3 id="考虑用mix-in类来表示可组合的功能">考虑用mix-in类来表示可组合的功能</h3><ul><li>超类最好能写成不带实例属性与__init__方法的min-in类，以避免由多重继承所引发的一些问题。</li><li>如果子类要定制（或者说修改）mix-in所提供的功能，那么可以自己的代码里面覆盖相关的实例方法。</li><li>根据需求，mix-in可以只提供实例方法，也可以只提供类方法，还可以同时提供这两种方法.</li><li>把每个mix-in所提供的简单功能组合起来，可以实现比较复杂的功能。</li></ul><h3 id="优先考虑用public属性表示应受保护的数据，不要用private属性表示">优先考虑用public属性表示应受保护的数据，不要用private属性表示</h3><ul><li>Python编译器无法绝对禁止外界访问private属性。</li><li>从一开始就应该考虑允许其他类能继承这个类，并利用其中的内部API与属性去实现更多功能，而不是把它们藏起来。</li><li>把需要保护的数据设计成protected字段，并用文档加以解释，而不要通过private属性限制访问。</li><li>只有在子类不受控制且名称有可能与超类冲突时，才可以考虑给超类设计private属性。</li></ul><h3 id="自定义的容器类型应该从collections-abc继承">自定义的容器类型应该从collections.abc继承</h3><ul><li>如果要编写的新类比较简单，那么可以直接从Python的容器类型（例如list或dict）里面继承。</li><li>如果想让定制的容器类型能像标准的Python容器那样使用，那么有可能要编写许多特殊方法。</li><li>可以从collections.abc模块里的抽象基类之中派生自己的容器类型，这样可以让容器自动具备相关的功能，同时又可以保证没有把实现这些功能所必备的方法给漏掉。</li></ul><h2 id="元类与属性">元类与属性</h2><h3 id="用纯属性与修饰器取代旧式的setter与getter方法">用纯属性与修饰器取代旧式的setter与getter方法</h3><ul><li>给新类定义接口时，应该从简单的public属性写起，避免定义setter与getter方法。</li><li>如果在访问属性时确实有必要做特殊的处理，那就通过@property来定义获取属性与设置属性的方法。</li><li>实现@property方法时，应该遵循最小惊讶原则，不要引发奇怪的副作用。</li><li>@property方法必须执行得很快。复杂或缓慢的任务，尤其是设计I/O或者会引发副作用的那些任务，还是用普通的方法来实现比较好。</li></ul><h3 id="考虑用-property实现新的属性访问逻辑，不要急着重构原有的代码">考虑用@property实现新的属性访问逻辑，不要急着重构原有的代码</h3><ul><li>可以利用@property给已有的实例属性增加新的功能。</li><li>可以利用@property逐渐改善数据模型而不影响已经写好的代码。</li><li>如果发现@property使用太过频繁，那可能就该考虑重构这个类了，同时按照旧办法使用这个类的那些代码可能也要重构。</li></ul><h3 id="用描述符来改写需要复用的-property方法">用描述符来改写需要复用的@property方法</h3><ul><li>如果像复用@property方法所实现的行为与验证逻辑，则可以考虑自己定义描述符类。</li><li>为了防止内存泄漏，可以在描述符中用WeakKeyDictionary取代普通的字典。</li><li>不要太纠结于__getattribute__是怎么通过描述符协议来获取并设置属性的。</li></ul><h3 id="针对惰性属性使用-getattr-、getattribute、-setattr-方法">针对惰性属性使用__getattr__、<strong>getattribute</strong>、__setattr__方法</h3><ul><li>如果想用自己的防护死（例如惰性地或者按需地）加载并保存对象属性，那么可以在该对象所属的类里实现__getattr__与__setattr__特殊方法。</li><li>__getattr__只会在属性缺失时触发，而__getattribute__则在每次访问属性时都要触发。</li><li>在实现__getattribute__与__setattr__的过程中，如果要使用本对象的普通属性，那么应该通过super()（也就是object类）来使用，而不要直接使用，以避免无限递归。</li></ul><h3 id="用-init-subclass-验证子类写得是否正确">用__init_subclass__验证子类写得是否正确</h3><ul><li>如果某个类时根据元类所定义的，那么当系统把该类的class语句体全部处理完之后，就会将这个类的写法告诉元类的__new__方法。</li><li>可以利用元类在类创建完成前检视或修改开发者根据这个元类所定义的其他类，但这种机制通常显得有点笨重。</li><li>__init_subclass__能够用来检查子类定义得是否合理，如果不合理，那么可以提前报错，让程序无法创建出这种子类的对象。</li><li>在分层的或者涉及多重继承的类体系里面，一定别忘了在你写的这些类的 __init_subclass__内通过 super() 来调用超类的 __init_subclass__方法，以便按照正确的顺序触发各类的验证逻辑。</li></ul><h3 id="用-init-subclass-记录现有的子类">用 __init_subclass__记录现有的子类</h3><ul><li>类注册（Class registration）是个相当有用的模式，可以用来构建模块式的Python程序。</li><li>我们可以通过基类的元类把用户从这个基类派生出来的子类自动注册给系统。</li><li>利用元类实现类注册可以防止由于用户忘记注册而导致程序出现问题。</li><li>优先考虑通过__init_subclass__实现自动注册，而不要用标准的元类机制来实现，因为__init_subclass__更清晰，更便于初学者理解。</li></ul><h3 id="用-set-name-给类属性加注解">用__set_name__给类属性加注解</h3><ul><li>我们可以通过元类把利用这个元类所定义的其他类拦截下来，从而在程序开始使用那些类之前，先对其中定义的属性做出修改。</li><li>描述符与元类搭配起来，可以形成一套强大的机制，让我们既能采用声明式的写法来定义行为，又能在程序运行时检视这个行为的具体执行情况。</li><li>你可以给描述符定义__set_name__方法，让系统把使用这个描述符做属性的那个类似以及它在类里的属性通过方法的参数告诉你。</li><li>用描述符直接操纵每个实例的属性字典，要比把所有实例的属性都放到一份字典里更好，因为后者要求我们必须使用weakref内置模块之中的特殊字典来记录每个实例的属性值以防止内存泄漏。</li></ul><h3 id="优先考虑通过类修饰器来提供可组合的扩充功能，不要使用元类">优先考虑通过类修饰器来提供可组合的扩充功能，不要使用元类</h3><ul><li>类修饰器起始就是个函数，只不过它可以通过参数获知自己所修饰的类，从而重建或调整这个类并返回修改结果。</li><li>如果要给类中的每个方法或属性都施加一套逻辑，而且还想着尽量少写一些例行代码，那么类修饰器是个很值得考虑的方案。</li><li>元类之间很难组合，而类修饰器则比较灵活，它们可以施加在同一个类上，并且不会发生冲突。</li></ul><h2 id="并发与并行">并发与并行</h2><h3 id="用subprocess管理子进程">用subprocess管理子进程</h3><ul><li>subprocess模块可以运行子进程并管理它们的输入流与输出流。</li><li>子进程能够跟Python解释器所在的进程并行，从而充分利用各CPU核心。</li><li>要开启子进程，最简单的办法就是调用run函数，另外也可以通过Popen类实现类似Unix管道的高级用法。</li><li>调用communicate方法时可以指定timeout参数，让我们有机会把陷入死锁或已经卡住的子进程关掉。</li></ul><h3 id="可以用线程执行阻塞式I-O，但不要用它做并行计算">可以用线程执行阻塞式I/O，但不要用它做并行计算</h3><ul><li>即便计算机具备多核CPU，Python线程也无法真正实现并行，因为它们会受到全局解释器锁（GIL）牵制。</li><li>虽然Python的多线程机制受GIL影响，但还是非常有用的，因为我们很容易就能通过多线程模拟同时执行多项任务的效果。</li><li>多条Python线程可以并行地执行多个系统调用，这样就能让程序在执行阻塞式的I/O任务时，继续做其他运算。</li></ul><h3 id="利用Lock防止多个线程争用同一份数据">利用Lock防止多个线程争用同一份数据</h3><ul><li>虽然Python有全局解释器锁，但开发者还是得设法避免线程之间发生数据争用。</li><li>把未经互斥锁保护的数据开放给多个线程去同时修改，可能导致这份数据的结构遭到破坏。</li><li>可以利用threading内置模块之中的Lock类确保程序中的固定关系不会在多线程环境下受到干扰。</li></ul><h3 id="用Queue来协调各线程之间的工作进度">用Queue来协调各线程之间的工作进度</h3><ul><li>管道非常适合用来安排多阶段的任务，让我们能够把每一阶段都交给各自的线程去执行，这尤其适合用在I/O密集型的程序里面。</li><li>构造这种并行的管道时，有很多问题需要注意，例如怎样防止线程频繁地查询队列状态，怎样通知线程尽快结束操作，以及怎样防止管道出现拥堵等。</li><li>我们可以利用Queue类所具有的功能来构造健壮的管道系统，因为这个类提供了阻塞式的入队（put）和出队（get）操作，而且可以限定缓冲区的大小，还能够通过task_done与join来确保所有元素都已处理完毕。</li></ul><h3 id="学会判断什么场合必须做并发">学会判断什么场合必须做并发</h3><ul><li>程序范围变大、需求变复杂之后，经常要用多条路径平行地处理任务。</li><li>fan-out与fan-in是最常见的两种并发协调（concurrency coordination）模式，前者用来生成一批新的并发单元，后者用来等待现有的并发单元全部完工。</li><li>Python提供了很多种实现fan-out与fan-in的方案。</li></ul><h3 id="不要在每次fan-out时都新建一批Thread实例">不要在每次fan-out时都新建一批Thread实例</h3><ul><li>每次都手工创建一批线程，是有很多缺点的，例如：创建并运行大量线程时的开销比较大，每条线程的内存占用量比较多，而且还必须采用Lock等机制来协调这些线程。</li><li>线程本身并不会把执行过程中遇到的异常抛给启动线程或者等待该线程完工的那个人，所以这种异常很难调试。</li></ul><h3 id="学会正确地重构代码，以便用Queue做并发">学会正确地重构代码，以便用Queue做并发</h3><ul><li>把队列（Queue）与一定数量的工作线程搭配起来，可以高效地实现fan-out（分派）与fan-in（归集）。</li><li>为了改用队列方案处理I/O，我们重构了很多代码，如果管道要分成好几个环节，那么要修改的地方会很多。</li><li>利用队列并行地处理I/O任务量有限，我们可以考虑用Python内置的某些功能与模块打造更好的方案。</li></ul><h3 id="如果必须用线程做并发，那就考虑通过ThreadPoolExecutor实现">如果必须用线程做并发，那就考虑通过ThreadPoolExecutor实现</h3><ul><li>利用ThreadPoolExecutor，我们只需要稍微调整一下代码，就能够并行地执行简单的I/O操作，这种方案省去了每次fan-out（分派）任务时启动线程的那些开销。</li><li>虽然ThreadPoolExecutor不想直接启动线程的方案那样，需要消耗大量内存，但它的I/O并行能力也是有限的。因为它能够使用的最大线程数需要提前通过max_workers参数指定。</li></ul><h3 id="用协程实现高并发I-O">用协程实现高并发I/O</h3><ul><li>协程时采用async关键字所定义的函数。如果你想执行这个协程，但并不要钱立刻就获得执行结果，而是稍后再来获取，那么可以通过await关键字表达这个意思。</li><li>协程能够制造出一种效果，让人以为程序里有成千上万个函数都在同一时刻高效地运行着。</li><li>协程可以用fan-out与fan-in模式实现并行的I/O操作，而且能够克服用线程做I/O时的缺陷。</li></ul><h3 id="学会用asyncio改写那些通过线程实现的I-O">学会用asyncio改写那些通过线程实现的I/O</h3><ul><li>Python提供了异步版本的for循环、with语句、生成器与推导机制，而且还有很多辅助的库函数，让我们能够顺利地迁移到协程方案。</li><li>我们很容易就能利用内置的asyncio模块来改写代码，让程序不要再通过线程执行阻塞式的I/O，而是改用协程来执行异步I/O。</li></ul><h3 id="结合线程与协程，将代码顺利迁移到asyncio">结合线程与协程，将代码顺利迁移到asyncio</h3><ul><li>asyncio模块的事件循环提供了一个返回awaitable对象的run_in_executor方法，它能够使协程把同步函数放在线程池执行期（ThreadPoolExecutor）里面执行，让我们可以顺利地将采用线程方案所实现的项目，从上至下地迁移到asyncio方案。</li><li>asyncio模块的事件循环还提供了一个可以再同步代码里面调用的run_until_complete方法，用来运行协程并等待其结束。它的功能跟asyncio.run_coroutine_threadsafe类似，只是后者面对的时跨线程的场合，而前者是为同一个线程设计的。这些都有助于将采用线程方案所实现的项目从下至上地迁移到asyncio方案。</li></ul><h3 id="让asyncio的事件循环保持畅通，以便进一步提升程序的响应能力">让asyncio的事件循环保持畅通，以便进一步提升程序的响应能力</h3><ul><li>把系统调用（包括阻塞式的I/O以及启动线程等操作）放在协程里面执行，会降低程序的响应能力，增加延迟感。</li><li>调用async.run时，可以把debug参数设为True，这样能够知道哪些协程降低了事件循环的反应速度。</li></ul><h3 id="考虑用concurrent-futures实现真正的并行计算">考虑用concurrent.futures实现真正的并行计算</h3><ul><li>把需要耗费大量CPU资源的计算任务改用C扩展模块来写，或许能够有效提高程序的运行速度，同时又让程序里的其他代码依然能够利用Python语言自身的特性。但是，这样做的开销比较大，而且容易引入bug。</li><li>Python自带的multiprocessing模块提供了许多强大的工具，让我们只需要耗费很少的精力，就可以把某些类型的任务平行地放在多个CPU核心上面处理。</li><li>要想发挥出multiprocessing模块的优势，最好是通过concurrent.futures模块及其ProcessPoolExecutor类来编写代码，因为这样做比较简单。</li><li>只有在其他方案全都无效的情况下，才可以考虑直接使用multiprocessing里面的高级功能（那些功能用起来相当复杂）。</li></ul><h2 id="稳定与性能">稳定与性能</h2><h3 id="合理利用try-except-else-finally结构种的每个代码块">合理利用try/except/else/finally结构种的每个代码块</h3><ul><li>try/finaly形式的复合语句可以确保，无论try块是否抛出异常，finally块都会得到运行。</li><li>如果某段代码应该再前一段代码顺利执行之后加以运行，那么可以把它放到else块里面，而不要把这两段代码全都写在try块之中。这样可以让try块更加专注，同时也能够跟except块形成明确对照；except块写的时try块没有顺利执行时所要运行的代码。</li><li>如果你要在某段代码顺利执行之后多做一些处理，然后再清理资源，那么通常可以考虑把这三段代码分别放在try、else与finally块里。</li></ul><h3 id="考虑用contextlib和with语句来改写可复用的try-finally代码">考虑用contextlib和with语句来改写可复用的try/finally代码</h3><ul><li>可以把try/finally逻辑风撞到情境管理器里面，这样就能通过with结构反复运用这套逻辑，而不需要每次用到的适合，都手工打一遍代码。</li><li>Python内置的contextlib模块提供了contextmanager修饰器，让我们可以很方便地修饰某个函数，从而制作出相对应的情境管理器，舍得这个函数能够运用再with语句里面。</li><li>情境管理器通过yield语句所产生的值，可以由with语句之中位于as右侧的那个变量所接收，这样的话，我们就可以通过该变量与当前情境相交互了。</li></ul><h3 id="用datetime模块处理本地事件，不要用time模块">用datetime模块处理本地事件，不要用time模块</h3><ul><li>不要用time模块再不同时区之间转换。</li><li>把Python内置的datetime模块与开发者社群提供的pytz模块结合起来，可以在不同时区之间可靠地转换。</li><li>在操纵事件数据的过程种，总是应该使用UTC时间，只有到了最后一步，才需要把它转回当地时间以便显示出来。</li></ul><h3 id="用copyreg实现可靠的pickle操作">用copyreg实现可靠的pickle操作</h3><ul><li>Python内置的pickle模块，只适合用来再彼此信任的程序之间传递数据，以实现对象的序列化与反序列化功能。</li><li>如果对象所在的这个类发生了变化（例如增加或删除了某些属性），那么程序在还原旧版数据的时候，可能会出现错误。</li><li>把内置的copyreg模块与pickle模块搭配起来使用，可以让新版的程序兼容旧版的序列化数据。</li></ul><h3 id="在需要准确计算的场合，用decimal表示相应的数值">在需要准确计算的场合，用decimal表示相应的数值</h3><ul><li>每一种数值几乎都可以用Python内置的某个类型，或者内置模块之中的某个类表示出来。</li><li>在精度要求较高且需要控制舍入方式的场合（例如在计算费用的时候），可以考虑使用Decimal类。</li><li>用小数构造Decimal时，如果想保证取值准确，那么一定要把这个数放在str字符串里面传递，而不要直接传过去，那样可能有误差。</li></ul><h3 id="先分析性能，然后再优化">先分析性能，然后再优化</h3><ul><li>优化Python程序之前，一定要先分析它的性能，因为导致程序速度缓慢的真正原因未必与我们想的一样。</li><li>应该优先考虑用cProfile模块来分析性能，而不要用profile模块，因为前者得到的分析结果更加准确。</li><li>把需要接收性能测试的主函数传给Profile对象的runcall方法，就可以专门分析出这个体系下面所有函数的调用情况了。</li><li>可以通过Stats对象筛选出我们关心的那些分析结果，从而更加为专注地思考如何优化程序性能。</li></ul><h3 id="优先考虑用deque实现生产者-消费者队列">优先考虑用deque实现生产者-消费者队列</h3><ul><li>list类型可以用来实现FIFO队列，生产者可以通过append方法向队列添加元素。但这种方案有个问题，就是消费者在用 pop(0) 从队列中获取元素时，所花的时间会随着队列长度，呈平方式增长。</li><li>跟list不同，内置collections模块种的deque类，无论时通过append添加元素，还是通过popleft获取元素，所花的时间都只跟队列长度呈现性关系，而非平方关系，这使得它非常适合于FIFO队列。</li></ul><h3 id="考虑用bisect搜索已排序的序列">考虑用bisect搜索已排序的序列</h3><ul><li>用index方法在已经排好顺序的列表之中查找某个值，花费的时间与列表长度成正比，通过for循环单纯地做比较以寻找目标值，所花的时间也是如此。</li><li>Python内置的bisect模块里面有个bisect_left函数，只需要花费对数级别的时间就可以在有序列表中搜寻某个值，这要比其他方法快好几个数量级。</li></ul><h3 id="学会使用heapq制作优先级队列">学会使用heapq制作优先级队列</h3><ul><li>优先级队列让我们能够按照重要程度来处理元素，而不是必须按照先进先出的顺序处理。</li><li>如果直接用相关的列表操作来模拟优先级队列，那么程序的性能会随着队列长度的增大这大幅下降，因为这样做的复杂程度是平方级别，而不是线性级别。</li><li>通过Python内置的heapq模块所提供的函数，我们完全可以实现基于堆的优先级队列，从而高效地处理大量数据。</li><li>要使用heapq模块，我们必须让元素所在的类型支持自然排序，这可以通过对类套用@functools.total_ordering修饰器并定义__lt__方法来实现。</li></ul><h3 id="考虑用memoryview与bytearray来实现无须拷贝的bytes操作">考虑用memoryview与bytearray来实现无须拷贝的bytes操作</h3><ul><li>Python内置的memoryview类型提供了一套无须执行拷贝的（也就是零拷贝）操作接口，让我们可以对支持缓冲协议的Python对象制作切片，并通过这种切片高速地完成读取与写入。</li><li>Python内置的bytearray类型是一种与bytes相似但内容能够改变的类型，我们可以通过socket.reccv_from这样的函数，以无需拷贝的方式（也就是零拷贝的方式）读取数据。</li><li>我们可以用memoryview来封装bytearray，从而用收到的数据覆盖底层缓冲里面的任意区段，同时又无需执行拷贝操作。</li></ul><h2 id="测试与调试">测试与调试</h2><h3 id="通过repr字符串输出调试信息">通过repr字符串输出调试信息</h3><ul><li>把内置类型的值传给print，会打印出便于认读的那种字符串，但是其中不会包含类型信息。</li><li>把内置类型的值传给repr，会得到一个能够表示该值的可打印字符串，将这个repr字符串传给内置的eval函数能够得到原值。</li><li>在格式化字符串里用%s处理相关的值，就跟把这个值传给str函数一样，都能得到一个便于认读的那种字符串。如果用%r来处理，那么得到的就是repr字符串。在f-string中，也可以用值来取代其中有待替换的那一部分，并产生便于认读的那种字符串，但如果待替换的部分加了!r后缀，那么替换出来的就是repr字符串。</li><li>给类定义__repr__特殊方法，可以让print函数把该类实例的可打印表现形式展现出来，在实现这个方法时，还可以提供更为详尽的调试信息。</li></ul><h3 id="在TestCase子类里验证相关的行为">在TestCase子类里验证相关的行为</h3><ul><li>Python内置的unittest模块里有个TestCase类，我们可以定义它的子类，并在其中编写多个test方法，以便分别验证想要测试的每一种行为。TestCase子类的这些test方法名称都必须以test这个词开头。</li><li>TestCase类还提供了许多辅助方法，例如，可以在test方法中通过assertEqual辅助方法来确认两个值相等，而不采用内置的assert语句。</li><li>可以用subTest辅助方法做数据驱动测试，这样就不用针对每项子测试重复编写相关的代码与验证逻辑了。</li></ul><h3 id="把测试前、后的准备与清理逻辑写在setUp、tearDown、setUpModule、tearDownModule中，以防用例之间互相干扰">把测试前、后的准备与清理逻辑写在setUp、tearDown、setUpModule、tearDownModule中，以防用例之间互相干扰</h3><ul><li>单元测试验证的是每项功能本身是否正常，集成测试验证的是模块之间能否正确交互，这两种测试都很重要。</li><li>把测试用例的准备与清理工作分别放在setUp与tearDown方法中，可以避免用例之间相互干扰，使它们都能从一套干净的环境开始执行。</li><li>集成测试的准备与清理工作可以放在模块级别的setUpModule与tearDownModule函数里，系统在测试该模块与其中所有TestCase子类的过程中，只会把这两个函数各自运行一遍。</li></ul><h3 id="用Mock来模拟受测试代码所依赖的复杂函数">用Mock来模拟受测试代码所依赖的复杂函数</h3><ul><li>unittest.mock模块中的Mock类能够模拟某个接口的行为，我们可以用它替换受测试函数所要调用的接口，因为那些接口可能不太容易在测试的过程种配置。</li><li>如果用mock把手册代码所依赖的函数替换掉了，那么在测试的时候，不仅要验证受测代码的行为，而且还要验证它有没有正确地调用这些mock，这可以通过Mock.assert_called_once_with等一系列方法实现。</li><li>要想把受测函数所调用的其他函数用mock逻辑替换掉，一种办法是给受测函数设计只能以关键字来指定的参数；另一种办法是通过unittest.mock.patch系列的方法暂时隐藏那些函数。</li></ul><h3 id="把受测代码所依赖的系统封装起来，以便于模拟和测试">把受测代码所依赖的系统封装起来，以便于模拟和测试</h3><ul><li>在写单元测试的时候，如果总是要反复使用许多代码来注入模拟的逻辑，那么可以考虑把受测函数所要用到的逻辑封装到类中，因为封装之后更容易注入。</li><li>Python内置的unitest.mock模块里有个Mock类，它能模拟类的实例，这种Mock对象具备与原类中的方法相对应的属性。如果在它上面调用某个方法，就会触发相应的属性。</li><li>如果想把程序完整的测一遍，那么可以重构代码，在原类直接使用复杂系统的地方引入辅助函数，让程序通过这些函数来获取它要用的系统，这样我们就可以通过辅助函数注入模拟逻辑。</li></ul><h3 id="考虑用pdb做交互调试">考虑用pdb做交互调试</h3><ul><li>在程序里某个兴趣点直接调用Python内置的breakpoint函数就可以触发交互调试器。</li><li>Python的交互调试界面（即pdb界面）也是一套完整的Python执行环境，在它里面我们可以检查正在运行的程序处于什么状态，并予以修改。</li><li>我们可以在pdb界面里用相关的命令精确地控制程序的执行方式，这样就能做到一边检查状态，一边推进程序了。</li><li>pdb模块还能够在程序出现错误的时候检查该程序的状态，这可以通过 <code>python -m pdb -c continue &lt;program path&gt;</code> 命令实现，也可以在普通的Python解释器界面运行受测程序，等到出现问题，再用<code>import pdb; pdb.pm()</code>切换至调试界面。</li></ul><h3 id="用tracemalloc来掌握内存的使用与泄漏情况">用tracemalloc来掌握内存的使用与泄漏情况</h3><ul><li>不借助相关的工具，我们可能很难了解Python程序是怎样使用内存的，以及其中有些内存又是如何泄漏的。</li><li>gc模块可以帮助我们了解垃圾回收器追踪到了哪些对象，但它并不能告诉我们那些对象是如何分配的。</li><li>Python内置的tracemalloc模块提供了一套强大的工具，可以帮助我们更好地了解内存的使用情况，并找到这些内存分别由哪一行代码所分配。</li></ul><h2 id="协作开发">协作开发</h2><h3 id="学会寻找由其他Python开发者所构建的模块">学会寻找由其他Python开发者所构建的模块</h3><ul><li>Python Package Index（PyPI） 含有许多常用的软件包，这些都是由广大Python开发者构建并维护的。</li><li>可以用pip命令行工具从PyPI里面安装软件包。</li><li>大多数PyPI模块都是自由及开源软件。</li></ul><h3 id="用虚拟环境隔离项目，并重建依赖关系">用虚拟环境隔离项目，并重建依赖关系</h3><ul><li>我们可以在每个虚拟环境里面，分别用pip命令安装它所需要的软件包，这样的话，同一台电脑中就可以存在许多互不冲突的环境了。</li><li><code>python3 -m venv</code> 命令可以创建虚拟环境，<code>source bin/activate与deactivate</code>命令分别可以启动与禁用该环境。</li><li><code>python3 -m pip freeze &gt; requirements.txt</code> 命令可以把当前环境所依赖的软件包保存到文件之中，之后可以通过 <code>python3 -m pip install -r requirements.txt</code> 在另一套环境里面重新安装这些包。</li></ul><h3 id="每一个函数、类与模块都要写docstring">每一个函数、类与模块都要写docstring</h3><ul><li>每个模块、类、方法与函数都应该编写docstring文档，并且要与实现代码保持同步。</li><li>模块的docstring要介绍本模块的内容，还要指出用户必须了解的关键类与重要函数。</li><li>类的docstring要写在class语句的正下方，描述本类的行为与重要的属性，还要指出子类应该如何正确地继承这个类。</li><li>函数与方法的docstring要写在def语句的正下方，描述本函数的每个参数、函数的返回值，可能抛出的异常以及其他相关的行为</li><li>如果某些信息已经通过类型注解表达过了，那就不要在docstring里面重复。</li></ul><h3 id="用包来安排模块，以提供稳固的API">用包来安排模块，以提供稳固的API</h3><ul><li>Python的包是一种包含其他模块的模块。这种结构让我们可以把代码划分成多个互不冲突的名称空间，即便两个实体同名，也能用它们所属的模块加以区分。</li><li>如果要构建的包比较简单，那就把其中每个模块所对应的源文件都直接放在本包的目录下，并给目录里面创建一份__init__.py文件。这样的话，这些源文件所表示的模块就会成为本包的子模块。这个目录里还可以创建子目录，以构建其他包。</li><li>如果想限制外界通过引入该模块能够访问到哪些API，那么可以把这些API的名称写在__all__这个特殊的属性里面。</li><li>如果不想让外界看到某些内容，那么可以在包目录中的__init__.py文件里面故意不引入这些内容，或者给这些只供本包内部使用的内容名称前面添加下划线。</li><li>假如这个包只在某个团队或某个项目内部使用，那恐怕就没必要专门通过__all__来指定外界能够访问到的API了。</li></ul><h3 id="考虑用模块级别的代码配置不同的环境">考虑用模块级别的代码配置不同的环境</h3><ul><li>程序通常需要部署到许多种环境里面，无论在哪一种环境之中运行程序，都必须先准备好相关的资源，并做出适当的配置。</li><li>可以像编写普通的Python语句那样，直接在模块作用域书写配置逻辑，以定制该模块的内容，从而针对不同的环境做出适当的部署。</li><li>还可以根据其他一些外部因素来调整模块的内容，例如通过sys或os模块查询与操作系统相关的信息，并据此定制该模块。</li></ul><h3 id="为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常">为自编的模块定义根异常，让调用者能够专门处理与此API有关的异常</h3><ul><li>给模块定义根异常，可以让使用这个模块的API用户将它们自己的代码与这个模块所提供的API隔开，以便分别处理其中的错误。</li><li>API用户在处理完API所属模块由可能抛出的具体异常后，可以写一个针对模块根异常的except块，如ugochengxu进入这个块，那就说明他使用API的方式可能有问题，例如可能忘记处理某种本来应该处理的具体异常。</li><li>API用户还可以再写一个except块以捕获整个Python体系之中的根异常，如果程序进入了那个块，那说明所调用的API可能实现得有问题。</li><li>在模块的根异常下，可以设立几个门类，让具体的异常不要直接集成总的根异常，而是继承各自门类种的那个分根异常，这样的话，使用这个模块的开发者，就可以只关注这几个门类，即便你修改了某个门类至下的具体异常，也不会影响到他们已经写好的那些代码。</li></ul><h3 id="用适当的方式打破循环依赖关系">用适当的方式打破循环依赖关系</h3><ul><li>如果两个模块都要在开头引入对方，那就会形成循环依赖，这有可能导致程序在启动的时候崩溃。</li><li>要想达阔依赖循环，最好的办法是把这两个模块都要用到的那些代码重构到整个依赖体系的最底层。</li><li>如果不想大幅度重构代码，也不想让代码变得太复杂，那么最简单的方案是通过动态引入来消除循环依赖关系，但尽量避免使用。</li></ul><h3 id="重构时考虑通过warnings提醒开发者API已经发生变化">重构时考虑通过warnings提醒开发者API已经发生变化</h3><ul><li>设计新版API的时候，可以通过warnings模块把已经过时的用法通知到调用者，让他们看到消息后尽快改用新的方法，以防程序在我们彻底放弃旧版API之后崩溃。</li><li>在命令行界面执行Python解释器的时候，可以开启-W error选项，从而将警告视为错误。这在执行自动测试的过程种特别有用，因为这样可以及时发现受测程序所依赖的API是否已经推出了新的版本。</li><li>如果程序要部署到生产环境，那么可以通过logging模块将警告信息重定向到日志系统，把程序在运行过程中遇到的警告纳入现有的错误报告机制中。</li><li>如果你设计的API会发出警告，那么应该为此编写测试，确保下游开发者在使用API的过程中，能够在适当的时机收到正确的警告信息。</li></ul><h3 id="考虑通过typing做静态分析，以消除bug">考虑通过typing做静态分析，以消除bug</h3><ul><li>Python提供了内置的typing模块与一套特殊的写法，可以给变量、字段、函数与方法标注类型信息。</li><li>静态类型检查工具可以利用标注的类型信息检查出许多常见的bug，而不用让它们到程序运行的时候再暴露。</li><li>合理地使用注解<ul><li>如果刚开始写代码的时候，就想着如何添加类型注解，那可能会拖慢编程速度。所以我们通常应该先把代码本身写出来，然后编写测试，最好才考虑在必要的地方添加类型信息。</li><li>类型提示信息最能发挥作用的地方，是在项目与项目衔接处。</li><li>如果有些代码比较复杂，或者特别容易出错，那么即便不属于API，也仍然值得添加类型提示信息。但是要注意，没必要给所有的代码都添上类型注解，因为到了一定程度之后，再添加这种信息，就不会给项目带来太大的好处。</li><li>如果有可能的话，应该把静态分析这一环节纳入自动构建流程与测试系统中，以确保提交上去的每份代码都会经受相关的检查。另外，检查类型信息所用的配置方案，应该放在代码库里面维护，以保证其他的合作者使用的也是这套规则。</li><li>每添加一批类型注解，就应该把静态分析工具运行一遍，这样可以及时发现问题并加以解决。假如把整个项目全部注解完之后，再实施类型检查，那么类型分析工具就有可能打印出极多的错误信息，让你不知到应该先处理哪一条才好，有时甚至会让你想要放弃类型注解。</li><li>有许多场合是不需要写类型注解的，如小型程序、临时代码、遗留项目以及原型等</li></ul></li></ul><h2 id="Reference">Reference</h2><p>[1] <a href="https://book.douban.com/subject/35334595/" target="_blank" rel="noopener">Effective Python</a></p>]]></content>
    
    <summary type="html">
    
      “编写高质量Python代码”。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
  </entry>
  
  <entry>
    <title>低碳水饮食</title>
    <link href="https://neo1989.net/SeizeTheDay/HEALTH-low-carb-diet/"/>
    <id>https://neo1989.net/SeizeTheDay/HEALTH-low-carb-diet/</id>
    <published>2021-05-10T09:35:28.000Z</published>
    <updated>2021-05-10T10:13:05.798Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>想减肥，但又吃惯了传统的高碳低脂饮食，一下子要改成低碳水化合物饮食，很多人不清楚到底该怎么吃？哪些食物能吃，哪些应该尽量避免？</p></blockquote><h2 id="低碳水饮食食材清单">低碳水饮食食材清单</h2><h3 id="能吃的">能吃的</h3><ul><li><p>✅ 任何肉类：牛肉、猪肉、羊肉、家禽、野味等。脂肪和肉皮（鸡皮）都可以随便吃。 如果是草饲的最好。</p></li><li><p>✅ 鱼类和海鲜：包括富含Omega-3脂肪酸的鲑鱼，鲭鱼、沙丁鱼或鲱鱼等脂肪鱼。</p></li><li><p>✅ 蛋类：鸡蛋、鸭蛋、鹅蛋、鹌鹑蛋等，非人工饲养的草饲蛋类（柴鸡蛋）最好。</p></li><li><p>✅ 健康脂肪：椰子油、橄榄油、草饲黄油。</p></li><li><p>✅ 蔬菜：地面上生长的蔬菜，如：西兰花、羽衣甘蓝、菠菜、菜花、卷心菜、白菜、芹菜、芦笋、西葫芦、茄子、黄瓜、西红柿、菌类，以及其他十字花科蔬菜。</p></li><li><p>地下生长的蔬菜一般含有较高碳水化合物，例如土豆、红薯、胡萝卜等，只能偶尔吃一些。</p></li><li><p>✅ 乳制品：动物黄油、奶油（含40%脂肪）、酸奶油（sour cream）、无糖全脂酸奶、奶酪等。</p></li><li><p>要小心普通牛奶，不管是全脂还是脱脂的，其中都含有糖分。</p></li><li><p>✅ 坚果：碳水含量低的坚果可以偶尔当作零食，包括：核桃、巴西坚果、澳洲坚果、榛子、花生、杏仁。</p></li><li><p>✅ 水果：某些浆果类可以适量吃，例如：草莓、黑莓、覆盆子。</p></li><li><p>✅ 黑巧克力：纯度在70%以上的黑巧克力可以偶尔吃。</p></li></ul><h3 id="能喝的">能喝的</h3><ul><li><p>✅ 水：白开水是最好的饮料，加了柠檬汁或黄瓜汁的水也没问题。</p></li><li><p>✅ 茶：绿茶、抹茶，只要是不加糖的都可以。</p></li><li><p>✅ 咖啡：不加糖和奶精的黑咖啡。</p></li></ul><h3 id="尽量避免的">尽量避免的</h3><ul><li><p>❌ 甜食：包括各种糕点、饼干、冰激淋、糖果、果汁、软包装饮料、碳酸饮料、牛奶巧克力等含糖饮食。</p></li><li><p>❌ 淀粉类：精制米、面及其制品，面条、面包、炸薯条、薯片、爆米花等。</p></li><li><p>❌ 酒精饮料：啤酒、白酒。干红葡萄酒可以偶尔少量饮用。</p></li><li><p>❌ 水果：大多数的水果都含有大量的糖分和碳水化合物，不易多吃。</p></li><li><p>❌ 人造黄油、人造奶油：它们含有大量的ω-6脂肪酸，这种脂肪吃多了会引起身体炎症。</p></li><li><p>❌ 加工食品：任何带包装，标签上有很多成分（添加剂）的食物都不应多吃。</p></li></ul><h2 id="学生党和上班族怎么吃？">学生党和上班族怎么吃？</h2><h3 id="食堂">食堂</h3><p>食堂中最不缺的就是碳水，一不留神就吃爆表。</p><ul><li><p>多吃或只吃炒菜：各种青菜，炒肉菜，换着花样吃；</p></li><li><p>多吃蛋白质：瘦肉、鱼肉、蛋类、豆制品；</p></li><li><p>多吃健康脂肪：带皮的猪肉、鸡肉、红烧肉、回锅肉、猪肘子；</p></li><li><p>各种淀粉少的汤：鸡汤、骨头汤、紫菜汤；</p></li><li><p>水果：几颗圣女果、蓝莓、覆盆子、草莓</p></li><li><p>可以适量吃抗性淀粉：比如一小块儿红薯、土豆、胡萝卜、玉米、燕麦粥；</p></li><li><p>避免含淀粉和糖的菜：比如四喜丸子、糖醋排骨、炸鸡翅、裹面的炸鱼等；</p></li><li><p>不吃米、面：包括面条、面包、大米粥、米饭；</p></li><li><p>不吃甜食、不喝含糖饮料；</p></li></ul><h3 id="快餐外卖">快餐外卖</h3><p>很多上班族除了吃食堂以外，还会点外卖，尽管没有办法保证能完全按照自己的心意来做，但仍然可以通过下面这几个方法来尽量吃得健康。</p><ul><li><p>点餐时备注少放油、少放盐、少放糖；</p></li><li><p>自带橄榄油、椰子油、奶酪片、牛油果；</p></li><li><p>多点肉类炒菜、沙拉；</p></li><li><p>不点主食，用菜代替；</p></li><li><p>不买饮料和甜食；</p></li></ul><h3 id="自助餐">自助餐</h3><p>吃自助餐可以自己做主，只选择那些更健康的食物和饮料。</p><p>各种蔬菜、肉类、鱼类、蛋类、奶酪等都可以。</p><p>不吃主食、不喝含糖和酒精饮料，不吃甜食。</p><h2 id="生酮饮食">生酮饮食</h2><p>生酮饮食，是一种“高”脂肪、“中”蛋白质、“低”碳水化合物的饮食方式，目的是让你的身体处于称为酮症的代谢状态，从而燃烧脂肪，而不是碳水化合物。</p><p>生酮饮食最初被用于治疗儿童癫痫，近年来也用来辅助治疗其他神经系统疾病、睡眠障碍、双相情感障碍、自闭症、甚至脑癌。</p><p><strong>75% 脂肪 + 20% 蛋白质 + 5% 碳水</strong></p><p>生酮饮食是一种严格的低碳水饮食，作为短期快速减肥的方法，它的效果很明显，但是<em>长期生酮的安全性目前来说仍没有定论</em>。</p><h3 id="生酮饮食的工作原理">生酮饮食的工作原理</h3><p>正常情况下，碳水化合物经人体吸收后会转化为葡萄糖并被当成能量运送到身体各处，尤其是用于维持大脑的正常运作。</p><p>而生酮饮食中只摄取极少量的碳水化合物，身体得不到足够的糖原来提供能量，肝脏就会将脂肪分解为脂肪酸和酮体。其中，酮体会代替葡萄糖进入血液，运往全身，成为主要的能量来源。</p><p>这个过程中，血液中的血糖含量会迅速下降，酮体水平会升高，身体进入营养性酮症状态。而一旦身体转换为这种新的代谢方式，就会开始燃烧脂肪。</p><p>达到生酮状态需要几天时间，这期间必须严格按照生酮饮食的比例来吃，即：碳水化合物5%，蛋白质20%，健康脂肪75%。</p><h3 id="生酮饮食的不良反应">生酮饮食的不良反应</h3><p>在最初阶段，大多数人都会出现身体不适，因为症状类似于流感和感冒，所以被称为“酮流感”。</p><p>主要表现包括：</p><ul><li>疲倦、乏力</li><li>头晕、头疼</li><li>口臭</li><li>胃部不适</li><li>腹泻或便秘</li><li>脱发</li><li>失眠</li><li>情绪不稳</li><li>酮疹（不多见）</li></ul><p>出现这些症状的原因是身体正在适应新的代谢方式。通常来说，这些不适感会在两三周之内消失。</p><h3 id="生酮饮食能吃什么？">生酮饮食能吃什么？</h3><p>这种饮食方式的特点是，吃大量的健康脂肪，例如：椰子油、牛油果油、橄榄油、草饲黄油等；以及适量的蛋白质，如：鸡蛋、瘦肉、鱼、虾等；碳水化合物主要从低碳水蔬菜、水果和坚果中获得。</p><p>因为脂肪和蛋白质含量更高，因此会明显增加饱足感，同时减少食欲和进食量。</p><h3 id="什么是净碳水（Net-Carbs）">什么是净碳水（Net Carbs）</h3><p>当我们说每天只能吃5%（20-50克）的碳水化合物时，指的是<strong>净碳水</strong>，这是相对于总碳水含量来说的。</p><p>净碳水化合物是食物中总碳水化合物的克数减去其总纤维的克数。因为身体不能消化纤维，所以它不计入碳水摄入量。</p><p><strong>总碳水化合物 – 总纤维 = 净碳水化合物</strong></p><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://lowcarbfasthealth.com/" target="_blank" rel="noopener">低碳坊</a></p>]]></content>
    
    <summary type="html">
    
      健康饮食
    
    </summary>
    
    
      <category term="SeizeTheDay" scheme="https://neo1989.net/categories/SeizeTheDay/"/>
    
    
      <category term="Health" scheme="https://neo1989.net/tags/Health/"/>
    
  </entry>
  
  <entry>
    <title>《超级自控力》</title>
    <link href="https://neo1989.net/Notes/NOTE-super-self-control/"/>
    <id>https://neo1989.net/Notes/NOTE-super-self-control/</id>
    <published>2021-04-21T07:05:36.000Z</published>
    <updated>2023-01-13T03:04:45.833Z</updated>
    
    <content type="html"><![CDATA[<h2 id="打造远离拖延的环境">打造远离拖延的环境</h2><h3 id="保持办公桌的干净整洁-–-断舍离">保持办公桌的干净整洁 – 断舍离</h3><ul><li>各种书籍、文件分类摆放</li><li>利用一些文具，诸如笔筒、书立、文件夹等</li><li>定时筛选、丢掉废弃纸质文件和其他垃圾</li><li>保留必须物品，其他的全部扔掉或者赠送给有需要的人</li></ul><h3 id="收起那些耽误正事的杂物">收起那些耽误正事的杂物</h3><ul><li>工作时手机关机（静音），必要时用电脑登录社交软件</li><li>卸载非必要APP，同种类型的只留下最好的那个</li><li>如果每天有大量信息需要处理，可以规划好每天固定的时间回复消息</li><li>不断进行心理暗示，不要在无聊的事情上浪费时间</li></ul><h3 id="远离假装努力的积极废人">远离假装努力的积极废人</h3><ul><li>少立flag</li><li>不要用战略上勤奋掩盖战术上的懒惰</li><li>主动远离懒惰、不自律者</li></ul><h3 id="让自己的生活尽量规律化">让自己的生活尽量规律化</h3><blockquote><p>真正规律化的生活是，在特定的时间做特定的事情，不要让一件事情上的焦虑影响另外一件事情的进行。</p></blockquote><ul><li>制定计划，合理分配时间</li><li>给自己留出独立的工作时间，减少干扰因素</li><li>将休闲娱乐与工作学习明确划分开</li><li>设置自我奖励机制，按时作息就奖励自己一个小礼物</li><li>让家人或朋友帮忙监督</li><li>利用好碎片化时间处理未完成的事情</li><li>睡前将手机等电子产品关机并收纳到抽屉里</li></ul><h3 id="及时疏解内在的消极情绪">及时疏解内在的消极情绪</h3><ul><li>倾诉，给压抑的心情一个出口</li><li>进行自我审视，找出消极情绪的根源</li><li>积极寻找帮助，切实解决问题</li><li>通过做自己喜欢的事情来打退消极情绪</li></ul><h3 id="多跟优秀自律的人在一起">多跟优秀自律的人在一起</h3><ul><li>跳出原本的惰性生活状态，主动向优秀的同事、朋友请教</li><li>利用互联网及时了解行业信息</li><li>关注行业中的佼佼者，通过互联网平台汲取经验</li><li>适当参加一些业内成功人士的分享活动</li><li>大胆迈出第一步，主动结识优秀者</li></ul><h2 id="设立有切实意义的目标">设立有切实意义的目标</h2><h3 id="用目标改变虚耗精力的状态">用目标改变虚耗精力的状态</h3><blockquote><p>“目标的坚定是性格中最必要的力量源泉之一，也是成功的利器之一，没有它，天才也会在矛盾屋顶的迷径中，徒劳无功”</p></blockquote><ul><li>你想在哪个领域获得成功</li><li>具体想得到什么样的收获</li><li>为了实现这个目标你要完成哪些事情</li><li>把这个事情分摊下来，每一天需要完成多少</li><li>思考在完成这件事情的过程中可能遇到的阻碍</li><li>你可能会因为什么原因放弃目标</li><li>怎样克服实现目标过程中的困难和阻碍因素</li><li>如果发现目标不恰当该如何调整</li><li>除了当前方案外是否还有plan B</li><li>你需要和谁一起完成这个目标</li></ul><h3 id="掌握指定目标的SMART原则">掌握指定目标的SMART原则</h3><ul><li>S（specific）： 明确性，不能笼统和抽象</li><li>M（measurable）：衡量性，即需要量化</li><li>A（attainable）：可实现性，目标不可过高或过低，要适量</li><li>R（realistic）：相关性，与主要目标要相关</li><li>T（time bound）：时限性，即完成目标的时间期限</li></ul><h3 id="为目标附加Deadline">为目标附加Deadline</h3><ul><li>番茄钟</li><li>设立deadline，不可太过迟缓，也不能操之过急</li></ul><h3 id="把大目标分解成小目标">把大目标分解成小目标</h3><blockquote><p>“每一步都走向一个最终要到达的目标，这并不够，应该每一站都有一个目标，每一步都有自有价值。”</p></blockquote><ul><li>把漫长的征途划分为一段一段，每当你到达一站的时候心理都会充满无尽的欢喜，然后充满激情的冲向下一站。</li></ul><h3 id="每天都要有可实现的目标">每天都要有可实现的目标</h3><blockquote><p>“合抱之木，生于毫末；九层之台，起于垒土；千里之行，始于足下。”</p></blockquote><h3 id="列好实现目标的具体步骤">列好实现目标的具体步骤</h3><ul><li>你想要实现什么样的目标？</li><li>为了实现这个目标你需要花多长时间？</li><li>要想实现这个目标你需要做哪些事情？</li><li>第一步是什么，需要在什么时间完成？</li><li>第二步，第三步，以及后续呢？</li><li>你的早晨、睡前这两个黄金时间如何安排？</li><li>如何完成这些具体的、细小的步骤？</li><li>当你遇到瓶颈的时候要怎么解决，咨询专业人士、上网查询资料或是其他？</li></ul><h3 id="有变动及时调整目标">有变动及时调整目标</h3><blockquote><p>一个正确的目标给人的动力是巨大的，而错误的目标却会把我们引入错误的方向，方向错，步步错。</p></blockquote><ul><li>有变动时，及时调整目标。</li></ul><h2 id="成为高校的行动派">成为高校的行动派</h2><h3 id="改掉习惯性担忧的毛病">改掉习惯性担忧的毛病</h3><blockquote><p>担忧可以归纳为：为已经发生的事情而担忧；为还没有发生的事情而担忧；担忧付出了努力却得不到满意的结果。</p></blockquote><ul><li>给自己心理暗示：担忧是无用的</li><li>找到担忧的原因，即：你面临着什么问题</li><li>思考解决问题的办法</li><li>明白这样一个道理：已经发生的事情，担忧没有用；还未发生的事情尚有时间想办法补救，担忧没有必要；努力了却不一定能成功的事情，做到内心无悔即可。</li><li>从生理上减缓担忧：运动、呼吸新鲜空气、拥有充分的睡眠和健康的饮食。</li><li>珍爱身边的朋友，建立积极的社交关系，可以向朋友诉说自己的担忧和苦恼</li><li>把目光放长远，保持心胸豁达</li><li>以一种平淡随然的态度面对生活</li></ul><h3 id="想做一件事立刻就行动">想做一件事立刻就行动</h3><blockquote><p>“我们一直推迟我们知道最终无法逃避的事情，这样的蠢行是一个普遍的人类弱点，它或多或少都盘踞在每个人的心灵里。”</p></blockquote><ul><li>做出初始行动 （前奏）</li></ul><h3 id="对抗趋乐避苦的懒惰本能">对抗趋乐避苦的懒惰本能</h3><ul><li><p>除了努力、拼命上进之外没有别的选择，为环境所迫，因而在极端的环境下爆发，为了生存只能吃苦磨砺，如果放弃挣扎选择了物质上的舒适，就意味着死亡或溃败。</p></li><li><p>有选择的空间，向前一步可以有更好的生活，向后一步也不至于落到深渊，一分耕耘一分收获。</p></li><li><p>行动力来源于清晰而深刻的认知。</p></li></ul><h3 id="今天的事不要推到明天做">今天的事不要推到明天做</h3><blockquote><p>“一天也不能虚度，要下定决心把可能完成的事情一把抓住然后紧紧抱住，有机会就绝不任其逃走，而且必定要贯彻执行”</p></blockquote><ul><li>把握好“黄金时间段”</li><li>抓住零碎时间</li><li>合理排序，科学工作</li><li>提高专注力</li></ul><h3 id="克服虎头蛇尾的三分钟热度">克服虎头蛇尾的三分钟热度</h3><ul><li>一段时间内只专注一件事</li><li>不断发掘生活的乐趣，避免陷入枯燥和厌倦的状态</li><li>指定循序渐进的计划</li><li>寻找志同道合的伙伴，互相监督、一起同行</li></ul><h3 id="讨厌的事情也得认真做好">讨厌的事情也得认真做好</h3><blockquote><p>很多人之所以拖延，是因为他讨厌某件事情</p></blockquote><ul><li>这件事情重要吗？</li><li>讨厌的原因是什么，是因为不擅长还是因为回报周期太长</li><li>做了这件不喜欢的事情你能收获什么？</li><li>如果不做会有什么样的后果？</li><li>你有选择不做的余地吗？</li><li>如果不做这件事情，你还有别的效益更大化的选择吗？</li><li>你有多长时间来完成这件事情，时间允许你拖延吗？</li><li>怎样才能让这个过程不那么枯燥？</li></ul><h2 id="让时间的价值最大化">让时间的价值最大化</h2><h3 id="把事情按照轻重缓急排序">把事情按照轻重缓急排序</h3><blockquote><p>以“价值”为基础排序。我们做任何事情都脱离不了其价值意义。</p></blockquote><ul><li>重要且紧急的事情</li><li>重要但不紧急的事情</li><li>紧急但不重要的事情</li><li>不紧急也不重要的事情</li></ul><h3 id="用好高效的“黄金时间”">用好高效的“黄金时间”</h3><blockquote><p>“普通人只想如何打发时间，有才能的人则设法利用时间。”</p></blockquote><ul><li>早晨6点（记忆力最佳）</li><li>8-10点（思维最活跃）</li><li>18-20点（最沉着）</li><li>入睡前的时间（加强记忆最好的时间）</li></ul><p>如何定位“黄金时间”</p><ul><li>在备忘录上列出每日事项</li><li>列出自己能够抽出来的所有时间</li><li>找出周围环境最好、最适宜的时间段，即为黄金时间</li><li>把最重要的事情放在“黄金时间”段完成</li><li>其他事项放在其他时间完成</li></ul><p>如何打造“黄金时间”</p><ul><li>自然环境上：以舒适、开阔、安静为重要元素</li><li>生理上：头脑清醒、充满活力、思维清晰的时间段最好</li><li>生活换教室：排除手机等移动设备的干扰，让自己更加专注</li><li>时间段的选取上：尽量选择大段的时间，不至于在执行任务的过程中被打断</li></ul><h3 id="重视不起眼的零碎时间">重视不起眼的零碎时间</h3><ul><li>利用“衔接式”时间</li><li>利用“并列式”时间</li><li>减少零碎时间</li></ul><h3 id="一次用心把事情做好">一次用心把事情做好</h3><blockquote><p>“逐二兔者不得其一”</p></blockquote><ul><li>人的精力有限</li><li>思绪具有连贯性</li><li>一次只做一件事</li></ul><h3 id="拒绝那些让自己分心的事">拒绝那些让自己分心的事</h3><blockquote><p>让我们分心的事情大概有：周围的环境；他人正在做的事情；乱七八糟的思绪；</p></blockquote><ul><li>删繁就简</li><li>摒弃杂念</li></ul><h3 id="无谓的细节无须浪费时间">无谓的细节无须浪费时间</h3><blockquote><p>把时间和精力花费在最重要的地方</p></blockquote><p>什么样的细节是无谓的细节</p><ul><li>日常生活中的细节</li><li>工作中的“次要任务”</li></ul><h3 id="掌握时间管理的二八法则">掌握时间管理的二八法则</h3><blockquote><p>用80%的时间去完成那最关键的20%的事情。</p></blockquote><p>如何确定那重要性为80%的事情?</p><ul><li>寻找效益最大化的事项</li><li>截止日期即将到来的事项</li></ul><h3 id="学会使用高效的番茄工作法">学会使用高效的番茄工作法</h3><p>番茄工作法的好处</p><ul><li>提升注意力，劳逸结合</li><li>减轻焦虑感，加强决心</li><li>改善任务流程，减少干扰因素</li></ul><h2 id="把逃避彻底删掉">把逃避彻底删掉</h2><h3 id="认识到问题与痛苦的价值">认识到问题与痛苦的价值</h3><blockquote><p>正路不一定就是一条平坦的直路，难免有曲折和崎岖坎坷，要绕一些弯，甚至难免会误入歧途。</p></blockquote><ul><li>攻克难题过程中收获的经验</li><li>苦尽甘来的收获</li></ul><h3 id="越是恐惧的事情越要去面对">越是恐惧的事情越要去面对</h3><ul><li>写出你的恐惧</li><li>列出最坏的结果</li><li>指定紧密的工作计划，用行动稀释恐惧</li></ul><h3 id="承认问题是解决问题的开始">承认问题是解决问题的开始</h3><blockquote><p>人们通常不会承认两类事情：不承认自我天赋的缺乏；不承认现实存在的、难以解决的问题。</p></blockquote><ul><li>不要对自己过于苛刻</li><li>让家人或朋友成为你的“参谋师”</li><li>明白一切问题都有解决的办法</li></ul><h3 id="不要总是指望别人替你解决问题">不要总是指望别人替你解决问题</h3><blockquote><p>“不论踩什么样的高跷，没有自己的能力是不行的。”</p></blockquote><ul><li>没有人能永远陪伴在你身边</li><li>人际关系的本质是潜在的价值交换</li></ul><p>什么时候靠自己，什么时候寻求帮助？</p><ul><li>能自己独立完成的任务不必寻求他人的帮助</li><li>自己努力一下就可以做到的事情不必劳烦他人</li><li>同事、朋友之间尽量互帮互助，不要单方面接受而不给与</li><li>在团队工作中公平分配任务</li><li>需要他人协助的事情可以向他人寻求帮助和支持</li></ul><h3 id="认清你给自己找的拖延借口">认清你给自己找的拖延借口</h3><blockquote><p>拖延的借口：问题难以解决，因此搁置；总认为还来得及；内心的恐惧；“我很忙”</p></blockquote><ul><li>眼下最紧急的事情是什么？</li><li>你最想做的事情是什么？</li><li>后一项是非做不可的吗？</li><li>思考“你想做的”和“你应该做的”这两件事会带来什么好处跟坏处？</li><li>哪些事效益最大化，损失最小化的事情？</li></ul><blockquote><p>“最珍贵的是今天，最容易失掉的也是今天。”</p></blockquote><h3 id="对工作保持积极主动的态度">对工作保持积极主动的态度</h3><ul><li>保持规律的作息、健康的饮食</li><li>给自己积极的心理暗示</li><li>常做那些“高能量姿势” （“神奇女校”姿势）</li></ul><h3 id="用“做做看”代替对结果的计较">用“做做看”代替对结果的计较</h3><blockquote><p>“现实是此案，理想是彼岸，中间隔着湍急的合理，行动则是加载川上的桥梁。”</p></blockquote><ul><li>“做”不是一个一成不变的过程</li><li>“做做看”的本质在于突破自我</li><li>珍惜试错的机会的成本</li></ul><h3 id="遇到困难不找借口找方法">遇到困难不找借口找方法</h3><blockquote><p>“人的一切痛苦，本质上都是对自己无能的愤怒。”</p></blockquote><ul><li>我应该怎样解决这个问题，并达到我的目标？</li></ul><h3 id="不求完美但求尽最大的努力">不求完美但求尽最大的努力</h3><blockquote><p>相较于成为一名“完美主义者”，你应该成为一名“现实主义者”。</p></blockquote><ul><li>不存在绝对的完美</li><li>人的欲望是无止境的</li><li>过程比结果更重要</li><li>真实比完美更有力量</li></ul><h3 id="敢于平凡让你更有“底气”">敢于平凡让你更有“底气”</h3><ul><li>平凡不等于平庸</li></ul><h2 id="拆掉思维的壁垒">拆掉思维的壁垒</h2><h3 id="删除“我必须”的思维模式">删除“我必须”的思维模式</h3><ul><li>“我必须”表现出来的是一种不自信，而“我可以”、“我能做到”则是一种自信满满的状态。</li></ul><h3 id="认清自己的长板与短板">认清自己的长板与短板</h3><ul><li>多多尝试新事物，开拓新领域</li><li>采纳他人的合理意见和建议</li></ul><h3 id="绷得太紧时让自己停下来">绷得太紧时让自己停下来</h3><ul><li>身体上的休息</li><li>心理上的缓冲</li></ul><h3 id="别担心达不到完美的结果">别担心达不到完美的结果</h3><ul><li>这种担心是无效担心</li><li>100分纵然完美，80分也可以</li><li>苛求完美会给人带来巨大的压力</li></ul><h3 id="没有尝试之前别给自己设限">没有尝试之前别给自己设限</h3><blockquote><p>还没尝试就设限的人一般处于什么心理：自卑，认为自己不配得到更好的东西；过度重视外在因素的重要性</p></blockquote><ul><li>大胆说出你内心的渴望</li><li>大胆尝试和追求那些你以前不敢奢求的事物</li></ul><h3 id="努力跳出熟悉的心理舒适区">努力跳出熟悉的心理舒适区</h3><ul><li>那些看似“舒适”的状态，往往只是表象</li><li>一时的舒适并不能代表会一直舒适</li></ul><h3 id="防止过分内疚消耗你的精力">防止过分内疚消耗你的精力</h3><ul><li>告别内疚，无须在意他人的眼光</li><li>拖延不好，但只要按部就班做出改变，一定会发生转机</li></ul><h2 id="用自律换得自由">用自律换得自由</h2><h3 id="用延迟满足击退拖延的念头">用延迟满足击退拖延的念头</h3><ul><li>选择做重要且紧急的事情会有什么结果</li><li>选择做短暂又吸引人的事情会有什么结果</li></ul><h3 id="给自己设置一个合理的期望值">给自己设置一个合理的期望值</h3><p>什么是&quot;合理&quot;</p><ul><li>基于现实</li><li>比自己的实际水平稍高一点</li><li>设置你独特的期望值</li></ul><blockquote><p>这一路也行风雨兼程，但请你始终保持可贵的清醒，不要美化过程，不要自怨自艾，一切以客观现实为基础，希望你能成为那个“手可摘星辰”的人。</p></blockquote><h3 id="利用增长的事慢慢建立自信">利用增长的事慢慢建立自信</h3><blockquote><p>“要有信心，然后全力以赴——假如具有这种观念，任何事情十有八九都能成功。”</p></blockquote><ul><li>找到你擅长的事情</li><li>把擅长的事情做到极致</li><li>把擅长的事情和事业相结合</li></ul><h3 id="把自己想象成不拖延的人">把自己想象成不拖延的人</h3><ul><li>“见贤思齐”</li></ul><h3 id="懈怠时开启自我激励模式">懈怠时开启自我激励模式</h3><ul><li>强迫自己回想一遍最初的目标</li><li>看激励人心的影片、听励志音乐</li><li>对自己说：再坚持一会儿</li><li>主动向优秀的人看齐</li></ul><h3 id="借助奖惩措施改变行为模式">借助奖惩措施改变行为模式</h3><ul><li><p>作为“奖励”和“惩罚”的事物要精挑细选<br>作为奖励的事物，应该是你发自内心喜欢的，位于寻常生活只外的东西。<br>作为惩罚的事物，应当是你感性上渴望但理智上应该拒绝的事物。</p></li><li><p>不要为了“拿到奖励”而工作</p></li><li><p>设置奖惩措施，可以从小事做起</p></li></ul><h3 id="多给自己一些积极的暗示">多给自己一些积极的暗示</h3><ul><li><p>心理暗示不同于自我欺骗<br>前者是缺乏自信和勇气<br>后者是无中生有</p></li><li><p>了解一个人是很难的事情，与其向外界寻求肯定，不如向内寻找价值。</p></li></ul><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://www.amazon.cn/dp/B0828N77XX" target="_blank" rel="noopener">超级自控力训练计划</a></p>]]></content>
    
    <summary type="html">
    
      拖延的本质来源于内心的恐惧。这个恐惧有两层含义：任务本身的艰巨性；害怕失败带来的结果。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="SoftSkills" scheme="https://neo1989.net/tags/SoftSkills/"/>
    
  </entry>
  
  <entry>
    <title>《沟通力》</title>
    <link href="https://neo1989.net/Notes/NOTE-ke-fu-zhi-de-gou-tong-li/"/>
    <id>https://neo1989.net/Notes/NOTE-ke-fu-zhi-de-gou-tong-li/</id>
    <published>2021-03-23T15:27:56.000Z</published>
    <updated>2023-01-13T03:02:04.862Z</updated>
    
    <content type="html"><![CDATA[<h2 id="沟通力是可以复制的">沟通力是可以复制的</h2><blockquote><p>如果说人类社会是一张网，那么每个人就是网上的结点，而人与人之间必须有线，才能互相连接，否则这些结点就无法形成网，无法成为组织、成为社会。人与人之间的这根“线”就是沟通。</p></blockquote><h3 id="沟通力为什么如此重要">沟通力为什么如此重要</h3><ul><li>提升社会竞争力</li><li>加速事业的成功</li><li>人际关系的润滑剂</li></ul><h3 id="沟通的目标不是“口服”而是“心服”">沟通的目标不是“口服”而是“心服”</h3><ul><li>有明确的沟通目标</li><li>善用语气、语调</li><li>用肢体语言为沟通加分</li></ul><h3 id="信息的准确传递与接收">信息的准确传递与接收</h3><ul><li>能够准确地表达自己的感受</li><li>表达时要直接、精确</li><li>运用深夜电台主持人般的声音 (温柔、缓慢、深沉)</li></ul><h3 id="每个人都能学会的沟通力">每个人都能学会的沟通力</h3><ul><li>学习科学的理论 (真实，完整，时效，同一，目标明确)</li><li>掌握正确的方法</li><li>一定要刻意练习</li></ul><h2 id="沟通的本质是尊重与合作">沟通的本质是尊重与合作</h2><blockquote><p>“尊人者，人尊之。”沟通中如果缺乏尊重，不能平衡自己与对方的需要，总以一种自以为是的方式与对方交流，这样的沟通是很难进行的。只有学会尊重与合作，沟通的过程才会愉快而积极，结果才能如你所愿。</p></blockquote><h3 id="了解自己对恐惧的反应">了解自己对恐惧的反应</h3><ul><li><p>合作为什么越来越难？<br>我们之所以生气、愤怒，其实是内心的恐惧在作祟</p></li><li><p>恐惧的根源<br>我们无法完全掌控局面的时候</p></li></ul><h3 id="从对方的视角看他的经历">从对方的视角看他的经历</h3><ul><li><p>什么是真正的尊重？<br>真正的尊重，应该是从他人的视角去看他们所经历的一切，也就是了解对方的“being”，哲学上称为“存在”。简而言之，就是了解对方此刻存在的状态是什么。</p></li><li><p>懂得尊重自己<br>“我”为什么会这样？“我”的哪些需要没有获得满足？</p></li><li><p>尊重是为了促进共赢</p></li></ul><h3 id="平衡自己与他人的需要">平衡自己与他人的需要</h3><ul><li><p>委屈和讨好<br>对自己的需要不太关注或关注度很低，总是把别人的需要放在第一位。（老好人）</p></li><li><p>控制和强势<br>对他人关注极少、只关注自己的需求。</p></li><li><p>忽视和无助<br>既不关注自己的需要，也不关注别人的需要。（不愿沟通）</p></li><li><p>尊重与合作<br>既关注他人的需要，也不忽视自己的需要。</p></li></ul><h3 id="学会处理情绪和信息">学会处理情绪和信息</h3><ul><li><p>知心大姐式<br>只关注其中的情感和关系。</p></li><li><p>冷面杀手式<br>永远只谈实际问题，从不谈感情。</p></li><li><p>拒绝沟通式<br>既不跟你谈信息，也不跟你谈感情，完全是一副拒绝沟通的模式。</p></li><li><p>沟通专家式<br>既会照顾对方的情感，也很懂得处理实际问题。</p></li></ul><h3 id="沟通之前先明确目标">沟通之前先明确目标</h3><ul><li>怎么才能记住沟通的目标<br>你要为自己创造什么？<br>你要为对方创造什么？<br>你需要为你们的关系创造什么？</li></ul><h3 id="不尊重的沟通方式有哪些">不尊重的沟通方式有哪些</h3><ul><li>喜欢给对方贴标签</li><li>忽视对方的感受</li><li>用威胁的口气说话</li><li>喜欢与别人攀比</li></ul><h2 id="沟通高手都善于掌控情绪">沟通高手都善于掌控情绪</h2><blockquote><p>当我们在沟通中遭遇不愉快，进而产生消极的情绪变化或心理状态时，最重要的是控制这种糟糕的情绪或心理蔓延，别让自己被情绪所左右，否则沟通效率会大打折扣。</p></blockquote><h3 id="停止你的暴力沟通">停止你的暴力沟通</h3><ul><li><p>暴力沟通如何出现的<br>道德评判<br>进行比较<br>回避责任<br>强人所难</p></li><li><p>沟通的公式<br>“我观察到……”<br>“我感觉……”<br>“是因为……”<br>“我请求……”</p></li></ul><h3 id="远离“傻瓜式”沟通">远离“傻瓜式”沟通</h3><ul><li>学会打破大脑中的思维惯性<br>更多地调动大脑前庭和大脑皮层的作用，去克服杏仁核和基底核给我们的沟通带来的情绪影响，远离“傻瓜式”沟通。</li></ul><h3 id="奖惩式沟通的代价">奖惩式沟通的代价</h3><ul><li><p>奖惩式沟通的表现<br>你表现好，我就奖励你；表现不好，我就惩罚你。</p></li><li><p>代价<br>破坏对方的安全感和信任感<br>打压对方的内驱力<br>剥夺了对方与你合作的快乐和愿望<br>让对方学会了用奖励和惩罚获得他想要的东西</p></li></ul><h3 id="沟通中切忌挖苦嘲笑">沟通中切忌挖苦嘲笑</h3><ul><li>明确沟通目的，理性交流</li><li>批评可以直接客观</li></ul><h3 id="不抱怨，把握沟通的尺度">不抱怨，把握沟通的尺度</h3><ul><li>表达感受，提出诉求</li><li>阐述诉求的原因</li><li>向对方提出你的建议</li></ul><h3 id="利用复述和认同感染对方">利用复述和认同感染对方</h3><ul><li><p>重复对方所说的话</p></li><li><p>告诉对方“你说得对”<br>让自己和对方产生一种情绪联结。</p></li></ul><h2 id="沟通要从了解需求开始">沟通要从了解需求开始</h2><blockquote><p>需求是沟通当中的重要因子，凡是沟通中出现的问题，多数是由需求不清晰或需求未能获得满足所致。这里的需求，既包括他人的需求，也包括自我需求。</p></blockquote><h3 id="洞悉对方真正需求，避免情绪积累">洞悉对方真正需求，避免情绪积累</h3><h3 id="人类共通的需求名单">人类共通的需求名单</h3><ul><li>朋友、集体、归属感</li><li>放松、休息、快乐</li><li>关注、理解、倾听</li><li>学习、探索、发现</li><li>选择、自由、自我</li><li>被认可、信任感、安全感</li><li>支持、尊重、爱</li></ul><h3 id="发掘和关注自我需求">发掘和关注自我需求</h3><h3 id="用给予礼物的心态去沟通">用给予礼物的心态去沟通</h3><ul><li>给予是人类的基本需求之一</li><li>你与他人有许多“礼物”可以互相给予</li><li>学会辨识“礼物”</li><li>慷慨地将“礼物”给予他人</li><li>从他人给予的“礼物”中学习和成长</li></ul><h3 id="让对方看到更多的选择空间">让对方看到更多的选择空间</h3><ul><li>具有富足心态的人看到的永远是自己拥有什么，自己还有哪些可选择的空间和可能性。</li><li>匮乏心态的本质就是“没的选”</li></ul><h2 id="营造安全的沟通氛围">营造安全的沟通氛围</h2><blockquote><p>当我们按照惯性思维与别人谈话时，通常会用自己最习惯的方式，但我们的惯性思维很可能让对方感觉不安全。这时候我们就需要打破惯性思维，主动营造一个安全的沟通氛围。</p></blockquote><h3 id="找到共同目的，让对方感受到理解">找到共同目的，让对方感受到理解</h3><ul><li><p>找出对方的真实目的，塑造共同目的<br>先一步做出让步。<br>进一步了解对方的真实目的。<br>塑造共同目的。</p></li><li><p>拓宽视野，塑造长远的共同目的</p></li><li><p>寻找联结，维护安全感，保持目的一致性</p></li></ul><h3 id="利用对比说明，防止冒犯和伤害">利用对比说明，防止冒犯和伤害</h3><ul><li>阐明自己的真实目的</li><li>说明你不想看到的结果</li><li>寻找一个两全其美的方法</li></ul><h3 id="标注对方情感，赢得对方接纳">标注对方情感，赢得对方接纳</h3><ul><li>定位情感：了解对方最关注什么</li><li>标注的常用句式：“看上去”“听起来”“似乎……”</li></ul><h3 id="合理使用道歉和“拔刺”">合理使用道歉和“拔刺”</h3><ul><li>道歉：当对方被激怒的时候</li><li>“拔刺”：当谈话还没正式开始的时候</li></ul><h3 id="气氛不对时先关注情绪再关注内容">气氛不对时先关注情绪再关注内容</h3><ul><li><p>学会做一个双核的对话人<br>一个核负责管理氛围、情绪，另一个核负责管理信息、内容。</p></li><li><p>通过心律共鸣营造气场</p></li><li><p>调整气场的几个高能量姿势<br>学学神奇女侠<br>练练瑜伽</p></li></ul><h2 id="用长颈鹿式沟通破解沟通困境">用长颈鹿式沟通破解沟通困境</h2><blockquote><p>长颈鹿有三个特点：高、反应慢、心脏大，这三个特点可以巧妙地运用到我们的沟通当中。心大，遇事不计较；反应慢，从不觉得什么事都会对自己有伤害；再加上它站得高，看得远，不会对眼前的小事斤斤计较。</p></blockquote><h3 id="长颈鹿式沟通的优势">长颈鹿式沟通的优势</h3><ul><li><p>高<br>站得高，可以看得远</p></li><li><p>反应慢<br>具备钝感力的人，大多会从容面对生活中的挫折和伤痛，也会坚定朝着自己的方向前进。</p></li><li><p>心脏大<br>不往心里去。</p></li></ul><h3 id="什么是长颈鹿式沟通">什么是长颈鹿式沟通</h3><ul><li><p>观察：只讲事实，不加入评判<br>把你看到和听到的东西准确地描述出来</p></li><li><p>感受：说出真实感受，挖掘真实需要<br>虽然感同身受有些难，但是沟通双方达成理解和包容却是可行的。<br>夫妻之间为什么总会发生争吵？因为我们所表达出来的通常都不是我们真实的感受，而是通过带有评判的观察之后臆测出来的对方的行为，这时候的沟通自然已经完全变了味，吵架也就在所难免了。</p></li><li><p>行动：提出具体可执行的请求</p></li></ul><h2 id="如何有效提问与倾听">如何有效提问与倾听</h2><blockquote><p>巧妙地提问可以促使对方进行深入思考，唤醒对方的内在动力，使对方努力去改变自己；倾听则既能满足他人自我表达的需要，又能巩固人与人之间的联结。只有学会提问和倾听，才能成为真正的沟通高手。</p></blockquote><h3 id="不要把建议变成批评">不要把建议变成批评</h3><ul><li><p>明确对方请教的真实意图</p></li><li><p>什么是内在动力？<br>你的内心当中想要把一件事做好的欲望。</p></li><li><p>用提问唤起对方的内在动力<br>通过恰当的提问和启发，引导对方深入、广泛地进行思考，让对方自己找到解决问题的方法，他的问题才能真正解决。</p></li></ul><h3 id="质疑式提问会打击对方积极性">质疑式提问会打击对方积极性</h3><p>提问是为了引发思考，而不是要将你的答案和解决方案直接告诉他人，以展示自己的分析和方案有多智慧，哪怕你心里有更好的答案也不要抢着说，而应通过巧妙地提问让对方先说出答案。同时，恰当的提问也能促使双方共同探讨，这样的沟通才会更加有效。</p><h3 id="启发式提问能激发对方责任感">启发式提问能激发对方责任感</h3><ul><li><p>什么是启发式提问<br>就是向对方提出一些带有启发性的问题，帮助对方的大脑打开一个新的窗口，让对方感觉“我真的没有思考过这些问题”，然后引导对方对这些问题进行深入的梳理，寻找能够真正解决问题的方法。</p></li><li><p>改变现状的标准路径<br>第一步: 觉知，即通过启发让一个人知道他有哪些问题，为什么自己会出现这些问题<br>第二步: 接纳，接纳自己的现状，哪怕现在的自己很糟糕，我们也仍然爱自己<br>第三部: 改变现状。</p></li><li><p>好的提问可以激发对方的行动</p></li></ul><h3 id="提问时对方才是主角">提问时对方才是主角</h3><ul><li><p>启发式提问分为三步<br>询问目标<br>询问现状<br>询问可选择的方法和路径</p></li><li><p>“我也没办法”<br>人会陷入一种“限制性想法”当中。什么是限制性想法？就是人会自己给自己设定很多限制，这些限制会让我们不敢或不愿去想。</p></li></ul><h3 id="放下自我，学会倾听">放下自我，学会倾听</h3><ul><li><p>我们为什么不愿倾听<br>放不下自己。<br>急于反驳。如果反驳效果不佳，我们又可能产生负面的情绪反应。</p></li><li><p>适当给予对方反馈</p></li><li><p>善于在倾听中吸收对方的信息</p></li><li><p>如何倾听<br>深呼吸<br>提问<br>复述</p></li></ul><h3 id="打造沟通的无错区">打造沟通的无错区</h3><p>“无错区”的意思其实是要将沟通双方的关注力从表面的“错误”转向深层的“需要”。</p><ul><li>将冲突看成一个需要解决的问题</li><li>确信你的需求可以获得满足</li><li>相信需求可以引出解决方案</li><li>用合作和联结化解冲突</li><li>对有效的方法庆祝，对无效的方法学习</li></ul><h2 id="用身体语言认识自己和他人">用身体语言认识自己和他人</h2><blockquote><p>人们总是会通过自己的肢体语言、面部表情和微妙暗示向他人传递各种信息，如果我们能正确判断这些信息，沟通就会变得愉快而顺畅。</p></blockquote><h3 id="避免用肢体语言暴露内心所想">避免用肢体语言暴露内心所想</h3><ul><li>减少缺乏自信的手势</li><li>注意紧张时的肢体动作</li></ul><h3 id="一眼看穿对方的微表情">一眼看穿对方的微表情</h3><ul><li>从面部表情猜测对方的情绪</li><li>小动作中表现出来的情绪</li></ul><h3 id="眼神透露出的心理活动">眼神透露出的心理活动</h3><ul><li>视线下移是在掩饰自己的胆怯和不自信</li><li>眼球快速转动是恐惧的表现</li><li>瞳孔变化暗示心理活动</li></ul><h3 id="展现高能量的身体姿态">展现高能量的身体姿态</h3><ul><li>运用与生俱来的骄傲姿态</li><li>正确运用体态语言的沟通力量</li><li>假装自己已经达成沟通目标</li></ul><h3 id="利用心理暗示调节自己的状态">利用心理暗示调节自己的状态</h3><ul><li>引导对方点头</li><li>用缓慢的语速说话</li><li>用表情和肢体动作改变情绪</li></ul><h2 id="让文字发挥力量">让文字发挥力量</h2><blockquote><p>相较于面对面的语言沟通，文字沟通会给沟通双方更多的思考时间，同时在传递语气和情绪方面也更考验智慧。</p></blockquote><h3 id="让文字沟通更专业和精准">让文字沟通更专业和精准</h3><ul><li>配合电话或会议</li><li>商务类书信的沟通</li><li>求职时要运用文字沟通</li></ul><h3 id="发挥文字沟通的优势">发挥文字沟通的优势</h3><ul><li>给彼此留出思考反应的时间</li><li>增加沟通的可信度</li></ul><h3 id="让文字沟通更高效的四个方法">让文字沟通更高效的四个方法</h3><ul><li>沟通目的要明确</li><li>信息传递要完整、准确</li><li>行文简洁，重点突出</li><li>语言表达恰当、合理</li></ul><h2 id="善用沟通力，提升决策力和影响力">善用沟通力，提升决策力和影响力</h2><blockquote><p>在需要做出决策和提升影响力时，高效的沟通力至关重要。出色的沟通力不仅能缓解你的紧张情绪，还能让你的发言更加吸引人，获得听众的共鸣。</p></blockquote><h3 id="如何在会议上高效沟通">如何在会议上高效沟通</h3><ul><li>会前准备充分</li><li>与会人员角色明确</li><li>学会换位思考</li><li>会议要充满创意</li><li>流程科学有序</li></ul><h3 id="利用头脑风暴法激发创意">利用头脑风暴法激发创意</h3><ul><li><p>对提出的意见不讨论、不评价</p></li><li><p>对各种观点都不要急于否认</p></li><li><p>头脑风暴法的流程<br>第一，明确本次会议讨论的具体问题，并且问题越具体、越详细越好。<br>第二，每个人都不要急于发言，而是先针对这个具体问题认真构思一下，把自己的想法整理下来。这个记录的过程就给了与会者独立思考的时间，有益于形成真正独特的思考。<br>第三，各自阐述，不对其他人的观点提出意见。在别人阐述观点时，我们也可以结合自己的想法继续完善方案，这样才能呈现出更多、更有效的解决方案。</p></li></ul><h3 id="六顶思考帽，让会议流程更科学">六顶思考帽，让会议流程更科学</h3><ul><li><p>“蓝帽子”思维<br>代表指挥官，担任着会议中指挥者或主持人的角色。</p></li><li><p>“白帽子”思维<br>代表理性和数据。</p></li><li><p>“黄帽子”思维<br>代表的就是乐观的、有希望的、有建设性的观点。</p></li><li><p>“黑帽子”思维<br>代表着否定、怀疑以及诸多问题，也就是我们常说的批判性思维。</p></li><li><p>“红帽子”思维<br>代表的是感觉、感受、直觉、预感等。</p></li><li><p>“绿帽子”思维<br>表示可以尽情地发挥自己的想象力和创造力，提出各种创意和解决问题的方法。</p></li></ul><h3 id="用平行思维法减少决策风险">用平行思维法减少决策风险</h3><h3 id="三步走，组织高效演讲">三步走，组织高效演讲</h3><ul><li><p>坡道<br>构建坡道的方法有很多，但要构建精彩的坡道只需思考一个问题：听众为什么要在意你的演讲？这个问题的答案就是一个绝妙的坡道。<br>坡道就是要把听众拉到你的演讲当中来。但有一点要注意，就是坡道的时间不要太长，你只有7秒钟的时间可用。</p></li><li><p>发现<br>用坡道成功地捕获了听众的注意力后，你即将说出自己的见解，应该可以引导听众有所发现和收获，而不是强制性地将信息灌输到他们的大脑之中。</p></li><li><p>甜点<br>这里要引起听众的情感共鸣，为听众创造一种感觉，比如紧迫感、诱惑感、惊喜感等。</p></li></ul><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://www.amazon.cn/dp/B088K5SQSM/" target="_blank" rel="noopener">可复制的沟通力</a></p>]]></content>
    
    <summary type="html">
    
      “克己复礼为仁”
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="SoftSkills" scheme="https://neo1989.net/tags/SoftSkills/"/>
    
  </entry>
  
  <entry>
    <title>《实用统计学》</title>
    <link href="https://neo1989.net/Notes/NOTE-practical-statistics/"/>
    <id>https://neo1989.net/Notes/NOTE-practical-statistics/</id>
    <published>2021-02-14T06:53:02.000Z</published>
    <updated>2023-01-13T03:04:27.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="探索性数据分析">探索性数据分析</h2><h3 id="结构化数据的组成">结构化数据的组成</h3><ul><li><p>连续型数据 (区间数据、浮点型数据、数值数据)<br>数据可在一个区间内取任何值。</p></li><li><p>离散型数据 (整数型数据、计数型数据)<br>数据只能取整数，例如计数。</p></li><li><p>分类型数据 (枚举数据、列举数据、因子数据、标称数据、多分支数据)<br>数据只能从特定集合中取值，表示一系列可能的分类。</p></li><li><p>二元数据 (二分数据、逻辑型数据、指示器数据、布尔型数据)<br>一种特殊的分类数据，数据值只能从两个值中取其一（例如0或1, True或False）。</p></li><li><p>有序数据 (有序因子数据)<br>具有明确排序的分类数据。</p></li></ul><blockquote><p>在软件中，数据通常按类型分类。<br>数据类型包括连续型数据、离散型数据、分类数据（其中包括二进制数据）和有序数据。<br>数据分类为软件指明了数据的处理方式。</p></blockquote><h3 id="矩形数据">矩形数据</h3><ul><li><p>数据框<br>电子表格等矩形数据是统计和机器学习模型中的基本数据结构。</p></li><li><p>数据特征 (属性、输入、预测因子、变量)<br>通常称数据表中的一列为一个特征。</p></li><li><p>结果 (因变量、响应、目标、输出)<br>不少数据科学项目涉及对结果的预测，常见的结果为“是”或“否”。特征有时在实验或研究中用于预测结果。</p></li><li><p>记录 (事例、例子、实例、观察、模式、样本)<br>通常称数据表中的一行为一条记录。</p></li></ul><blockquote><p>矩阵是数据科学中的基本数据结构。在矩阵中，行是记录，列是变量（特征）。<br>术语中会存在一些令人困惑之处。在与数据科学相关的各学科中，例如统计学、计算机科学和信息技术等，存在着一系列的同义词。</p></blockquote><h3 id="位置估计">位置估计</h3><ul><li><p>均值 (平均值)<br>所有数据值之和除以数值的个数。</p></li><li><p>加权均值 (加权平均值)<br>各数值乘以相应的权重值，然后加总求和，再除以权重的总和。</p></li><li><p>中位数 (第50百分位数)<br>使得数据集中分别有一半数据位于该值之上和之下。</p></li><li><p>加权中位数<br>使得排序数据集中分别有一半的权重之和位于该值之上和之下。</p></li><li><p>切尾均值 (截尾均值)<br>在数据集剔除一定数量的极值后，再求均值。</p></li><li><p>稳健 (耐抗性)<br>对极值不敏感。</p></li><li><p>离群值 (极值)<br>与大部分数据值差异很大的数据值。</p></li></ul><blockquote><p>均值是一种基本的位置度量，但是对极值（离群值）敏感。<br>其他一些度量更为稳健，例如中位数和切尾均值。</p></blockquote><h3 id="变异性估计">变异性估计</h3><ul><li><p>偏差 (误差、残差)<br>位置的观测值与估计值的直接差异。</p></li><li><p>方差 (均方误差)<br>对于n个数据值，方差是对距离均值的偏差平方后求和，再除以n-1。</p><p>计算方差时的被除数为什么是n-1，而不是n？这一讨论引出了自由度的概念。<br>如果在方差公式中使用了直观的除数n，那么就会低估方差的真实值和总体的标准偏差。这被称为有偏估计。<br>但是，如果除以n-1而不是n，这时标准偏差就是无偏估计。<br>自由度考虑了计算估计量中的限制个数。在这种情况下，自由度是n-1，因为其中有一个限制：<br>标准偏差依赖于计算样本的均值。</p></li><li><p>标准偏差 (L2范数、欧几里得范数)<br>方差的平方根。</p></li><li><p>平均绝对误差 (L1范数、曼哈顿范数)<br>对数据值与均值间偏差的绝对值计算均值。</p></li><li><p>中位数绝对偏差<br>数据值与中位数间绝对偏差的均值。</p></li><li><p>极差<br>数据集中最大值和最小值间的差值。</p></li><li><p>顺序统计量 (秩)<br>基于从大到小排序的数据值的度量。</p></li><li><p>百分位数 (四分位数)<br>表示一个数据集中，P%的值小于或等于第P百分位数，(100-P)%的值大于或等于第P百分位数。</p></li><li><p>四分位距 (四分位差)<br>第75百分位数和第25百分位数间的差值。</p></li></ul><blockquote><p>方差和标准偏差是日常最广为使用的变异性统计量。<br>方差和标准偏差都对离群值敏感。<br>更稳健的度量包括偏离均值（百分位数、四分位距）的平均（中位数）绝对偏差。</p></blockquote><h3 id="探索数据分布">探索数据分布</h3><ul><li><p>箱线图 (箱形图、箱须图)<br>图基提出的一种绘图，是一种快速可视化数据分布情况的方法。</p></li><li><p>频数表<br>将数值型数据的计数情况置于一组间隔（组距）中。</p></li><li><p>直方图<br>对频数表的绘图，其中x轴是组距，y轴是计数（或比例）。</p></li><li><p>密度图<br>直方图的平滑表示，通常基于某种核密度估计。</p></li></ul><blockquote><p>频数直方图在y轴上绘制频数计数，在x轴上绘制变量值。它提供了对数据分布的概览。<br>频数表是直方图中频数计数的表格形式。<br>在箱线图中，箱子的顶部和底部分别表示第75百分位数和第25百分位数。箱线图也提供了数据分布的基本情况。多个箱线图通常是并排展示的，以便于比较分布情况。<br>密度图是直方图的一种平滑表示。它需要一个基于数据估计绘图的函数（当然也可以做多个估计）。</p></blockquote><h3 id="探索二元数据和分类数据">探索二元数据和分类数据</h3><ul><li><p>众数<br>数据集中出现次数最多的类别或值。</p></li><li><p>期望值<br>如果类别可以与一个数值相关联，可以根据类别的出现概率计算一个平均值。</p></li><li><p>条形图<br>在绘图中，以条形表示每个类别出现的频数或占比情况。</p></li><li><p>饼图<br>在绘图中，圆饼中的一个扇形部分表示每个类别出现的频数或占比情况。</p></li></ul><blockquote><p>分类数据通常按比例总结，可以使用条形图将它可视化。<br>类别用于表示不同类型的事物（例如苹果和橘子，男性和女性）、因子变量的等级（例如低、中和高），或由组距分隔的数值型数据。<br>期望值是对每个数值与该数值出现概率的乘积求和，通常用于总结因子变量的等级</p></blockquote><h3 id="相关性">相关性</h3><ul><li><p>相关系数<br>一种用于测量数值变量间相关程度的度量，取值范围在-1到+1之间。</p></li><li><p>相关矩阵<br>将变量在一个表格中按行和列显示，表格中每个单元格的值是对应变量间的相关性。</p></li><li><p>散点图<br>在绘图中，x轴显示一个变量的值，y轴显示另一个变量的值。</p></li></ul><blockquote><p>相关系数测量了两个变量间相互关联的程度。<br>如果变量v1的高值随变量v2的高值的变化而变化，那么v1和v2是正相关的。<br>如果变量v1的高值与变量v2的低值的变化相关联，那么v1和v2是负相关的。<br>相关系数是一种标准化的度量，因此其值的范围处于-1（完全负相关）和+1（完全正相关）之间。<br>如果相关系数为0，那么表示两个变量间没有相关性。但是注意，数据的随机排列将会随机生成正的或负的相关系数。</p></blockquote><h3 id="探索两个及以上变量">探索两个及以上变量</h3><ul><li><p>列联表<br>一种对两个或两个以上分类变量做计数的表格。</p></li><li><p>六边形图<br>一种用于两个数值变量的绘图，图中使用六边形表示记录的组距。</p></li><li><p>等势线图<br>一种类似于地形图的绘图，显示了两个数值型变量的密度情况。</p></li><li><p>小提琴图<br>一种类似于箱线图的绘图，但是显示的是密度估计量。</p></li></ul><blockquote><p>六边形图和等势线图是有用的工具，它们支持以图形方式同时查看两个数值型变量，不会受数据规模的影响。<br>列联表是一种查看两个分类变量计数情况的标准工具。<br>箱线图和小提琴图允许根据分类变量绘制数值型变量。</p></blockquote><h2 id="数据和抽样分布">数据和抽样分布</h2><h3 id="随机抽样和样本偏差">随机抽样和样本偏差</h3><ul><li><p>样本<br>大型数据集的一个子集。</p></li><li><p>总体<br>一个大型数据集，或是一个构想的数据集。</p></li><li><p>N（或n）<br>一般用N表示总体的规模，n表示样本的规模。</p></li><li><p>随机抽样<br>从总体中随机抽取元素到样本中。</p></li><li><p>分层抽样<br>对总体分层，并在每层中做随机抽样。</p></li><li><p>简单随机抽样<br>在不对总体分层的情况下，做随机抽样所得到的样本。</p></li><li><p>样本偏差<br>样本对总体做出了错误的解释。</p></li></ul><blockquote><p>即便是在大数据时代，随机抽样依然是数据科学家的一种重要手段。<br>由于测量或观测不能代表总体而出现系统性误差时，就会产生偏差。<br>数据的质量通常比数量更重要，而随机抽样可以降低偏差，提高数据的质量（否则，实现成本可能很高）。</p></blockquote><h3 id="选择偏差">选择偏差</h3><ul><li><p>偏差<br>系统性误差。</p></li><li><p>数据窥探<br>为得到感兴趣的结果，在数据中做大量的查找。</p></li><li><p>大规模搜索效应<br>由于重复的数据建模，或使用大量的预测变量对数据建模所导致的偏差或非可重现性。</p></li></ul><blockquote><p>指定一个假设，然后遵循随机化和随机抽样的原则收集数据，可以确保不会产生偏差。<br>所有其他类型的数据分析都有产生偏差的风险，风险来自数据的采集和分析过程，包括在数据挖掘中反复地运行模型、在研究中窥探数据，以及事后选取有意义的事件。</p></blockquote><h3 id="统计量的抽样分布">统计量的抽样分布</h3><ul><li><p>样本统计量<br>对抽取自大规模总体中的样本做计算，所得到的一些度量值。数据分布</p></li><li><p>数据分布<br>单个值在数据集中的频数分布。</p></li><li><p>抽样分布<br>一个样本统计量在多个样本或重抽样中的频数分布。</p></li><li><p>中心极限定理<br>当样本的规模增大时，抽样分布呈正态分布的趋势。</p></li><li><p>标准误差<br>多个样本间样本统计量的变异性（标准偏差）。不要与标准偏差混淆，后者指的是个体数据值间的变异性。</p></li></ul><blockquote><p>样本统计量的频数分布表明了度量在各个不同抽样间的变化情况。<br>抽样分布可以使用自助法估计，也可以通过依赖于中心极限定理的公式计算得到。<br>标准误差是一个关键的度量，它汇总了抽样统计量的变异性。</p></blockquote><h3 id="自助法">自助法</h3><ul><li><p>自助样本（bootstrap sample）<br>从观测数据集中做有放回的抽取而得到的样本。</p></li><li><p>重抽样<br>在观测数据中重复抽取样本的过程，其中包括自助过程和置换（混洗）过程。</p></li></ul><blockquote><p>自助法（即对数据集做有放回的抽样）是一种评估样本统计量变异性的强大工具。<br>自助法可以类似的方式应用于各种场景中，无须深入探究抽样分布的数学近似。<br>自助法可以在不使用数学近似的情况下，估计统计量的抽样分布。<br>用于预测模型时，聚合多个自助样本的预测（即Bagging方法），要优于使用单个模型的预测。</p></blockquote><h3 id="置信区间">置信区间</h3><ul><li><p>置信水平<br>以百分比表示的置信区间。该区间是从同一总体中以同一方式构建的，可以包含我们感兴趣的统计量。</p></li><li><p>区间端点<br>置信区间的两端。</p></li></ul><blockquote><p>置信区间是一种以区间范围表示估计量的常用方法。<br>数据越多，样本估计量的变异性越小。<br>所能容忍的置信水平越低，置信区间就越狭小。<br>自助法是一种构建置信区间的有效方法。</p></blockquote><h3 id="正态分布">正态分布</h3><ul><li><p>误差<br>数据点与预测值或均值间的差异。</p></li><li><p>标准化<br>数据值减去均值，再除以标准偏差。</p></li><li><p>z分数<br>单个数据点标准化的结果。</p></li><li><p>标准正态分布<br>均值为0、标准偏差为1的正态分布。</p></li><li><p>QQ图<br>对样本分布与正态分布间接近程度的可视化绘图。</p></li></ul><blockquote><p>在统计学的发展史中，正态分布有着十分重要的地位，因为它允许从数学上近似不确定性和变异性。<br>虽然原始数据通常并不符合正态分布，但误差通常是符合正态分布的。对于大规模样本的均值和总数，也是一样的。<br>要将数据转换为z分数，需要减去数据的均值，再除以标准偏差。这样，所生成的数据才可以与正态分布进行对比。</p></blockquote><h3 id="长尾分布">长尾分布</h3><ul><li><p>尾<br>一个频数分布的狭长部分，其中相对极值出现的频数很低。</p></li><li><p>偏斜<br>分布的一个尾部长于另一个尾部。</p></li></ul><blockquote><p>大部分数据是不符合正态分布的。<br>假设数据符合正态分布，这可导致对极端事件产生错误的估计（即“黑天鹅”现象）。</p></blockquote><h3 id="学生t分布">学生t分布</h3><ul><li><p>n<br>表示一个样本的规模。</p></li><li><p>自由度<br>自由度是一个参数，允许根据不同的样本规模、统计量和组数对t分布进行调整。</p></li></ul><blockquote><p>t分布实际上是一个分布家族。它们与正态分布相似，但是尾部略厚。<br>t分布被广泛地用作样本均值分布、两个样本均值间的差异、回归参数等的参考基础。</p></blockquote><h3 id="二项分布">二项分布</h3><ul><li><p>试验<br>一次输出离散值的事件，例如，一次硬币抛掷。</p></li><li><p>成功<br>一次试验的输出为我们感兴趣的结果。</p></li><li><p>二项 (二元)<br>具有两个输出</p></li><li><p>二项试验 (伯努利试验)<br>有两种输出的试验。</p></li><li><p>二项分布 (伯努利分布)<br>在多次试验中（例如x次），成功次数的分布。</p></li></ul><blockquote><p>二项输出在建模中十分重要，因为它们表示了基本的决策情况，例如是否购买、是否点击、存活还是死亡等。<br>二项试验是一种具有两种可能结果的试验，其中一种结果的概率为p，另一种结果的概率为1-p。<br>当n很大并且p不接近于0（或1）时，二项分布可使用正态分布近似。</p></blockquote><h3 id="泊松分布及其相关分布">泊松分布及其相关分布</h3><ul><li><p>lambda<br>单位时间内或单位空间中的事件发生率。</p></li><li><p>泊松分布<br>单位时间内或单位空间中事件数量的频数分布。</p></li><li><p>指数分布<br>在时间或距离上，从一个事件到下一个事件的频数分布。</p></li><li><p>韦伯分布<br>泛化版本的指数分布。韦伯分布允许事件发生的速率随时间变化。</p></li></ul><blockquote><p>如果事件发生率为常数，那么可以用泊松分布对单位时间或空间内的事件数量进行建模。<br>这种场景下，可以用指数分布对两个事件间的时间间隔或距离建模。<br>如果事件发生率会随时间变化（例如，设备故障率的增大），可以使用韦伯分布建模。</p></blockquote><h2 id="统计实验与显著性检验">统计实验与显著性检验</h2><h3 id="A-B测试">A/B测试</h3><ul><li><p>处理<br>实验对象所接触的东西，例如药品、价格、Web标题等。</p></li><li><p>实验组<br>行特定处理的一组对象。</p></li><li><p>对照组<br>执行标准处理或不执行处理的一组对象。</p></li><li><p>随机化<br>随机地分配实验对象以进行处理的过程。</p></li><li><p>实验对象<br>接受处理者，例如Web访问者、病人等。</p></li><li><p>检验统计量<br>用于检验处理效果的度量。</p></li></ul><blockquote><p>将实验对象分配给两组或更多组，各组的条件完全相同，只是要接受的处理不同。<br>在理想情况下，实验对象是随机分配给各组的。</p></blockquote><h3 id="假设检验">假设检验</h3><ul><li><p>零假设<br>完全归咎于偶然性的假设。</p></li><li><p>备择假设<br>与零假设相反，即实验者希望证实的假设。</p></li><li><p>单向检验<br>在假设检验中，只从一个方向上计数偶然性结果。</p></li><li><p>双向检验<br>在假设检验中，从正反两个方向上计数偶然性结果。</p></li></ul><blockquote><p>零假设的逻辑理念体现为没有特殊事件发生，任何观察到的效果都是由随机偶然导致的。<br>假设检验假定零假设为真，创建“零模型”（一种概率模型），并检验所观察到的效果是否是该模型的合理结果。</p></blockquote><h3 id="重抽样">重抽样</h3><ul><li><p>置换检验 (随机化检验、随机置换检验、准确检验)<br>将两组或多组样本组合在一起，并将观测值随机地（或穷尽地）重新分配给重抽样。</p></li><li><p>有放回，无放回<br>在抽样时，所抽取的元素在下一次抽取前是否放回样本中。</p></li></ul><blockquote><p>置换检验将多个样本组合在一起，并做随机混洗。<br>对混洗后的值做分组并重抽样，计算我们感兴趣的统计量。<br>重复上述过程，并在表格中记录重抽样统计量的情况。<br>对比统计量的观测值与重抽样分布，就可以判定观测到的样本间差异是否由偶然性导致的。</p></blockquote><h3 id="统计显著性和p值">统计显著性和p值</h3><ul><li><p>p值<br>对于一个加入了零假设的偶然性模型，p值指得到与观测结果一样不寻常或极端的结果的概率。</p></li><li><p>α值<br>在实际结果的确是统计显著的情况下，α值指偶然性结果必须超出的“不寻常性”概率的阈值。</p></li><li><p>第一类错误<br>错误地将一个由随机导致的效果归结为真。</p></li><li><p>第二类错误<br>错误地将一个为真的效果归结为由随机导致的。</p></li></ul><blockquote><p>显著性检验可以用于确定观测到的效果是否落在零假设模型的随机变异范围内。<br>给定一个零假设模型，p值表示模型所生成的结果与观测到的结果同样极端的概率。<br>α值是零假设随机模型“不寻常性”的阈值。<br>相对于数据科学而言，显著性检验在正式的研究报告中更加重要。但是近年来，即便是对于研究报告，p值的重要性也一直在下降。</p></blockquote><h3 id="t检验">t检验</h3><ul><li><p>检验统计量<br>对我们所关注的差异或效果的度量。</p></li><li><p>t统计量<br>归一化的检验统计量。</p></li><li><p>t分布<br>一种用于比较所观测到的t统计量的参考分布。对于t检验，参考分布是从零假设生成的。</p></li></ul><blockquote><p>在计算机出现之前，重抽样检验并不实用，统计人员使用标准参考分布。<br>检验统计量应该做归一化，这样才能与参考分布做比较。<br>t统计量是一种广为使用的归一化统计量。</p></blockquote><h3 id="多重检验">多重检验</h3><ul><li><p>第一类错误<br>错误地得出一个效果是统计显著的结论。</p></li><li><p>错误发现率<br>在多重检验中，犯第一类错误的比率。</p></li><li><p>p值校正<br>用于在同一数据上做多重检验。</p></li><li><p>过拟合<br>拟合了噪声。</p></li></ul><blockquote><p>在研究工作或数据挖掘项目中，多重性（多重比较、多变量、多模型等）增加了仅根据随机对某个结果得出显著性结论的风险。<br>对于涉及多重统计比较的情况（即显著性的多重检验），可以使用统计校正过程。<br>在数据挖掘中使用结果变量带标记的验证样本，有助于避免得到误导性的结果。</p></blockquote><h3 id="自由度">自由度</h3><ul><li><p>n (样本规模)<br>在数据中，观测（也称为行或记录）的数量。</p></li><li><p>d.f.<br>degrees of freedom（自由度）的简写。</p></li></ul><blockquote><p>自由度是归一化检验统计量计算的一部分。它使得归一化后的结果可以与参考分布（例如t分布、F分布等）进行对比。<br>在回归中，为避免出现多重共线性问题，在将分类变量因子化为n-1个标识或虚拟变量时，应考虑其中隐含的自由度概念。</p></blockquote><h3 id="方差分析">方差分析</h3><ul><li><p>两两对比<br>对于有多个组的情况，在两个组之间做假设检验（比如对均值）。</p></li><li><p>多项检验（omnibus test）<br>一种可以测定多个组均值间方差的单一假设检验。</p></li><li><p>方差分解<br>从整体统计量中（例如，从整体均值、处理均值以及残差中），分离出单个值的贡献情况。</p></li><li><p>F统计量<br>一种归一化统计量，用于衡量多个组均值间的差异是否会超过随机模型的预期。</p></li><li><p>SS<br>sum of square（平方和）的简写，指与某一均值的偏差。</p></li></ul><blockquote><p>方差分析是一种用于分析多组处理结果的统计过程。<br>方差分析是对A/B测试中类似过程的一种扩展，用于评估各组之间的整体方差是否落在随机变异范围内。<br>方差分析的一个有用结果是识别出与组处理、交互效果和误差相关的方差成分。</p></blockquote><h3 id="卡方检验">卡方检验</h3><ul><li><p>卡方统计量<br>观测数据偏离预期程度的量度。</p></li><li><p>期望值 (期望)<br>在某种假设（通常是零假设）下，我们期望数据能给出的结果。</p></li><li><p>d.f.<br>自由度。</p></li></ul><blockquote><p>统计学中一个常见的过程是检验观测情况与独立性假设是否一致，例如购买特定产品的倾向是否与性别无关。<br>卡方分布是一种加入了独立性假设的参考分布。由观测情况计算得到的卡方统计量，必须与卡方分布进行对比。</p></blockquote><h3 id="多臂老虎机算法">多臂老虎机算法</h3><ul><li><p>多臂老虎机<br>一种假想的老虎机，提供多个拉杆供用户选择，每个拉杆对应不同的收益，用于模拟多处理实验。</p></li><li><p>臂<br>表示实验中的一个处理，例如Web测试中的标题A。</p></li><li><p>获胜<br>通过实验模拟老虎机上的获胜，例如客户点击了链接。</p></li></ul><blockquote><p>传统的A/B测试基于随机抽样过程，会导致过度地使用非最优处理。<br>相比而言，多臂老虎机算法改进了抽样过程，加入了在实验过程中学到的信息，减少了非最优处理的频数。<br>多臂老虎机算法还有助于有效地应对两种以上的处理。<br>多臂老虎机具有多种不同的算法，能够解决如何将抽样概率从非最优处理转移到（假设的）最优处理的问题。</p></blockquote><h3 id="检验效能和样本规模">检验效能和样本规模</h3><ul><li><p>效果规模<br>在统计检验中，期望能检测到的效果的最小规模，例如点击率提高20%。</p></li><li><p>检验效能<br>给定样本规模，检测到给定效果规模的概率。</p></li><li><p>显著性水平<br>在检验中所使用的统计显著性水平。</p></li></ul><blockquote><p>在确定样本的规模之前，需提前确定要执行的统计检验。<br>必须指定要检测效果的最小规模。<br>还必须指定检测这一效果规模（检验效能）所需的概率。<br>最后，还必须指定执行检验的显著性水平（α值）。</p></blockquote><h2 id="回归与预测">回归与预测</h2><h3 id="简单线性回归">简单线性回归</h3><ul><li><p>响应变量 (因变量、变量Y、目标、结果)<br>想要预测的变量。</p></li><li><p>自变量 (自变量、变量X、特征、属性)<br>用于预测响应的变量。</p></li><li><p>记录 (行、案例、实例、示例)<br>一个表示特定个体或实例的向量，由因子和结果值组成。</p></li><li><p>截距 ($ b_0 $、$ β_0 $)<br>回归线的截距，即当X = 0时的预测值。</p></li><li><p>回归系数 (斜率、$ b_1 $、$ β_1 $、参数估计值、权重)<br>回归线的斜率。</p></li><li><p>拟合值 (预测值)<br>从回归线获得的估计值[插图]。</p></li><li><p>残差 (误差)<br>观测值和拟合值之间的差异。</p></li><li><p>最小二乘法 (普通最小二乘法)<br>一种通过最小化残差的平方和而拟合回归的方法。</p></li></ul><blockquote><p>回归方程将响应变量Y和预测变量X间的关系建模为一条直线。<br>回归模型给出了拟合值和残差，即响应的预测值和预测的误差。<br>回归模型通常使用最小二乘法拟合。<br>回归可用于预测和解释。</p></blockquote><h3 id="多元线性回归">多元线性回归</h3><ul><li><p>均方根误差 (RMSE)<br>回归均方误差的平方根，它是比较回归模型时使用最广泛的度量。</p></li><li><p>标准残差 (RSE)<br>与均方根误差的计算一样，只是根据自由度做了调整。</p></li><li><p>R方 (决定系数、$ R^2 $)<br>可以被模型解释的变异的比例，值介于0到1之间。</p></li><li><p>t统计量<br>预测因子的系数，除以系数的标准误差。它提供了一种比较模型中变量重要性的度量。</p></li><li><p>加权回归<br>在回归中，记录具有不同的权重。</p></li></ul><blockquote><p>多元线性回归建模了响应变量Y与多个预测变量$ X_1, …, X_p $之间的关系。<br>均方根误差（RMSE）和R2是评价模型最重要的度量。<br>回归系数的标准误差可用于度量变量对模型的贡献的可靠性。<br>逐步回归是一种自动确定模型中应包括哪些变量的方法。<br>加权回归用于拟合函数中，可以对特定记录给予更大或更小的权重。</p></blockquote><h3 id="使用回归做预测">使用回归做预测</h3><ul><li><p>预测区间<br>个体预测值的不确定区间范围。</p></li><li><p>外推法<br>将模型扩展到拟合所用的数据范围之外。</p></li></ul><blockquote><p>超出数据范围的外推会导致误差。<br>置信区间量化了回归系数的不确定度。<br>预测区间量化了单个预测中的不确定度。<br>包括R在内的很多统计软件，都会使用公式在默认或指定输出中给出预测区间和置信区间。<br>也可以使用自助法确定置信区间，该做法的解释和理念同上。</p></blockquote><h3 id="回归中的因子变量">回归中的因子变量</h3><ul><li><p>虚拟变量<br>二元的0/1变量，通过对因子数据重新编码得到，可用于回归模型或其他模型。</p></li><li><p>参考编码 (编码处理)<br>统计学家最常使用的编码类型。它以因子的一层作为参考层，并将其他因子与参考层进行对比。</p></li><li><p>独热编码（one hot encoder）<br>机器学习领域中常用的一种编码。它保留了所有的因子层。虽然该编码适用于部分机器学习算法，但并不适用于多元线性回归。</p></li><li><p>偏差编码 (总和对照编码)<br>在编码中用于对比的并不是参考层，而是将每一层与整体均值进行对比。</p></li></ul><blockquote><p>因子变量需要转换为数值变量，才能在回归中使用。<br>要编码一个具有P个不同值的因子变量，最常用的方法是表示为P-1个虚拟变量。<br>即便是在规模非常大的数据集中，多层因子变量也需整合为具有更少层的变量。<br>一些因子的层是有序的，可以表示为单一的数值变量。</p></blockquote><h3 id="解释回归方程">解释回归方程</h3><ul><li><p>相关变量<br>当预测变量高度相关时，难以解释单个回归系数。</p></li><li><p>多重共线性 (共线性)<br>当预测变量间存在完美的或近乎完美的相关性时，回归是不稳定的，或者说是不可能计算的。</p></li><li><p>混淆变量<br>一种重要的预测变量。忽视该变量可导致回归方程给出伪关系。</p></li><li><p>主效应<br>预测变量和结果变量之间的关系，该关系独立于其他的变量。</p></li><li><p>交互作用<br>两个或两个以上预测变量和响应之间的相互依赖关系。</p></li></ul><blockquote><p>考虑到预测因子之间的相关性，在多元线性回归中，必须注意如何解释回归系数。<br>多重共线性可能导致拟合回归方程中存在数值不稳定的问题。<br>混淆变量是指在模型中遗漏的重要预测因子，它可以导致存在虚假关系的回归方程。<br>如果变量和响应之间存在相互依赖的关系，那么需要在两个变量间添加一个交互项。</p></blockquote><h3 id="回归诊断">回归诊断</h3><ul><li><p>标准残差<br>残差除以残差的标准误差。</p></li><li><p>离群值<br>距离其他记录（或预测结果）很远的记录（或结果值）。</p></li><li><p>强影响值 (influential value)<br>一个值或记录，其存在与否会使回归方程有很大差异。</p></li><li><p>杠杆 (hat-value)<br>单个记录对回归方程的影响程度。</p></li><li><p>非正态残差<br>非正态分布的残差可能会导致一些对回归的技术需求失效。但在数据科学中，通常并不会关注该问题。</p></li><li><p>异方差性<br>在输出的部分范围中具有较高变异性的残差。这可能表明在回归方程中缺失了某个预测变量。</p></li><li><p>偏残差图 (变量添加图、added-variable-plot)<br>展示结果变量和单个预测变量之间关系的一种诊断图。</p></li></ul><blockquote><p>鉴于离群值可能会在小规模数据集中导致问题，关注离群值主要是为了发现数据中存在的问题，或是确定异常所在。<br>单个记录（包括回归离群值）可以对小规模数据集的回归方程产生很大的影响。但是在大数据中，这种效果却荡然无存。<br>如果将回归模型用于形式推断（如p值等），那么应该检验对残差分布的一些假设。但是对于数据科学而言，残差分布通常无关紧要。<br>偏残差图可以用于定性地评估每个回归项的拟合情况，这可能会得出另一种模型声明。</p></blockquote><h3 id="多项式回归和样条回归">多项式回归和样条回归</h3><ul><li><p>多项式回归<br>在回归方程中添加了多项式项，例如平方项、三次方项等。</p></li><li><p>样条回归<br>使用一系列多项式片段去拟合一条平滑曲线。</p></li><li><p>结点<br>分隔样条片段的值。</p></li><li><p>广义加性模型  (GAM)<br>可以自动选择结点的样条模型。</p></li></ul><blockquote><p>在回归中，离群值表现为具有很大残差的记录。<br>多重共线性会导致拟合回归方程中存在数值不稳定的问题。<br>混淆变量是一种重要的预测变量。如果在一个模型中忽略了混淆变量，将会导致回归方程给出伪关系。<br>如果一个变量的效果依赖于另一个变量（因子变量）的层级，那么在两个变量之间需要有交互项。<br>多项式回归可以拟合预测变量和结果变量之间的非线性关系。<br>样条是一组连接在一起的多项式片段，连接点被称为结点。<br>广义加性模型可以自动指定样条函数中的结点。</p></blockquote><h2 id="分类">分类</h2><h3 id="朴素贝叶斯算法">朴素贝叶斯算法</h3><ul><li><p>条件概率<br>在给定另一个事件（比如Y = i）的条件下，观测到某个事件（比如X = i）的概率，记作 $ P(X_i | Y_i) $。</p></li><li><p>后验概率<br>在给定预测因子的情况下，出现某一结果的概率（后验概率不同于结果的先验概率，后者并未考虑预测因子的信息）。</p></li></ul><blockquote><p>朴素贝叶斯适用于分类的（因子型的）预测和结果。<br>朴素贝叶斯要解答的问题是：“在每个结果类别中，哪些预测类别是最可能发生的？”<br>该问题可以转化为，在给定预测值的情况下，估计结果属于不同类别的概率。</p></blockquote><h3 id="判别分析">判别分析</h3><ul><li><p>协方差<br>对一个变量相对于另一个变量的一致程度（幅度和方向类似）的度量。</p></li><li><p>判别函数<br>当应用于预测变量上时，该函数可以使类之间的分离度最大化。</p></li><li><p>判别权重<br>应用判别函数得到的分值，用于估计记录属于某个类的概率。</p></li></ul><blockquote><p>判别分析适用于连续预测因子或分类预测因子，也适用于分类结果。<br>判别分析使用协方差矩阵计算线性判别函数，该函数用于区分属于不同类的记录。<br>线性判别函数对每个记录生成一个权重或分值（每个可能的类对应一个权重），以此来确定记录的估计类。</p></blockquote><h3 id="逻辑回归">逻辑回归</h3><ul><li><p>Logit函数 (对数函数)<br>一种能将属于某个类的概率映射到 ±∞ 范围上（而不是0到1之间）的函数。</p></li><li><p>几率<br>“成功”（1）与“不成功”（0）之间的比率。</p></li><li><p>对数几率<br>转换后的模型（即线性模型）中的响应。该响应已被映射回概率值。</p></li></ul><blockquote><p>逻辑回归和线性回归类似，只不过其结果是二元变量。<br>在逻辑回归中需要做多次转换，以将模型转化为一种可以像线性模型一样拟合的形式，并使用对数优势比作为响应变量。<br>通过迭代过程拟合了线性模型之后，应将对数几率映射回概率值。<br>逻辑回归的计算快速，并且生成的模型可以在不重新计算的情况下对新数据打分，因此它得到了广泛的使用。</p></blockquote><h3 id="评估分类模型">评估分类模型</h3><ul><li><p>正确率（accuracy）<br>正确分类的百分比（或比例）。</p></li><li><p>混淆矩阵<br>按预测分类和实际分类情况对记录分别计数，将计数结果以表格形式显示。例如，对于二元变量，使用的是2×2的表格。</p></li><li><p>灵敏度 (召回率)<br>在预测结果中，1被正确分类的百分比（或比例）。</p></li><li><p>特异性<br>在预测结果中，0被正确分类的百分比（或比例）。</p></li><li><p>准确率（precision）<br>预测结果为1、真实值也为1的百分比（或比例）。</p></li><li><p>ROC曲线<br>灵感度与特异性的绘图。</p></li><li><p>提升（lift）<br>在不同截止概率的情况下，衡量模型在识别（相对罕见的）1上的有效性。</p></li></ul><blockquote><p>正确率（即预测分类正确的百分比）可以用于评估模型，但只是评估的第一步。<br>其他度量（召回率、特异性、准确率）侧重于更具体的性能特征。例如，召回率测定了模型正确识别1的良好程度。<br>AUC（ROC曲线下的面积）是对模型区分1与0能力的一种常用度量。<br>提升衡量了一个模型在识别1上的有效性，并且常常是按十分位数逐个计算的，从分类为1可能性最大之处开始。</p></blockquote><h3 id="不平衡数据的处理策略">不平衡数据的处理策略</h3><ul><li><p>欠采样 (下采样)<br>在分类模型中，使用更少的多数类记录。</p></li><li><p>过采样 (上采样)<br>在分类模型中，更多地使用稀有类记录。必要时可以使用自助法。</p></li><li><p>上权重、下权重<br>在模型中，对稀有类赋予更大的权重，对多数类赋予更小的权重。</p></li><li><p>数据生成<br>类似于自助法，只是每个新的自助记录与原记录略有不同。</p></li><li><p>z分数<br>对结果做归一化所生成的值。</p></li><li><p>K<br>在最近邻计算中使用的近邻个数。</p></li></ul><blockquote><p>分类算法在高度不平衡数据（其中感兴趣的结果“1”十分罕见）中会存在问题。<br>平衡训练数据的一种策略是，对多数类做欠采样，或者对稀有类做过采样。<br>如果使用了数据中所有的“1”依然不够，可以对稀有类做自助法，或使用SMOTE算法创建与稀有类相似的合成数据。<br>不平衡数据通常表明正确的分类（即“1”）具有更高的价值。我们应将这种值的比率纳入到评估度量中。</p></blockquote><h2 id="统计机器学习">统计机器学习</h2><h3 id="K最近邻算法">K最近邻算法</h3><ul><li><p>近邻<br>具有相似预测值的两个记录。</p></li><li><p>距离度量<br>以单一数值的形式，测量两个记录之间的距离。</p></li><li><p>标准化 (归一化)<br>减去均值，并除以标准偏差。</p></li><li><p>z分数<br>标准化后得到的值。</p></li><li><p>K<br>在最近邻计算中考虑的近邻个数。</p></li></ul><blockquote><p>KNN通过指定与一条记录相似的记录所属的类，实现对该记录的分类。<br>可以使用欧氏距离或其他相关度量判定相似度（距离）。<br>与一条记录进行比较的最近邻数（即K值），取决于使用不同K值时，算法在训练数据上的性能。<br>预测变量通常需要做标准化，以避免大尺度变量主导了距离度量。<br>KNN常常作为预测建模过程的第一个阶段。KNN的预测值会作为一个预测变量添加回数据中，进而用于第二阶段（非KNN）的建模。</p></blockquote><h3 id="树模型">树模型</h3><ul><li><p>递归分区（recursive partition）<br>反复对数据进行划分和细分，目的是使每个最终细分内的结果尽可能同质。</p></li><li><p>拆分值（split value）<br>一个预测变量值，它将一组记录分为两部分，使得一部分中的预测变量小于拆分值，而另一部分中的预测变量大于拆分值。</p></li><li><p>节点<br>在决策树中（或在一组相应的分支规则中），节点是拆分值的图形化表示（或规则表示）。</p></li><li><p>叶子<br>一组if-then规则的终点，或一个树分支的终点。在树中访问叶子的规则，构成了对树中一条记录的分类规则。</p></li><li><p>损失<br>在拆分过程的某一阶段中误分类的个数。损失越大，不纯度越高。</p></li><li><p>不纯度 (异质性)<br>表示在数据的一个细分中发现多个类混杂的程度。细分中混杂的类越多，该细分的不纯度就越高。</p></li><li><p>剪枝<br>为了降低过拟合，对一棵完全长成树逐步剪枝的过程。</p></li></ul><blockquote><p>决策树生成一组规则，用于分类或预测结果。<br>规则对应于如何将数据划分为连续的子分区。<br>每个分区或拆分指定一个预测变量值（即拆分值），将分区中数据拆分为高于和低于该拆分值的两组记录（即子分区）。<br>在每个阶段，树算法选择使每个子分区内结果的不纯度最小的拆分。<br>一旦算法不能做进一步的拆分，就得到了一棵完全长成树。每个末端节点或叶子内的记录属于相同的类。此后，遵循该规则（拆分）路径的新记录，将会分配为该类。<br>完全长成树会过产生拟合，因此为了使模型捕获信号而非噪声，必须做剪枝。<br>虽然随机森林和Boosting等多树模型算法具有更好的预测性能，但失去了单个树模型基于规则的交流能力。</p></blockquote><h3 id="Bagging和随机森林">Bagging和随机森林</h3><ul><li><p>集成 (模型平均)<br>使用一组模型给出预测。</p></li><li><p>Bagging (自助法聚合)<br>对数据使用自助法构建一组模型的通用方法。</p></li><li><p>随机森林 (自助法聚合决策树)<br>使用决策树的一类自助法聚合估计。</p></li><li><p>变量重要性<br>对预测变量在模型性能中重要性的测量。</p></li></ul><blockquote><p>通过组合多个模型的结果，集成模型提高了模型正确率。<br>Bagging是一类特殊的集成模型，它使用数据的自助法抽样拟合多个模型，并对模型取平均值。<br>随机森林是一种应用于决策树的特殊Bagging方法。除了对数据重抽样之外，随机森林算法还在拆分树时对预测变量做抽样。<br>对变量重要性的一种度量是随机森林的一种有用输出。变量重要性根据变量对模型正确率的贡献度，对变量排序。<br>随机森林具有一组超参数。可以使用交叉验证调整超参数，以避免产生过拟合。</p></blockquote><h3 id="Boosting">Boosting</h3><ul><li><p>Boosting<br>在拟合一组模型时所使用的一种通用方法。Boosting在每轮连续的拟合中，会对具有更大残差的记录赋予更大的权重。</p></li><li><p>Adaboost<br>Boosting算法的一种早期实现，它根据残差的情况对数据重新加权。</p></li><li><p>梯度提升<br>一种更通用的Boosting算法。它将问题转化为代价函数最小化的问题。</p></li><li><p>随机梯度提升（SGD）<br>最常用的Boosting算法。它在每轮拟合中加入了对记录和数据列的重抽样。</p></li><li><p>正则化<br>通过在代价函数中对模型参数的数量添加惩罚项，避免产生过拟合。</p></li><li><p>超参数<br>在拟合算法之前就需要设定的参数。</p></li></ul><blockquote><p>Boosting是一类基于对一组模型做拟合的集成模型。在连续的每轮拟合中，Boosting算法会为具有更大残差的记录赋予更大的权重。<br>随机梯度提升是最通用的Boosting算法，具有最佳性能。随机梯度提升最常见的形式是使用树模型。<br>XGBoost是一种广为使用的随机梯度提升软件包，它计算高效。所有数据科学常用的语言中都提供了XGBoost。<br>Boosting容易过拟合数据。为了避免产生过拟合，需要调整超参数。<br>正则化通过在模型的参数数量（例如，树的规模）上添加惩罚项，避免产生过拟合。<br>鉴于Boosting算法需要设置大量的超参数，交叉验证尤为重要。</p></blockquote><h2 id="无监督学习">无监督学习</h2><h3 id="主成分分析">主成分分析</h3><ul><li><p>主成分<br>预测变量的一种线性组合。</p></li><li><p>载荷 (权重)<br>将预测因子转换为成分的过程中所使用的权重值。</p></li><li><p>陡坡图<br>一种展示各成分方差的绘图，图中显示了各成分的相对重要性。</p></li></ul><blockquote><p>主成分是预测变量的线性组合，但仅限于数值型预测变量。<br>主成分计算的原则是使成分之间的相关性最小化，进而减少冗余。<br>通常，有限数量的成分就可以解释结果变量的大部分方差。<br>这样就可以使用一组有限的主成分代替（更多的）原始预测变量，从而降低维度。</p></blockquote><h3 id="K-Means聚类">K-Means聚类</h3><ul><li><p>类（cluster）<br>一组类似的记录。</p></li><li><p>类均值<br>表示类内记录变量均值的向量。</p></li><li><p>K<br>类的个数。</p></li></ul><blockquote><p>所需的类数K由用户决定。<br>K-Means算法通过迭代地将记录分配给最近的类均值，直到类的分配情况不再发生改变，实现了类的生成。<br>通常，出于实际的考虑决定了K的选择。在统计学上不存在最优的类数。</p></blockquote><h3 id="层次聚类">层次聚类</h3><ul><li><p>树状图<br>一种可视化表示，显示了记录及其所属类的层次结构。</p></li><li><p>距离<br>测量两个记录之间的接近程度。</p></li><li><p>相异性<br>测量两个类之间的接近程度。</p></li></ul><blockquote><p>层次聚类算法开始时，每条记录单独构成一个类。<br>在凝聚算法中，类逐步与相邻的类合并，直到所有记录属于单一类。<br>凝聚算法的类历史可以被保留并绘制出来。用户（无须预先指定类数）可以在算法执行的各个阶段，可视化地查看类数和类的结构。<br>有多种方法可以计算类之间的距离。这些方法都依赖于所有记录间距离。</p></blockquote><h3 id="基于模型的聚类">基于模型的聚类</h3><blockquote><p>基于模型的聚类方法假设类是由不同数据生成过程所生成的，各个数据生成过程具有不同的概率分布。<br>基于模型的聚类方法拟合了不同的模型，假设有不同数量的分布（通常是正态分布）。<br>基于模型的聚类方法无须使用过多的参数（即过拟合），就能选出一个能很好地拟合数据的模型（以及类数）。</p></blockquote><h3 id="变量的缩放和分类变量">变量的缩放和分类变量</h3><ul><li><p>缩放<br>缩小或放大数据的方法，常用于将多个变量缩放到同一尺度上。</p></li><li><p>归一化 (标准化)<br>一种通过减去均值并除以标准偏差进行缩放的方法。</p></li><li><p>高氏距离（Gower’s distance）<br>一种应用于数值数据和类别数据相混合的缩放算法。它可以将所有变量缩放到[0, 1]范围内。</p></li></ul><blockquote><p>以不同尺度测量的变量，需要转换到相似的尺度上。这样，变量对算法的影响不会主要由变量的尺度决定。<br>归一化（标准化）是一种常用的缩放方法——减去均值再除以标准偏差计算。<br>另一种缩放方法是高氏距离，它将所有的变量缩放到[0, 1]范围内。高氏距离通常用于含有数值型数据和分类数据的混合数据。</p></blockquote><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://www.amazon.cn/dp/B07MNV5MSN" target="_blank" rel="noopener">面向数据科学家的实用统计学</a></p>]]></content>
    
    <summary type="html">
    
      重要的统计学概念
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="DAE" scheme="https://neo1989.net/tags/DAE/"/>
    
      <category term="Math" scheme="https://neo1989.net/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>Pandas常用</title>
    <link href="https://neo1989.net/CheatSheet/CHEATSHEET-pandas/"/>
    <id>https://neo1989.net/CheatSheet/CHEATSHEET-pandas/</id>
    <published>2021-01-12T07:50:19.000Z</published>
    <updated>2021-02-07T08:31:34.173Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你可以不用，但你不能不会。</p></blockquote><table><thead><tr><th style="text-align:left">Grammar</th><th style="text-align:center">Explanation / Examples</th></tr></thead><tbody><tr><td style="text-align:left"><strong>Importing Data</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.read_csv(filename)</td><td style="text-align:center">From a CSV file</td></tr><tr><td style="text-align:left">pd.read_table(filename)</td><td style="text-align:center">From a delimited text file (like TSV)</td></tr><tr><td style="text-align:left">pd.read_excel(filename)</td><td style="text-align:center">From an Excel file</td></tr><tr><td style="text-align:left">pd.read_sql(query, connection_object)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.read_json(json_string)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.read_html(url)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.DataFrame(dict)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>Exporting Data</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.to_csv(filename)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.to_sql(table_name, connection_object)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.to_json(filename)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>Create Test Objects</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.DataFrame(np.random.rand(20, 5))</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">pd.Series(my_list)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.index = pd.date_range(‘1900/1/30’, periods=df.shape[0])</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>Viewing / Inspecting Data</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.head(n)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.tail(n)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.shape</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.describe()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.value_counts()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>Selection</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df[col]</td><td style="text-align:center">Returns column with label col as Series</td></tr><tr><td style="text-align:left">df[[col1, col2]]</td><td style="text-align:center">Returns columns as a new DataFrame</td></tr><tr><td style="text-align:left">ss.iloc[0]</td><td style="text-align:center">Selection by position</td></tr><tr><td style="text-align:left">df.iloc[0, :]</td><td style="text-align:center">First row</td></tr><tr><td style="text-align:left">df.iloc[0, 0]</td><td style="text-align:center">First element of first column</td></tr><tr><td style="text-align:left"><strong>Data Cleaning</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.columns = [‘a’,‘b’,‘c’]</td><td style="text-align:center">Rename columns</td></tr><tr><td style="text-align:left">pd.isnull()</td><td style="text-align:center">Checks for null Values, Returns Boolean Arrray</td></tr><tr><td style="text-align:left">pd.notnull()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.dropna()</td><td style="text-align:center">Drop all rows that contain null values</td></tr><tr><td style="text-align:left">df.dropna(axis=1)</td><td style="text-align:center">Drop all columns that contain null values</td></tr><tr><td style="text-align:left">df.dropna(axis=1, thresh=n)</td><td style="text-align:center">Drop all rows have have less than n non null values</td></tr><tr><td style="text-align:left">df.fillna(x)</td><td style="text-align:center">Replace all null values with x</td></tr><tr><td style="text-align:left">ss.fillna(ss.mean())</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">ss.astype(float)</td><td style="text-align:center">Convert the datatype of the series to float</td></tr><tr><td style="text-align:left">ss.replace(1, ‘one’)</td><td style="text-align:center">Replace all values equal to 1 with ‘one’</td></tr><tr><td style="text-align:left">ss.replace([1, 3], [‘one’, ‘three’])</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.rename(columns=lambda x: x + 1)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.rename(columns={‘old_name’: ‘new_ name’})</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.set_index(‘column_one’)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.rename(index=lambda x: x + 1)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>Filter, Sort, and Groupby</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df[df[col].gt(0.5)]</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df[(df[col] &gt; 0.5) &amp; (df[col] &lt; 0.7)]</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.sort_values(col1)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.sort_values(col2, ascending=False)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.sort_values([col1,col2], ascending=[True, False])</td><td style="text-align:center">Sort values by col1 in ascending order then col2 in descending order</td></tr><tr><td style="text-align:left">df.groupby(col)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.groupby([col1, col2])</td><td style="text-align:center">Returns groupby object for values from multiple columns</td></tr><tr><td style="text-align:left">df.pivot_table(index=col1, values=[col2, col3], aggfunc=np.mean)</td><td style="text-align:center">Create a pivot table that groups by col1 and calculates the mean of col2 and col3</td></tr><tr><td style="text-align:left">df.groupby(col1).agg(np.mean)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.apply(np.mean)</td><td style="text-align:center">Apply the function np.mean() across each column</td></tr><tr><td style="text-align:left">df.apply(np.max, axis=1)</td><td style="text-align:center">Apply the function np.max() across each row</td></tr><tr><td style="text-align:left"><strong>Join / Combine</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df1.append(df2)</td><td style="text-align:center">Add the rows in df1 to the end of df2 (columns should be identical)</td></tr><tr><td style="text-align:left">pd.concat([df1, df2], axis=1)</td><td style="text-align:center">Add the columns in df1 to the end of df2 (rows should be identical)</td></tr><tr><td style="text-align:left">df1.join(df2, on=col1, how=‘inner’)</td><td style="text-align:center">SQL-style</td></tr><tr><td style="text-align:left"><strong>Statistics</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.describe()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.mean()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.corr()</td><td style="text-align:center">Returns the correlation between columns in a DataFrame</td></tr><tr><td style="text-align:left">df.count()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.max()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.min()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.median()</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">df.std()</td><td style="text-align:center"></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      Save more time.
    
    </summary>
    
    
      <category term="CheatSheet" scheme="https://neo1989.net/categories/CheatSheet/"/>
    
    
      <category term="DAE" scheme="https://neo1989.net/tags/DAE/"/>
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
  </entry>
  
  <entry>
    <title>Excel必会</title>
    <link href="https://neo1989.net/CheatSheet/CHEATSHEET-excel-formulas/"/>
    <id>https://neo1989.net/CheatSheet/CHEATSHEET-excel-formulas/</id>
    <published>2021-01-08T06:54:55.000Z</published>
    <updated>2021-02-02T06:30:45.042Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>你可以不用，但你不能不会。</p></blockquote><h3 id="常用公式">常用公式</h3><table><thead><tr><th style="text-align:left">Formula</th><th style="text-align:center">Grammar</th><th style="text-align:center">Explanation / Examples</th></tr></thead><tbody><tr><td style="text-align:left"><strong>日期时间类</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">DATE</td><td style="text-align:center">DATE(year, month, day)</td><td style="text-align:center"></td></tr><tr><td style="text-align:left">DAYS</td><td style="text-align:center">DAYS(end_date, start_date)</td><td style="text-align:center">返回两个日期之间的天数</td></tr><tr><td style="text-align:left">DAY</td><td style="text-align:center">DAY(serial_number)</td><td style="text-align:center">返回一个月中的第几天的数值 [1, 31]</td></tr><tr><td style="text-align:left">MONTH</td><td style="text-align:center"></td><td style="text-align:center">返回月份值 [1, 12]</td></tr><tr><td style="text-align:left">YEAR</td><td style="text-align:center"></td><td style="text-align:center">返回日期的年份值 [1900, 9999]</td></tr><tr><td style="text-align:left"><strong>统计类</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">COUNT</td><td style="text-align:center"></td><td style="text-align:center">计算区域中包含数字的单元格的个数</td></tr><tr><td style="text-align:left">COUNTA</td><td style="text-align:center"></td><td style="text-align:center">计算区域中非空单元格的个数</td></tr><tr><td style="text-align:left">COUNTBLANK</td><td style="text-align:center"></td><td style="text-align:center">计算某个区域中空单元格的数目</td></tr><tr><td style="text-align:left">COUNTIF</td><td style="text-align:center">COUNTIF(range, criteria)</td><td style="text-align:center">计算某个区域中满足给定条件的单元格数目</td></tr><tr><td style="text-align:left">COUNTIFS</td><td style="text-align:center"></td><td style="text-align:center">统计一组给定条件所指定的单元格数</td></tr><tr><td style="text-align:left">SUM</td><td style="text-align:center"></td><td style="text-align:center">计算单元格区域中所有数值的和</td></tr><tr><td style="text-align:left">SUMIF</td><td style="text-align:center"></td><td style="text-align:center">对满足条件的单元格求和</td></tr><tr><td style="text-align:left">SUMIFS</td><td style="text-align:center"></td><td style="text-align:center">对一组给定条件指定的单元格求和</td></tr><tr><td style="text-align:left">SUMPRODUCT</td><td style="text-align:center"></td><td style="text-align:center">点积</td></tr><tr><td style="text-align:left">FREQUENCY</td><td style="text-align:center">FREQUENCY(data_array, bins_array)</td><td style="text-align:center">以一列垂直数组返回一组数据的频率分布</td></tr><tr><td style="text-align:left">MAX</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">MIN</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">RANK</td><td style="text-align:center"></td><td style="text-align:center">返回某数字在一列数字中相对于其他数值的大小排名</td></tr><tr><td style="text-align:left">RAND</td><td style="text-align:center"></td><td style="text-align:center">返回大于或等于 0 且小于 1 的平均分布随机数</td></tr><tr><td style="text-align:left">RANDBETWEEN</td><td style="text-align:center">RANDBETWEEN(bottom, top)</td><td style="text-align:center">返回一个介于指定的数字之间的随机数</td></tr><tr><td style="text-align:left">AVERAGEA</td><td style="text-align:center"></td><td style="text-align:center">算数平均数</td></tr><tr><td style="text-align:left">QUARTILE</td><td style="text-align:center">QUARTILE(array, quart)</td><td style="text-align:center">返回一组数据的四分位点</td></tr><tr><td style="text-align:left">VAR</td><td style="text-align:center"></td><td style="text-align:center">方差</td></tr><tr><td style="text-align:left">STDEV</td><td style="text-align:center"></td><td style="text-align:center">标准差</td></tr><tr><td style="text-align:left">TTEST</td><td style="text-align:center">TTEST(array1, array2, tails, type)</td><td style="text-align:center">返回t-检验的概率值</td></tr><tr><td style="text-align:left">CHITEST</td><td style="text-align:center">CHITEST(actual_range, expected_range)</td><td style="text-align:center">返回独立性检验的结果: 针对统计和相应的自由度返回卡方分布值</td></tr><tr><td style="text-align:left">FTEST</td><td style="text-align:center">FTEST(array1, array2)</td><td style="text-align:center">返回的是当 Array1 和 Array2 的方差无明显差异时的双尾概率</td></tr><tr><td style="text-align:left"><strong>关联匹配类</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">INDEX</td><td style="text-align:center">INDEX(…)</td><td style="text-align:center">在给定的单元格区域中，返回特定行列交叉处单元格的值或引用</td></tr><tr><td style="text-align:left">LOOKUP</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">VLOOKUP</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">MATCH</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">ROW</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">COLUMN</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">OFFSET</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>逻辑运算类</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">IF</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">IF*</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">AND</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">OR</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">IS*</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left"><strong>数据清洗类</strong></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">TRIM</td><td style="text-align:center"></td><td style="text-align:center">清除掉单元格两边的空格</td></tr><tr><td style="text-align:left">CONCATENATE</td><td style="text-align:center"></td><td style="text-align:center">将多个文本字符串合并成一个</td></tr><tr><td style="text-align:left">REPLACE</td><td style="text-align:center">REPLACE(old_text, start_num, num_chars, new_text)</td><td style="text-align:center">通过下标替换字符串</td></tr><tr><td style="text-align:left">SUBSTITUTE</td><td style="text-align:center">SUBSTITUTE(text, old_text, new_text, instance_num)</td><td style="text-align:center">通过内容替换字符串</td></tr><tr><td style="text-align:left">LEFT / MID / RIGHT</td><td style="text-align:center"></td><td style="text-align:center">截取字符串</td></tr><tr><td style="text-align:left">LEN / LENB</td><td style="text-align:center"></td><td style="text-align:center">字符串长度</td></tr><tr><td style="text-align:left">FIND</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">SEARCH</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">INT</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">RAOUND</td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><h3 id="常见错误">常见错误</h3><table><thead><tr><th style="text-align:left">Error</th><th style="text-align:center">Explanation</th></tr></thead><tbody><tr><td style="text-align:left">#####!</td><td style="text-align:center">计算结果过长，单元格容纳不下；增加列宽可解决</td></tr><tr><td style="text-align:left">#DIV/0</td><td style="text-align:center">除数为0，或公式被空单元格除</td></tr><tr><td style="text-align:left">#N/A</td><td style="text-align:center">公式中无可用数值，或缺少函数参数</td></tr><tr><td style="text-align:left">#NAME?</td><td style="text-align:center">引用了无法识别的名称</td></tr><tr><td style="text-align:left">#NULL!</td><td style="text-align:center">使用了错误的区域运算符，或错误的单元格引用</td></tr><tr><td style="text-align:left">#NUM!</td><td style="text-align:center">在需要数字参数的地方使用了无法接受的参数，或计算结果过大过小</td></tr><tr><td style="text-align:left">#RFF!</td><td style="text-align:center">引用了无效的单元格</td></tr><tr><td style="text-align:left">#VALUE!</td><td style="text-align:center">公式中含有一个错误类型的参数或操作数</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      Save more time.
    
    </summary>
    
    
      <category term="CheatSheet" scheme="https://neo1989.net/categories/CheatSheet/"/>
    
    
      <category term="DAE" scheme="https://neo1989.net/tags/DAE/"/>
    
  </entry>
  
  <entry>
    <title>The End Is Not the End, 2020</title>
    <link href="https://neo1989.net/SeizeTheDay/SUMMARY-2020/"/>
    <id>https://neo1989.net/SeizeTheDay/SUMMARY-2020/</id>
    <published>2020-12-31T14:22:00.000Z</published>
    <updated>2022-11-18T16:11:33.097Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Always walk in the middle of the road.</p></blockquote><h3 id="〖-2020-〗">〖 2020! 〗</h3><ul><li>COVID-19</li><li>科比·布莱恩特逝世, “<a href="/SeizeTheDay/Bryant-2-and-24/"><strong>Mamba out</strong></a>”</li><li>接手ETL、数据分析</li><li>入门<a href="/tags/ML"><strong>机器学习</strong></a></li><li>上手NLP、搜索引擎相关</li><li>换了台MBP-i7-32G，终于能本地跑腾讯的词向量了</li><li>国庆期间，海南万宁第一次真冲浪</li><li>业余开发了个小程序：间读记。利用NLP技术的短句推荐</li></ul><h3 id="〖-2021-〗">〖 2021? 〗</h3><ul><li>深入机器学习、数据分析</li></ul>]]></content>
    
    <summary type="html">
    
      The summary of 2020 and new year&#39;s resolution.
    
    </summary>
    
    
      <category term="SeizeTheDay" scheme="https://neo1989.net/categories/SeizeTheDay/"/>
    
    
  </entry>
  
  <entry>
    <title>MAC命令行快捷键</title>
    <link href="https://neo1989.net/CheatSheet/CHEATSHEET-mac-cmd/"/>
    <id>https://neo1989.net/CheatSheet/CHEATSHEET-mac-cmd/</id>
    <published>2020-12-22T07:17:43.000Z</published>
    <updated>2021-01-06T12:10:14.432Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:center">CheatSheet</th><th style="text-align:center">DESC</th></tr></thead><tbody><tr><td style="text-align:center">CTRL + a</td><td style="text-align:center">左移到行首</td></tr><tr><td style="text-align:center">CTRL + e</td><td style="text-align:center">右移到行尾</td></tr><tr><td style="text-align:center">CTRL + b</td><td style="text-align:center">左移一格</td></tr><tr><td style="text-align:center">CTRL + f</td><td style="text-align:center">右移一格</td></tr><tr><td style="text-align:center">ESC + b</td><td style="text-align:center">左移一词</td></tr><tr><td style="text-align:center">ESC + f</td><td style="text-align:center">右移一词</td></tr><tr><td style="text-align:center">CTRL + d</td><td style="text-align:center">删除当前字符</td></tr><tr><td style="text-align:center">CTRL + h</td><td style="text-align:center">删除左边一个字符</td></tr><tr><td style="text-align:center">CTRL + w</td><td style="text-align:center">删除左边一个词 (不包含当前字符)</td></tr><tr><td style="text-align:center">CTRL + k</td><td style="text-align:center">删除当前及右边所有字符</td></tr><tr><td style="text-align:center">ESC + DEL</td><td style="text-align:center">清除至行首 (不包含当前及右边所有字符)</td></tr><tr><td style="text-align:center">CTRL + u</td><td style="text-align:center">清除当前行</td></tr><tr><td style="text-align:center">CTRL + t</td><td style="text-align:center">交换光标当前字符和左边一个字符的位置</td></tr><tr><td style="text-align:center">ESC + t</td><td style="text-align:center">交换光标当前词和左边一词的位置 <br/> (当前空格右边如果有词，那空格算右边一词的，否则算前面一词的)</td></tr><tr><td style="text-align:center">CTRL + c</td><td style="text-align:center">杀死当前进程</td></tr><tr><td style="text-align:center">CTRL + z</td><td style="text-align:center">挂起当前进程 (fg恢复)</td></tr><tr><td style="text-align:center">CTRL + l</td><td style="text-align:center">清屏</td></tr><tr><td style="text-align:center">CTRL + r</td><td style="text-align:center">搜索历史命令</td></tr><tr><td style="text-align:center">CTRL + y</td><td style="text-align:center">粘贴上次的删除</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      快人一步。
    
    </summary>
    
    
      <category term="CheatSheet" scheme="https://neo1989.net/categories/CheatSheet/"/>
    
    
      <category term="Coder" scheme="https://neo1989.net/tags/Coder/"/>
    
  </entry>
  
  <entry>
    <title>《机器学习》</title>
    <link href="https://neo1989.net/Notes/NOTE-machine-learning-exercises/"/>
    <id>https://neo1989.net/Notes/NOTE-machine-learning-exercises/</id>
    <published>2020-12-15T09:09:39.000Z</published>
    <updated>2023-01-13T03:02:10.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Gists-摘要">Gists 摘要</h2><h3 id="概述">概述</h3><ul><li><p>举例说明机器学习的基本过程<br>定义分析目标、收集数据、数据预处理、数据建模、模型训练、模型评估、模型应用</p></li><li><p>讨论数据数量和质量对机器学习的影响。<br>数据数量少、质量低，无法完成任务、欠拟合、维度爆炸等；数据量大，耗费计算资源、过拟合。</p></li><li><p>讨论目前机器学习应用中存在的主要问题。<br>选择什么模型或算法、选择什么优化方法、如何对数据进行预处理、目标函数是什么、过拟合与欠拟合的处理、维度爆炸</p></li></ul><h3 id="基本方法">基本方法</h3><ul><li><p>什么是标准差、方差和协方差？它们反映了数据的什么内容？<br>方差：离平均的平方距离的平均。<br>标准差：方差的平方根, 描述的是样本集的分散程度。<br>协方差：用于衡量两个随机变量的联合变化程度。 可以反映两个变量是否正负相关或线性无关。</p></li><li><p>如何利用平均值和标准差判断数据的异常值？<br>与平均值的偏差超过三倍标准差的测定值，称为高度异常的异常值。<br>标准差可用于识别符合高斯或类高斯分布的数据中的异常值。</p></li><li><p>何为正则化？其功能是什么？<br>正则化是为了避免过拟合，在经验风险上加入了一个惩罚项。正则化项一般是模型复杂度的单调递增函数，模型越复杂，正则化值就越大。</p></li><li><p>常见的数据概率分布有哪些？<br>伯努利分布、均匀分布、二项分布、正态分布、泊松分布、指数分布等</p></li><li><p>损失函数和风险函数的含义和作用是什么？<br>损失函数是关于模型计算结果 $f(x)$ 和样本目标实际结果 $Y$ 的非负实值函数，记做 $L(y, f(x))$ ，用来解释模型在每个样本实例上的误差损失。<br>函数的值越小，说明预测值与实际值越接近，即模型的拟合效果越好。<br>$L(y, f(x))$ 可以被认为是模型的经验风险，是模型关于训练样本集的平均损失。通常情况下，经验风险也可以训练数据集的损失函数来确定。<br>损失函数反应了模型预测结果和实际结果之间的差距，理解损失函数的本质有助于对算法进行优化，需要结合业务目标和数据特点对问题的本质进行理解，并用数学公式进行抽象，并选择简单的实现方法进行应用。</p></li><li><p>训练误差如何度量和减少？<br>训练误差是模型 $Y$ 关于训练数据集的平均损失。损失函数可以有多种，包括 0-1损失函数、平方损失函数、绝对损失函数、对数损失函数。<br>训练误差较高时可以调整超参数重新训练。</p></li><li><p>如何理解L0、L1和L2正则化？<br>L0正则化是通过限制向量中非0的元素的个数实现模型优化，用L0来正则化一个参数举证 $W$ , 目标是使其更稀疏，即 $W$ 中的大部分元数都是0。很明显，如果通过L0范数作为罚项， 就是寻找最优稀疏特征项.<br>L1正则化是通过对向量中各个元素绝对值之和进行限制，任何的规则化算子，如果在 $W_i = 0$ 的地方不可微，并且可以分解为多项式的形式，那么这个规则化算子就可以实现稀疏。<br>L2正则化是指向量各元素求平方和然后求平方根，用模最小化来确保 $w$ 的每个元素都很小，都接近于0。</p></li><li><p>什么是交叉校验？常用的交叉校验方法有哪些？<br>常用方法：HoldOut检验、简单交叉检验、k折交叉检验、留一交叉检验</p></li><li><p>如何评价一个算法的性能？<br>分类算法评价指标有：准确率、准确率、召回率、F1值、ROC曲线等<br>回归模型的评价指标有：平均绝对偏差（MAE）、均方误差（MSE）、 均方根误差（RMSE）、R2指标等</p></li><li><p>数据降维有哪些常用的方法？<br>主成分分析、线性判别分析、奇异值分解、局部线性嵌入、拉普拉斯特征映射</p></li><li><p>举例解释主成分分析。<br>主成分分析是最常用的线性降维方法，它的目标是通过某种线性投影，将高维的数据映射到低维的空间中，并期望在所投影的维度上数据的方差最大，以此使用较少的维度，同时保留较多原数据的维度。</p></li><li><p>LDA的基本思想是什么？<br>线性判别分析的原理是对于给定的训练集，设法将样本投影到一条直线上，是的同类的投影点尽可能的接近，异类样本的投影点尽可能的远离。<br>在对新样本进行分类时，将其投影到这条直线上，再根据投影点的位置来确定新样本的类别。</p></li><li><p>拉普拉斯特征映射的功能是什么？<br>拉普拉斯特征映射是一种基于图的降维算法，它希望相互间有关系的点在降维后的空间中尽可能的靠近，从而在降维后仍能保持原有的数据结构</p></li><li><p>为什么要考虑特征提取？<br>特征提取目的是自动地构建新的特征，将原始数据转换为一组具有明显统计意义的核心特征</p></li><li><p>特征构造有哪些常用的方法？<br>一般使用混合属性或者组合属性来创建新的特征，或是分解、切分原有的特征来创建新的特征。<br>特征生成前的原始数据可以分单列变量、多列变量、多行样本（时间序列）等三种情况。</p></li><li><p>特征提取有哪些常用的方法？<br>主成分分析、独立成分分析、线性判别分析</p></li><li><p>线性回归的过程是什么？</p><ol><li>确定输入变量与目标变量间的回归模型，即变量间相关关系的数学表达式。</li><li>根据样本估计并检验回归模型及未知参数。</li><li>从众多的输入变量中，判断哪些变量对目标变量的影响是显著的。</li><li>根据输入变量的已知值，来估计目标变量的平均值并给出预测精度。</li></ol></li><li><p>逻辑回归为什么可以预测新样本的类别？<br>LR是一种预测分析，解释因变量与一个或多个自变量之间的关系。<br>与线性回归不同的是它的目标变量有多种类别, 所以逻辑回归主要用于解决分类问题。<br>与线性回归相比，它用概率的方式，预测出来属于某一分类的概率值，如果大于50%，则属于该分类。</p></li><li><p>举例说明二次判别分析的功能。</p></li><li><p>在机器学习过程的每个阶段，机器学习起到什么作用？</p></li></ul><h3 id="决策树与分类算法">决策树与分类算法</h3><ul><li><p>分类解决什么问题？<br>分类算法是利用训练样本集获得的分类函数（分类模型），从而实现将数据集中的样本划分到各个类中。<br>分类模型通过学习训练样本中的属性集与类别之间的潜在关系，并以此为依据对新样本属于哪一类进行预测。</p></li><li><p>常用的分类算法有哪些？<br>决策树、支持向量机、最近邻、贝叶斯网络和神经网络等。</p></li><li><p>简述决策树的生成过程。<br>决策树的构建过程是按照属性的优先级或重要性来逐渐确定树的层次结构，使其叶子节点尽可能属于同一类别，一般采用局部最优额贪心策略来构建决策树。</p></li><li><p>总结常用的决策树C5.0、CHAID、CART等算法的分支标注。<br>C5.0 算法选择分支变量的依据：以信息熵的下降速度作为确定最佳分支变量和分隔阈值的依据。信息熵的下降意味着信息的不确定性下降。<br>CHAID 算法分支处理的标注指标是：独立性检验和相关性（分裂后自变量与目标变量的相关性）。<br>CART 算法在处理中分支属性的度量指标是： Gini指标。</p></li><li><p>举例说明连续属性离散化的几种方法。<br>非监督离散化:<br>等宽离散化：将属性划分为宽度一致的若干个区间。<br>等频离散化：将属性划分为若干个区间，每个区间的数量想等。<br>聚类：根据特性将属性划分为不同的簇，以此形式将连续属性离散化。<br>监督离散化：常用的方法是通过选取极大化区间纯度的临界值来进行划分。<br>C4.5 使用熵作为区间纯度的度量标准。<br>CART 使用Gini系数作为区间纯度的度量标准。</p></li><li><p>什么是过拟合问题？如何判断过拟合？<br>模型的训练误差低但是泛化误差比较高，则称此分类模型过拟合。</p></li><li><p>如何减少过拟合？<br>一方面要注意数据训练集的质量，选取具有代表性样本的训练样本集。<br>另一方面要避免决策树过度增长，通过限制树的深度来减少数据中的噪声对于决策树构建的影响，一般采取剪枝的方法。</p></li><li><p>在决策树的训练过程中，如果通过剪枝减少过拟合？<br>剪枝是用来缩小决策树的规模，从而降低最终算法的复杂度并提高预测准确度，包括预剪枝、后剪枝两类。<br>预剪枝的思路是提前终止决策树的增长，在形成完全拟合训练样本集的决策树之前就停止树的增长，避免过拟合。<br>后剪枝的策略是先让决策树完全生长，之后针对子树进行判断，用叶子节点或者子树中最常用的分支替换子树，以此方式不断改进决策树，直到无法改进为止。</p></li><li><p>决策树的学习质量如何评价？<br>对于一般的分类问题，有训练误差、泛化误差、准确率、精确率、召回率、F值、ROC曲线等指标</p></li><li><p>ROC曲线如何绘制？它的主要功能是什么？<br>通过将连续变量设定出过个不同的临界值，从而计算出一系列真正率和假正率，再以假正率为纵坐标、真正率为横坐标绘制出ROC曲线。<br>ROC曲线下面积越大，模型的准确性越高。在ROC曲线上，最靠近坐标左上方的点为假正率和真正率均较高的临界值。</p></li><li><p>AUC与ROC的关系是什么？<br>ROC曲线下的面积称为AUC。<br>AUC值越大，表示模型准确性越高。<br>ROC曲线越光滑，一般代表过拟合现象越轻。</p></li><li><p>阅读文献，讨论k折交叉校验的方法。<br>k折交叉验证法将样本集随机地划分为k个大小相等的子集，在每一轮交叉验证中， 选择一个子集作为检验集，其余子集作为训练集，重复k轮，保证每一个子集都作为检验集出现。<br>用K轮检验结果取平均值作为模型好坏的评价标准。</p></li><li><p>集成学习的基本原理是什么？<br>集成学习方法是指组合多个模型，以获得更好的效果，使集成的模型具有更强的泛化能力。<br>最常见的集成思想有两种：bagging、boosting。</p></li><li><p>讨论GBDT算法的过程以及应用。<br>梯度提升决策树算法（GBDT）是利用梯度下降的思想，使用损失函数的负梯度在当前模型的值，作为提升树中残差的近似值，以此来拟合回归决策树。<br>算法过程:<br>初始化决策树，估计一个使损失函数最小化的常数构建一个只有根节点的树。<br>不断提升迭代：<br>计算当前模型中损失函数的负梯度值，作为残差的估计值；<br>估计回归树中叶子节点的区域，拟合残差的近似值；<br>利用线性搜索估计叶子节点区域的值，使损失函数极小化；<br>更新决策时。<br>经过若干轮的提升法迭代后，输出最终的模型。</p></li><li><p>以随机森林为例，讨论集成学习能否提高分类的性能。<br>随机森林算法目标是通过将多个弱学习机（如单棵决策树）组合得到一个强学习机。</p></li><li><p>举例说明决策树在实际分类项目中的应用。</p></li><li><p>计算整个Adult数据集中性别属性的Gini指标值和信息增益。</p></li><li><p>使用Python对Iris数据集实现代价复杂度剪枝策略（CCP）。</p></li></ul><h3 id="聚类分析">聚类分析</h3><ul><li><p>聚类分析的目的是什么？<br>聚类分析用于对未知类别的样本进行划分，将它们按照一定的规则划分成若干个类簇，从而揭示样本之间内在的性质以及相互之间的联系。</p></li><li><p>讨论聚类与分析的关系。<br>聚类算法将未标记的样本自动划分为多个类簇，但不会提供对每个类簇的语义解释，这就需要分析人员对聚类结果进行归纳总结，阐述聚类的意义。</p></li><li><p>聚类分析常用的应用领域有哪些？<br>金融保险、生物学、医学、军事、地理、电子商务等领域都有重要用途。</p></li><li><p>常见的聚类有哪些方法？这些方法分别适用于什么场合？<br>基于划分<br>基于层次<br>基于密度<br>基于模型</p></li><li><p>评价聚类算法的好坏可以从哪些方面入手？<br>良好的可伸缩性、处理不同类型数据的能力、处理噪声的能力、对样本顺序的不敏感性、约束条件下的表现、易解释性、易用性等。<br>外部指标包括: Rand统计量、F值、Jaccard指数、FM指数等<br>内部指标：欧氏距离、曼哈顿距离、切比雪夫距离(Chebyshev distance)、闵可夫斯基距离(Minkowski Distance)、紧密度、分隔度、戴维森堡丁指数(DBI)、邓恩指数等</p></li><li><p>在聚类分析中，样本之间的距离常用的计算方法有哪些？<br>欧氏距离、曼哈顿距离、切比雪夫距离(Chebyshev distance)、闵可夫斯基距离(Minkowski Distance)等</p></li><li><p>简要说明基于划分的聚类方法的基本原理。<br>基于划分的方法通过将对象划分为互斥的簇进行聚类， 每个对象属于且仅属于一个簇。<br>划分结果旨在使簇之间的相似性低，簇内部的相似度高。</p></li><li><p>k-均值算法的聚类数k如何确定？<br>第一种方法：与层次聚类算法结合，先通过层次聚类算法得出大致的聚类数目，并且获得一个初始聚类结果，然后再通过k-均值算法改进聚类结果<br>第二种方法：基于系统演化的方法，将数据集视为伪热力学系统，在分裂和合并过程中，将系统演化到稳定平衡状态从而确定k值</p></li><li><p>讨论初始的k个假设聚类中心位置对k-均值算法的影响。<br>k-means算法对初始化聚类中心依赖性比较大，很可能陷入局部最优的情况或使得迭代次数增加</p></li><li><p>k-medoids算法和k-prototype算法对k-均值算法做了哪些改进？<br>k-medoids(中心点算法)不通过计算簇中所有样本的平均值得到簇的中心，而是通过选取原有样本的样本点作为代表对象代表这个簇，计算剩下的样本点到代表对象的距离，将样本点划分到与其距离最近的代表对象所在的簇中。<br>k-prototypes算法在聚类的过程中，是将数据的数值型变量和类别型变量拆开，分开计算样本间变量的距离，再将两者相加，视为样本间的距离。 准则就是使用一个合适的损失函数去度量数值型和分类变量对原型的距离。</p></li><li><p>简述CLARANS算法的思想。</p></li><li><p>讨论DBSCAN算法的几个参数如何选择。</p></li><li><p>举例说明DBSCAN算法的应用。</p></li><li><p>简述OPTICS算法的原理以及适用场合。</p></li><li><p>简述基于层次聚类的思想。</p></li><li><p>常见的层次聚类算法有哪些？分别阐述其思想。</p></li><li><p>凝聚型层次聚类算法有何优点？结合案例讨论其应用。</p></li><li><p>讨论自组织映射网络Kohonen聚类算法的基本思想，并举例说明其应用。</p></li><li><p>举例讨论聚类算法与其他算法的组合应用。</p></li></ul><h3 id="文本分析">文本分析</h3><ul><li><p>常见的文本数据有哪些来源？<br>公开数据、自有数据、爬虫抓取</p></li><li><p>文本挖掘的过程由哪几个环节组成？这些环节分别负责哪些工作？<br>分词（文本分词、去停词、词形归一等）、 文本特征提取和表示（词性标注、句法分析、语义分析、特征提取与表示等）、 特征选择、 知识提取和挖掘、应用（文本分类、情感分析、信息抽取、问答系统）等。</p></li><li><p>什么是文本的特征？<br>文本中少量的、具有代表性语义的词语。一组文本特征的集合即可代表整个文本的语义。</p></li><li><p>提取文本特征有哪些常用的方法？结合例子讨论这些方法的应用。<br>文本数据表示： 布尔模型、向量空间模型、概率模型、图空间模型等<br>文本特征选择：无监督（TF-IDF）、有监督（卡方、信息增益、互信息、WLLR等）</p></li><li><p>TF-IDF适合提取什么样的文本特征？在使用过程中TF-IDF有哪些问题？</p></li><li><p>向量空间模型的作用以及常用计算是什么？<br>向量空间模型能把文本表示成由多维特征构成的向量空间中的点，从而通过计算向量之间的距离来判定文档和查询关键词之间的相似程度。<br>常用度量方法：最小编辑距离、欧氏距离、余弦距离、Jaccard相似度等</p></li><li><p>分析文本分词的基本思想<br>中文分词主要包括词的歧义切分、未登录词识别。</p></li><li><p>文本分词有哪些常用的算法？<br>基于词典<br>基于统计<br>基于规则</p></li><li><p>讨论IK Analyzer开源中文分词工具包所用的分词算法，并用这个文具对某文本进行分词。<br>IK分词使用了“正向迭代最细粒度切分算法”</p></li><li><p>命名实体识别的基本算法有哪些？<br>最大熵模型：关键是建立有效的特征模板，结合不同层次和粒度的特征建立中文实体语义知识库。<br>支持向量机：对于特征集的要求比较高，例如使用实体属性、词性、实体间关系等有助于提高识别的准确性，这一方法由于在细分类别上的识别效果不佳，应用较少。<br>条件随机场：一种判别式概率模型，通过分析序列资料实现对目标序列建模，相较于最大熵模型，它引入了上下文信息实现对未知词汇的识别。<br>隐马尔科夫模型：依赖于训练语料的标签标记，它的速度要快一些，所以它更适用于信息检索等实时性要求较高的场景。</p><p>基于统计的方法对特征的选取要求很高，对语料库的依赖也比较大，需要从文本中选择对该项任务有影响的特征，目前大部分细分领域的语料库是基于现有素材经过机器或者人工干预的方式构建的。</p></li><li><p>什么是语义消歧？说明常用的语义消歧方法的基本思想。<br>消歧就是根据上下文来确定对象的真实语义。</p><p>基于词典的词义消歧主要是基于覆盖度实现。即通过计算语义词典中各词与上下文之间合理搭配程度，选择与当前语境最合适的词语。<br>有监督的消歧方法使用已经标记好的语义资料集构建模型，通过建立相似词语的不同特征表示实现去除歧义的目的。<br>半监督或无监督方法仅需要少量人工或不需要人工标注语料，但依赖于大规模的未标注语料和语料上的句法分析结果。</p></li><li><p>举例说明常用句法分析方法的思想与应用。</p></li><li><p>语义分析的难点在何处？</p></li><li><p>文本分类常用在什么领域？<br>文本内容分类、观点挖掘、垃圾邮件检测等</p></li><li><p>如何从一篇比较长的新闻中抽取摘要？</p></li><li><p>问答系统的基本原理是什么？其中的核心问题如何解决？<br>问答系统在回答用户问题时，首先需要正确理解用户所提的自然语言问题，并抽取其中的关键语义信息，然后在已有语料库、知识库或问答库中通过检索、匹配、推理的手段获取答案并返回给用户。<br>问答系统的核心问题在于问句理解、文本信息抽取和知识推理。</p></li><li><p>举例说明如何分析电商评论、论坛帖子、微博用户帖子中用户的情感。</p></li><li><p>讨论如何从事件报道中抽取相关的信息。<br>事件抽取技术是从非结构化信息中抽取出用户感兴趣的事件，并以结构化呈现给用户。<br>常用的事件抽取的方法包括模式匹配方法和机器学习方法。</p></li></ul><h3 id="神经网络">神经网络</h3><ul><li><p>简述感知机的基本原理。<br>一个感知机神经元将所有的输入参数$x = (x_1, x_2, … , x_n)$与对应的权值$w = (w_1, w_2, … , w_n)$进行加权求和，经过激活函数变换后输出，公式如下： $ y = f(x * w + b) $</p></li><li><p>讨论BP神经网络的学习过程。<br>初始化网络权值和神经元的阈值，一般通过随机的方式进行初始化。<br>前向传播，计算隐层神经元和输出层神经元的输出。<br>后向传播，根据目标函数公式修正权值 $w_{ij}$ 。<br>上述过程反复迭代，通过损失函数和成本函数对前向传播结果进行判定，并通过后向传播过程对权重参数进行修正，一直到满足终止条件为止。</p></li><li><p>BP神经网络有哪些常见应用？<br><strong>函数逼近</strong>：用输入向量和相应的输出向量训练一个网络逼近一个函数。<br><strong>模式识别</strong>：用一个待定的输出向量将它与输入向量联系起来。<br><strong>分类</strong>：把输入向量所定义的合适方式进行分类。<br><strong>数据压缩</strong>：减少输出向量维数以便于传输或存储。</p></li><li><p>神经网络的激活函数有哪些？它们对神经网络的性能有何影响？<br><strong>Sigmoid</strong>：优点在于输出范围为 $(0, 1)$ ，数据在传递过程中不容易发散，并且可以在输出层表示概率值，容易计算。缺点是梯度下降非常明显，两头过于平坦，容易出现梯度消失，而且输出值域不对称。<br><strong>tanh（双曲正切）</strong>：解决了S函数输出值不对称的问题。另外它是完全可微分和反对称的。然而梯度消失的问题任然存在。为了解决学习缓慢、梯度消失问题，可使用更加平缓的变体，如Symmetrical-Sigmoid、Softsign等<br><strong>ReLu（修正线性单元）</strong>：是神经网络中最常用的激活函数。由于ReLU函数是线性特点使其收敛速度比Sigmoid、Tanh更快，而且没有梯度饱和的情况出现。然而，当输入为负值的时候，ReLU会保持静默。</p><p><a href="https://dashee87.github.io/deep%20learning/visualising-activation-functions-in-neural-networks/" target="_blank" rel="noopener">26种神经网络激活函数可视化</a></p></li><li><p>在BP神经网络训练过程中如何减少陷入最小极值点？</p><ol><li>以多组不同参数初始化多个神经网络，按标准方法训练后取其中误差最小的解作为最终参数。</li><li>模拟退火，在每一步都以一定概率接受比当前解更差的结果，从而有助于跳出局部最小。在每步迭代中接受次优解的概率随着时间的推移而逐渐降低，从而保证算法的稳定。</li><li>随机梯度下降，在计算梯度时加入随机因素，因此即使陷入局部极小点，梯度也可能不为0，就有机会跳出局部最小继续搜索。</li><li>遗传算法。</li></ol></li><li><p>在BP神经网络的训练过程中学习步长、隐层个数、隐层单元数等参数如何调整？<br><strong>算法的步长选择</strong> 步长太大，会导致迭代太快，甚至错过最优解。步长太小，迭代速度慢。<br><strong>网络的层数</strong> 理论已经证明，具有偏差和至少一个S型隐层加上一个线性输出层的网络，能够逼近任何有理函数，增加层数可以进一步降低误差，提高精度，但同时也使网络复杂化。另外不能用仅具有非线性激活函数的单层网络来解决问题，因为能用单层网络解决的问题，用自适应线性网络也一定能解决，而且自适应线性网络的运算速度更快，而对于只能用非线性函数解决的问题，单层精度又不够高，也只有增加层数才能达到期望的结果。<br><strong>隐层单元数</strong> 在能够解决问题的前提下，再加上一两个神经元，以加快误差下降速度即可。</p></li><li><p>RBF神经网络的基本原理是什么？</p></li><li><p>RBF为什么可以减少局部极少值难题？</p></li><li><p>Elman神经网络的优点是什么？</p></li><li><p>与决策树比较，神经网络适合处理什么类型的数据和问题？<br>在中小数据集上，优先选择集成树模型。大数据集上推荐神经网络。<br>在需要模型解释度的项目上，优先使用树模型。<br>在项目时间较短的项目上，如果数据质量低（大量缺失值、噪音等），优先使用集成树模型。<br>在硬件条件有限及机器学习知识有限的前提下，优先选择树模型。<br>对于结构化较高的数据，数据量大的数据，优先使用神经网络模型。</p></li><li><p>如何避免过拟合？<br>参数范数惩罚、数据增强、提前终止、Bagging等集成方法、Dropout、批正则化等</p></li><li><p>为什么要对模型的输入数据进行归一化？<br>归一化的目的就是使得预处理的数据被限定在一定的范围内，从而消除奇异样本数据导致的不良影响。</p></li><li><p>什么是梯度消失？<br>在每次训练的迭代中，神经网络权重的更新值与误差函数的偏导数成比例，然而在某些情况下，梯度值会几乎消失，使得权重无法得到有效更新，甚至神经网络可能完全无法继续训练。</p></li><li><p>如何加快梯度下降的速度？<br>Mini-batch 小批量梯度下降法<br>动量(Momentum)梯度下降<br>RMSprop<br>Adam算法<br>Batch Norm</p><p><a href="https://fivecakes.com/p/5bdfa51fd249870dca3afe22" target="_blank" rel="noopener">几种加速梯度下降的方法</a></p></li></ul><h3 id="贝叶斯网络">贝叶斯网络</h3><ul><li><p>贝叶斯定理的适用条件是什么？<br>条件变量之间的独立性</p></li><li><p>举例说明贝叶斯定理的应用。<br>垃圾邮件过滤器</p></li><li><p>在贝叶斯定理的应用过程中，先验概率如何计算？<br>在对历史数据进行统计分析时，为计算方便，常选择现有数据似然分布的共轭分布族(Conjugate Family)中的分布。</p></li><li><p>与决策树、神经网络分类方法比较，贝叶斯定理用于分类有什么不同？<br>叶斯定理用于分类一般是朴素贝叶斯分类（NBC）。<br>朴素贝叶斯分类发源于古典数学理论，有着坚实的数学基础，以及稳定的分类效率。NBC模型所需估计的参数很少，对缺失数据不太敏感，算法也比较简单。<br>因为NBC模型假设属性之间相互独立，所以在属性个数多或者相关性较大时，NBC模型的分类效率比不上决策树模型。NBC模型还需要实现知道先验概率，并且其分类决策存在一定的错误率。</p></li><li><p>贝叶斯网络解决了贝叶斯定理的什么问题？<br>贝叶斯网络解决了变量间需要保持条件独立的假设，贝叶斯网络包括了有向无环图和条件概率表，可以系统地描述变量间的关系。</p></li><li><p>如何构建贝叶斯网络？<br><strong>根据问题和领域专家知识手工构建</strong><br><strong>通过对数据进行分析得到 (贝叶斯网络学习)</strong><br><strong>结合了领域专家知识和数据分析得到</strong></p></li><li><p>结合实例，讨论贝叶斯网络的推理过程。<br><strong>精确推理</strong><br><strong>近似推理</strong></p></li><li><p>缺值环境下的贝叶斯估计要克服什么问题？<br>在缺值时，不能直接套用完整数据下的最大似然估计的方法，需要对数据进行近似处理，常用EM算法处理。<br>缺值状态下的贝叶斯估计也缺少必要的先验信息，因此会使用碎权更新法去确定这部分缺失数据。</p></li><li><p>应用贝叶斯网络适合解决什么问题？<br>贝叶斯网络适用于解决不确定性或不完整性问题。</p></li><li><p>贝叶斯网络如何应用于中文分词？<br>中文分词问题可以描述为给定一句话，将其切分为合乎语法和语义的词语序列。</p><p>设一句完整的话为 $X$，$Y$ 为组成该句话的词语集合，共有 $n$ 个词语。于是分词问题可以转化为求下列式子最大值的问题：<br>$$<br>\begin{align}<br>\displaystyle P(Y|X) =  \frac{P(X|Y) \cdot P(Y)}{P(X)}<br>\end{align}<br>$$<br>也就是 $P(X|Y) \cdot P(Y)$ 最大值。由于任意的分词情况下由词语序列生成句子的精确的，所以可以忽略 $P(X|Y)$ ，因此只需找到 $P(Y)$ 的最大值即可。<br>$$<br>P(Y) = P(Y_1, Y_2, … ,Y_n) = P(Y_1) * P(Y_2 | Y_1) * P(Y_3|Y_1, Y_2) * …<br>$$<br>这样的展开子式是指数级增长的，并且数据稀疏的问题也会越来越明显。所以我们假设每个词语只会依赖于词语序列中该词前面出现的k个词语，即k-gram。这里我们假设 $k=2$，于是就有：<br>$$<br>P(Y) = P(Y_1, Y_2, … ,Y_n) = P(Y_1) * P(Y_2|Y_1) * P(Y_3|Y_2) * …<br>$$</p></li><li><p>使用贝叶斯网络实现一个简单拼写检查。</p><ol><li>建立一个足够大的文本库</li><li>对文本库的每一个单词统计其出现频率</li><li>根据用户输入的单词，得到其所有可能的拼写相近的形式</li><li>比较所有拼写相近的词在文本库的出现频率。频率最高的那个词，就是正确的拼法</li></ol></li></ul><h3 id="支持向量机">支持向量机</h3><ul><li><p>作为一种分类算法，支持向量机的基本原理是什么？<br>支持向量机是一种二类分类模型。<br>它的基本模型是定义在特征控件上的间隔最大的线性分类器。支持向量机还包括和技巧，这使它成为实质上的非线性分类器。<br>支持向量机的学习策略就是间隔最大化，可形式化为一个求解凸二次规划的问题，也等价于正则化的合页损失函数的最小化问题。</p></li><li><p>支持向量机适合解决什么问题？<br>支持向量机用于二元分类问题，对于多元分类可以将其分解为多个二元分类问题，再进行分类。</p></li><li><p>支持向量机常用在哪些领域？<br>图像分类、文本分类、人脸识别、垃圾邮件检测等</p></li><li><p>支持向量机常用的核函数有哪些？<br><strong>线性核函数</strong> 主要用于线性可分的情况。<br><strong>多项式核函数</strong> 一种非稳态核函数，适合于正交归一化后的数据。<br><strong>径向基核函数</strong> 具有很强的灵活性，应用广泛。大多数情况下有较好的性能。<br><strong>Sigmoid核</strong> 来源于MLP中的激活函数，SVM使用sigmoid相当于一个两层感知机网络</p></li><li><p>核函数的选择对支持向量机的性能有何影响？<br>只要一个对称函数所对应的核矩阵半正定，它就能作为核函数使用。<br>核函数的使用，不一定能够准确的划分，只能说使用哪个核函数，能够逼近真实的划分效果。因此特征空间的好坏对支持向量机的性能至关重要。<br>在不知道特征映射的形式时，我们并不知道什么样的核函数是合适的，而核函数也仅是隐式定义了这个特征空间。<br>于是，核函数的选择成为了支持向量机的最大变数。若核函数选择不合适，则意味着映射到一个不合适的特征空间，很可能导致性能不佳。</p></li><li><p>支持向量机在使用过程中会遇到哪些主要问题？如何解决？</p></li></ul><h3 id="进化计算">进化计算</h3><ul><li><p>遗传算法可以解决哪些问题？<br>遗传算法主要解决技术优化问题，可用于解决数值优化、组合优化、智能控制、人工生命、图像处理、模式识别等领域的问题。<br>比如函数最值问题、旅行商问题、背包问题、车辆路径问题、生产排程问题、选址问题等。</p></li><li><p>讨论遗传算法用于分类问题的原理。<br>用遗传算法解决分类问就是找到一组能姮好拟合训练样本的IF-THEN规则，也就是目标概念。<br>学习过程可以看作是一个搜索过程，也就是在搜索空间中搜索目标概念，目标概念的表示方法有种群表示方法以及单条染色体表示方法。</p></li><li><p>遗传算法的目标函数如何构造？<br>目标函数的构造与期望值有关，同时需要不断尝试，把每一次的目标函数以及得到的结果的平均值记录下来，绘制成图，选择可以使得遗传算法最有效的目标函数</p></li><li><p>讨论遗传算法的常用编码方式<br><strong>二进制编码</strong> 使用0或1表示染色体的基因信息，如0100100<br><strong>格雷编码</strong> 两个相邻的数用格雷码表示，其对应的码位只有一个不相同，从而可以提高算法的局部搜索能力。<br><strong>浮点编码</strong> 是指将个体范围映射到对应浮点数区间范围，精度可以随浮点数区间大小而改变, 用于多维、高精度的连续函数优化问题。<br><strong>符号编码</strong> 指染色体编码串中的基因值可能涉及符号集的字符。使用符号编码，便于编码有意义的基因值。如ADJHKDH</p></li><li><p>遗传算法的步骤有哪些？讨论每个步骤的主要工作。</p><ol><li>随机产生种群</li><li>用轮盘赌策略确定个体的适应度，判断是否符合优化准则，若符合，输出最佳个体及其最优解并结束，否则，进行下一步。</li><li>依据适应度选择再生个体，适应度高的个体被选中的概率高，适应度低的个体被淘汰。</li><li>按照一定的交叉概率和交叉方法，生成新的个体。</li><li>按照一定的变异概率和变异方法，生成新的个体。</li><li>由交叉和变异产生新的一代种群，返回步骤2。</li></ol></li><li><p>初始种群的大小对遗传算法的性能有何影响？<br>规模较大的群体一般对应的个体多样性较高，可以避免算法陷入局部最优解，但计算复杂、算法效率低。<br>群体的规模选择过小会使搜索空间分布范围不足，搜索有可能会停止在一个次优解。</p></li><li><p>讨论基因突变的概率对遗传算法的影响。</p></li><li><p>遗传算法的不足是什么？</p></li><li><p>蚁群算法的原理是什么？<br>蚁群算法来源于蚂蚁寻找食物的过程。<br>蚂蚁总能发现一条从蚁巢到食物源的最短路径。<br>蚂蚁能够在经过的路途中留下“信息素”作为标记，以此来指导自己的活动轨迹。<br>蚂蚁倾向于发现那些“信息素”浓度高的路径，某一路径上走过的蚂蚁越多，遗留下的“信息素”越多，被选中的概率越大，最终形成最短路径。</p></li><li><p>与遗传算法比较，蚁群算法为什么能取得更优的结果？</p></li><li><p>结合案例，讨论蚁群算法的应用过程。</p></li><li><p>与蚁群算法相比，蜂群算法有什么不同？</p></li><li><p>蜂群算法的主要步骤有哪些？</p><ol><li>初始化。</li><li>重复3 ~ 7</li><li>将采蜜蜂与蜜源一一对应，更新蜜源信息，同时确定蜜源的花蜜量。</li><li>观察蜂根据采蜜蜂所提供的信息采用一定的选择策略选择蜜源，根据第一个公式更新蜜源信息，同时确定蜜源的花蜜量。</li><li>确定侦查蜂，寻找新的蜜源。</li><li>记忆迄今为止最好的蜜源。</li><li>判断是否终止。</li></ol></li><li><p>举例说明蜂群算法的应用。</p></li></ul><h3 id="分布式机器学习">分布式机器学习</h3><ul><li><p>分布式学习用在什么场合？<br>机器学习是计算机利用已有的数据生成某种模型，并且利用此模型预测的一种方法。<br>在确定模型结构之后，根据已知模型寻找模型参数的过程就是训练，训练过程中不断依据训练数据来迭代调整模型的参数值，从而使结果更加准确。<br>训练数据集大，模型参数量多，并且各参数需要频繁访问，此时需要进行分布式学习。</p></li><li><p>讨论分布式计算的常用方法。<br><strong>模型并行</strong> 是指在分布式系统不同机器负责网络模型的不同部分。<br><strong>数据并行</strong> 是指不同机器使用同一模型，但是各台机器处理训练数据分割后形成的不同的子数据集。<br><strong>混合并行</strong></p></li><li><p>简述MapReduce计算框架的基本原理。<br>MapReduce框架由一个单独的JobTracker以及每个集群节点对应一个备TaskTracker组成。<br>JobTracker负责调度作业的所有任务，并监控它们的执行，这些任务分布在不同的TaskTracker上，如果任务执行失败，还会调度其重新执行。<br>一个MapReduce作业通常把输入的数据集切分成若干独立的数据块，由Map任务以并行的方式处理，Map输出结果经框架排序后输入到Reduce任务中。<br>整个框架负责任务的调度和监控。</p></li><li><p>MapReduce的过程由哪些环节组成？这些环节分别处理什么工作？</p></li><li><p>为什么Hadoop架构不能处理实时的数据分析工作？<br>Hadoop是一个批处理框架，相较于那些支持流数据的框架，多了些收集数据的时间以及作业调度的时延。<br>从时延角度看，Hadoop不适合处理实时的数据分析工作。<br>Hadoop是基于MapReduce模型的，处理海量数据的离线分析工具，MapReduce模型在实时领域很难有所发挥。</p></li><li><p>举例说明MapReduce的应用。<br>MapReduce多应用在日志分析、搜索引擎、数据挖掘以及信息提取等领域。<br>例如索引系统是Google最大的MapReduce应用程序。Yahoo定期在搜索业务上使用Hadoop来提高其产品和服务，如排名功能和目标广告等。</p></li><li><p>与Hadoop相比，Spark对大数据的处理速度为什么显著提升？<br>Spark是基于内存计算的，省去了Hadoop的大量的磁盘读写操作。<br>Spark对于迭代操作支持延迟处理，在Action操作时才会进行真正的运算。这时可以对计算进行优化，也可以加快处理速度。</p></li><li><p>结合实例，讨论MapReduce在并行决策树算法的应用。<br>并行决策树算法基于MapReduce框架核心思想是分而治之的策略。 将决策树算法中最耗时的属性相似度计算并行运行可以大大提高运行效率。<br>在Map阶段，Map函数以单个元组的形式分解数据。计算属性的相似度，并以&lt;属性名,相似度&gt;的形式输出数据。<br>Reduce阶段，对输出结果中的所有局部结果及相关汇总，找到最大相似度的属性名，选择这个属性作为测试节点，判断它是否为叶子节点，如果是叶子节点，则返回；反之，执行分裂，并将其录入待计算数据库中存储。</p></li><li><p>结合实例，讨论并行k-均值算法的计算过程。</p></li><li><p>查找资料，讨论如何对关联算法Apriori进行并行化改造？</p></li><li><p>讨论对于大样本数据，如何对多元线性回归模型进行并行化改造？</p></li></ul><h3 id="深度学习">深度学习</h3><ul><li><p>深度学习的提出背景是什么？<br>深度学习是一种利用复杂结构的多个处理层来实现对数据进行高层次抽象的算法，是机器学习的一个重要分支。<br>传统的BP算法仅有几层网络，需要手工指定特征且易出现局部最优问题，而深度学习引入了概率生成模型，可自动地从训练集提取特征，解决了手工特征考虑不周的问题。<br>而且初始化了神经网络权重，采用反向传播算法进行训练，与BP算法相比取得了很好的效果。</p></li><li><p>讨论大数据技术对深度学习的促进作用。<br>除了组织存储的数据类型的不同，数据的绝对量是促进深度学习工具和技术发展的一个关键因素。积累了足够的数据后，技术才能更好地发挥作用。</p></li><li><p>比较深度学习主流的几种学习框架。<br><strong>Torch</strong><br><strong>TensorFlow</strong><br><strong>Caffe</strong><br><strong>Keras</strong></p></li><li><p>描述卷积神经网络的结构。<br>卷积神经网络是一种稀疏的网络结构，其中卷积层和子采样层是特征提取功能的核心模块。<br>卷积神经网络采用梯度下降的方式，应用最小化损失函数对网络中各节点的权重参数逐层调节，通过反向递推，不断地调整参数使得损失函数的结果逐渐变小，从而提升整个网络的特征描绘能力，使卷积神经网络分类的精确度和准确率不断提高。</p></li><li><p>卷积神经网络适合解决什么问题？</p></li><li><p>举例说明卷积神经网络的应用。</p></li><li><p>卷积神经网络的输入如何编码？</p></li><li><p>在卷积神经网络中，卷积层和池化层的参数如何确定？</p></li><li><p>常见的卷积神经网络有哪些？<br><a href="http://yann.lecun.com/exdb/publis/pdf/lecun-01a.pdf" target="_blank" rel="noopener">LeNet</a><br><a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="noopener">AlexNet</a><br><a href="https://arxiv.org/abs/1409.1556" target="_blank" rel="noopener">VggNet</a><br><a href="https://arxiv.org/abs/1512.03385" target="_blank" rel="noopener">ResNet</a></p></li><li><p>卷积神经网络的各层激活函数如何选择？</p></li><li><p>如何防止卷积神经网络的过拟合问题？</p></li><li><p>简述循环神经网络模型的工作原理。<br>循环神经网络是一种对序列数据建模的神经网络。<br>循环神经网络中一个当前神经元的输出与前面的输出也有关，网络会对前面的信息进行记忆并应用于当前神经元的计算中，即隐藏层之间的节点是有连接的，并且隐藏层的输入不仅包括输入层的输出还包括上一时刻隐藏层的输出。<br>理论上，循环神经网络可以对任何长度的序列数据进行处理。但是在实践中，为了降低复杂性往往假设当前的状态只与前面的几个状态相关。</p></li><li><p>循环神经网络的常用应用领域有哪些？</p></li><li><p>举例说明循环神经网络的应用过程。</p></li><li><p>结合长短期记忆神经网络的结构解释其工作过程。</p></li><li><p>举例说明长短期记忆神经网络的应用。</p></li><li><p>卷积神经网络如何进行调优？结合具体案例说明。</p></li></ul><h3 id="高级深度学习">高级深度学习</h3><ul><li><p>目标检测和追踪中的运动目标如何合理地表示？<br>首先要获取目标的初始状态并且提取目标的特征，在此基础上构建目标描述模型，模型可分为生成式模型和判别式模型。<br>生成式方法运用生成模型描述目标的表现特征，之后通过搜索候选目标来最小化重构误差。<br>判别式方法通过训练分类器来区分目标和背景。</p></li><li><p>目标检测与追踪的深度学习框架有哪些？<br>基于分类的算法有R-CNN，Fast R-CNN，Faster R-CNN。<br>基于回归的深度学习框架有 YOLO（You Only Look Once) 和 SSD(Single Shot Multibox Detector)</p></li><li><p>举例说明R-CNN的应用。<br>R-CNN可以用于目标检测、图像识别、检索和分类。</p></li><li><p>长短期记忆神经网络的编码-解码模型有哪些？</p></li><li><p>如何理解循环神经网络的记忆力模型？</p></li><li><p>长短期记忆神经网络在图片标注和看图说话等应用中需要注意什么问题？</p></li><li><p>讨论生成式对抗模型的组成。<br>生成对抗网络由一个生成网络与一个判别网络组成。<br>生成对抗网络的实现方法是让生成模型和判别模型进行博弈，训练过程通过互相博弈使两个模型的性能同时增强。<br>生成模型需要在整个条件内去产生数据的分布，就像高斯分布一样，它需要去拟合整个分布。<br>判别模型就像分类一样，通过一个判别界限去区分样本。</p></li><li><p>举例说明生成式对抗模型的应用。</p></li><li><p>迁移学习解决什么问题？<br><strong>小数据的问题</strong><br><strong>个性化的问题</strong></p></li><li><p>迁移学习常用的方法有哪些？<br><strong>基于样本的迁移学习</strong><br><strong>基于特征的迁移学习</strong><br><strong>基于模型的迁移学习</strong><br><strong>基于关系知识的迁移</strong></p></li><li><p>强化学习的基本思想是什么？<br>强化学习是目标导向的，从白纸一张的状态开始，经由许多个步骤来实现某一个维度上的目标最大化。在训练的过程中不断尝试，错误就惩罚，正确就奖励，由此训练得到的模型在各个状态环境下都最好。</p></li><li><p>简述Q-学习的基本过程。<br>Q-学习是让主体从一个状态到另一个状态不断转换进行探索学习。<br>主体的每一次探索都会从初始状态到目标状态，相当于一次迭代，训练越多，学到的东西越多。<br>初始化Q，初始化状态奖励值。 主体会探索很多状态直到发现一个奖励，此时更新Q。直到Q收敛。</p></li><li><p>强化学习如何与深度学习结合？</p></li></ul><h3 id="推荐系统">推荐系统</h3><ul><li><p>推荐系统的功能是什么？<br>推荐系统是一种帮助用户快速发现有用信息的工具。<br>通过分析用户的历史行为，研究用户偏好，对用户兴趣建模，从而主动给用户推荐能够满足他们感兴趣的信息。<br>本质上，推荐系统是解决用户额外信息获取的问题。在海量冗余信息的情况下，用户容易迷失目标，推荐系统主动筛选信息，将基础数据与算法模型进行结合，帮助其确定目标，最终达到智能化推荐。</p></li><li><p>讨论推荐系统的结构组成。<br><strong>输入模块</strong><br><strong>推荐算法模块</strong><br><strong>推荐输出模块</strong></p></li><li><p>推荐系统常用于哪些领域？<br>可用于电商平台、个性化电影网站、音乐歌单、社交网络、新闻网站、个性化阅读、个性化广告等。</p></li><li><p>推荐系统常用哪些方法？这些方法分别适用什么场合？<br><strong>基于人口统计学的推荐</strong><br><strong>基于内容的推荐</strong> 适用于物品特征易于提取的场合<br><strong>基于协同过滤的推荐</strong> 适用于能够获取到用户历史行为的场合<br><strong>基于关联规则的推荐</strong> 常用于实体商店或在线电商的推荐系统<br><strong>基于知识的推荐</strong><br><strong>基于约束的推荐</strong><br><strong>基于标签的推荐</strong> 适用于有描述信息的关键词产生和应用的场合</p></li><li><p>基于内容的推荐基本思想是什么？<br>根据物品的属性和用户的特殊偏好，直观的选择可推荐物品。</p></li><li><p>举例说明基于内容的推荐应用过程。<br>UserA偏爱科幻小说，ItemA是一本科幻小说，系统便会直接推荐ItemA给UserA。</p></li><li><p>如何为用户和物品建模？</p></li><li><p>如何计算推荐过程中用户和商品的相似性？</p></li><li><p>基于协同过滤的推荐基本思想是什么？</p></li><li><p>基于协同过滤的推荐适用于什么场合？</p></li><li><p>基于用户的协同推荐与基于物品的协同有什么不同？</p></li><li><p>什么是冷启动问题？如何解决？<br>冷启动是数据较少问题。<br><strong>系统冷启动</strong> 先建立起物品的相关度，通过某一物品可以检索到与之相似的其他物品，用户表现出对物品感兴趣后推荐与之相似的其他物品。<br><strong>物品冷启动</strong> 新上线的物品可以利用物品内容相似性，推荐给喜欢类似物品的用户。<br><strong>用户冷启动</strong> 提供非个性化推荐，比如热门排行。或者利用用户注册信息以及用户的社交网络账号。</p></li><li><p>举例说明基于图的推荐算法基本思想及其应用。</p></li><li><p>举例说明隐语义模型在推荐中的应用。</p></li><li><p>简述Apriori和FP增长等关联算法的基本过程。</p></li><li><p>举例说明关联推荐的过程。</p></li><li><p>推荐算法的性能如何评价？<br>满意度、预测准确度、覆盖率、多样性、新颖性、惊喜度、信任度、实时性、健壮性等</p></li><li><p>如何组合基于内容的推荐与基于协同的推荐等多种推荐算法？</p></li><li><p>查找资料，讨论推荐系统的最新发展趋势。</p></li></ul><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://www.amazon.cn/dp/B07NYN8JR1" target="_blank" rel="noopener">机器学习</a></p>]]></content>
    
    <summary type="html">
    
      上帝说，要有光。
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="DAE" scheme="https://neo1989.net/tags/DAE/"/>
    
      <category term="ML" scheme="https://neo1989.net/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title>自学机器学习十诫</title>
    <link href="https://neo1989.net/Notes/NOTE-the-10-commandments-of-self-taught-machine-learning-engineers/"/>
    <id>https://neo1989.net/Notes/NOTE-the-10-commandments-of-self-taught-machine-learning-engineers/</id>
    <published>2020-11-02T09:27:40.000Z</published>
    <updated>2023-01-13T03:04:52.752Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>戒律和自学这两个词不能掉以轻心。一个人必须对自己的教育和启蒙负责。如果你忽略它，别人就会为你做选择。</p></blockquote><h2 id="Gists-摘要">Gists 摘要</h2><h3 id="数学，代码和数据是你最重要的Trinity">数学，代码和数据是你最重要的Trinity</h3><p>任何有效的机器学习管道都是数学、代码和数据的交叉。每一项只有和另一项在一起时才会有效果。</p><p>如果你的数据质量很差，那么无论你的数学计算多么优雅或代码多么高效都没用。</p><p>如果你的数据质量最高，但你的数学计算错误，那么你的结果可能会不是很好，甚至会更糟，造成伤害。</p><p>如果你的数据和数学都是世界级的，但是你的代码效率很低，那么你将无法获得扩展带来的好处。</p><p>数据为你提供了一个包含自然瑰宝的采矿地点。数学就是你的十字镐。代码可以让你建立一支挥舞着十字镐的机器人队伍。</p><p>Trinity是你系统的输入(你拥有的)和输出(你想要的)之间的桥梁。</p><h3 id="唯一例外">唯一例外</h3><p>除了不能平衡Trinity，还有一个更大的罪过：忘记这Trinity是为谁服务的。即使是执行得最好、由最优雅的数学驱动的代码，如果不能为客户提供服务，从最丰富的数据中获得洞察也毫无意义。</p><p>工程师经常会发现自己迷失在一个过程中，忘记了最初想要的结果。尽管他们怀着良好的意图进行，但他们忘记了，意图并不像行动那么重要。</p><p>Trinity至少要为客户提供点好处，总比什么都不提供要好。</p><p>需要澄清的是，如果你的先进模型需要47倍的时间才能提高1%的准确率，那么它是否提供了最好的体验？</p><h3 id="不要被Trinity给骗了">不要被Trinity给骗了</h3><p>无论你多么崇拜这Trinity，你都不应该被你的爱蒙蔽。自学成才的机器学习工程师是他们自己的最大的怀疑者。</p><p>他们知道，数据不能进行证明，只能进行反驳(只要在十亿数据中有一个数据点就能证明之前的概念是错误的)，一点点糟糕的数学运算就会产生极端的后果(自然不是线性的)，代码的效率只有在它最薄弱的地方才有。</p><p>无论Trinity多么神圣，直觉也不应被忽视。如果一个结果好得令人难以置信，除非你很幸运，否则它很可能就是错的。</p><h3 id="和客户保持好关系">和客户保持好关系</h3><p>让机器做它们擅长的事情(反复重复过程)。让你去做你擅长的事情时(关心、设身处地、提问、倾听、领导、教学)。</p><p>你的客户不像你那样关心Trinity。他们关心他们的需求是否得到满足。</p><h3 id="向先驱致敬">向先驱致敬</h3><p>当你想到计算机、机器学习、人工智能、数学等领域时，你会想到谁的名字？</p><p>Ada Lovelace，Geoffrey Hinton，Yann LeCun，Yoshua Bengio，Alan Turing，Fei Fei Li，Grace Hopper，Andrew Ng，Jon Von Neumann，Alan Kay，Stuart Russel，Peter Norvig？</p><p>当然，在你听到或记住的所有名字中，有1000个名字功不可没，但却从历史书中消失了。</p><p>后起之秀应该认可前辈们做出的巨大努力，但也应该认可他们中的每一个人都会告诉这位新晋的机器学习工程师同样的事情：这个领域的未来取决于你的工作。</p><h3 id="适时重写">适时重写</h3><p>你的目标应该是在第一时间构建可靠的东西。但随着技能的提高，你可能会重构之前的作品，拆掉它们，用新的视角重新创造它们。</p><p>自学成才的机器学习工程师都明白，就像大自然一样，软件和机器学习项目永远不会完成，它们一直在运动。数据变化，代码在新的硬件上执行，一个天才发现了一个计算高效，低内存依赖的优化器适合，并称之为“亚当”。</p><p>你不仅应该对这些变化持开放态度，还应该欢迎它们。一旦它们出现，请使用你最好的判断力来判断它们是否值得实现到你的系统中 —— 因为有些东西是新的，并不意味着它是必需的。</p><h3 id="不要成为工具奴">不要成为工具奴</h3><p>在编程界，一个常见的轶事是粉刷自行车棚。它说的是一个程序员，或者一组程序员，担心的是车棚应该是什么颜色，而不是问一些重要的问题，比如车棚是否真的可以存放自行车。</p><p>当然，这个自行车棚也可以用电脑程序来代替。</p><p>在机器学习的世界里，你会听到关于R还是Python、TensorFlow还是PyTorch、书籍还是课程、数学还是code first(两者都有，记得这Trinity吧)、Spark还是Hadoop、Amazon Web Services还是谷歌云平台、VSCode还是Jupyter、Nvidia还是……的无休止的争论。</p><p>所有的比较都是有效的，但没有一个值得与对方争论。</p><p>你应该回答的真正问题是：用什么可以让我以最快、最可靠的方式建立我的想法？</p><p>一旦你问自己这个问题，你会发现其他人都在问自己同样的问题。</p><p>工程师的诅咒是从工具开始，然后寻找问题，而不是从问题开始，然后寻找工具，只有到了那个时候，如果没有合适的工具，才应该去构建它。</p><p>学习资源也是如此。数学、代码和数据的Trinity，在你学习它的时候就是不变的，唯一重要的是你如何使用它。</p><p>不要忘记：许多问题可以在没有机器学习的情况下解决。</p><h3 id="想法就是生意">想法就是生意</h3><p>不要把一个执行好想法的人与窃取你想法的人混为一谈。你的想法在别人手中比在你的头脑中更有价值。</p><p>作为一名工程师，你的角色不仅是建立自己的想法，而且还要与他人沟通，向他们展示如何从这些想法中获益。如果你缺乏这样的沟通能力，你应该与有这种能力的人合作，或者寻求培养这种能力。</p><p>在一个没人知道该相信什么的世界里，你可以通过做真实的自己来区分自己。诚实面对你做的东西所能提供的和你所不知道的。能够承认自己的无知是一种优势，而不是弱点。</p><p>好的技术总是胜利的，撒谎永远不会胜利。构建技术。不要撒谎。</p><h3 id="你的邻居、同事、同学和伙伴也在思考这个问题">你的邻居、同事、同学和伙伴也在思考这个问题</h3><p>你看到别人的进步而嫉妒吗？或者你把它看作是你能做到的事情的动力？</p><p>你对别人的成功的感觉就是你自己成功时候的感觉。</p><h3 id="不能贪">不能贪</h3><p>你应该寻求建立你运用Trinity的技能，回答那些你想要提供服务的人的问题，但你不应该带着欲望这样做。欲望会诅咒你，让你永远过于严肃地看待未来，而不是享受你现在所拥有的。</p><p>对提高技能的渴望的治疗方法是培养对学习的热爱。</p><p>自学成才的机器学习工程师能够很快地学习利用数学、代码和数据力量所需的概念，但不能匆忙行事。他们明白学习任何有价值的技术都需要时间，如果是这样的话，还不如享受这个过程。</p><p>从一开始，你就是对自己的启蒙和教育负责的人。知道了这一点，你就应该选择那些无论你有什么样的运气都能成功的项目。这个项目是否满足了你的好奇心？它是否对你的技能构成挑战？它可以让你遵守这些戒律吗？如果是这样，就足够了。</p><p>最后，在沿着自己的道路行进的同时，自学成才的机器学习工程师在他们的脑海中一直保持着这样的印象：</p><ul><li>No certifications without knowledge.</li><li>No (over)thinking without doing.</li><li>No learning without enjoyment.</li><li>No creations without style.</li><li>No skill without practice.</li><li>No tools without purpose.</li><li>No showboating without shipping.</li><li>No assumptions without scepticism.</li><li>No consumption without contribution.</li><li>No desire for the future without love for the present.</li></ul><p>最重要的是，<strong>No machine learning without the trinity</strong>。</p><h2 id="Reference-参考">Reference 参考</h2><p>[1] <a href="https://danielbourke.substack.com/p/the-10-commandments-of-self-taught" target="_blank" rel="noopener">The 10 Commandments of Self-Taught Machine Learning Engineers</a></p>]]></content>
    
    <summary type="html">
    
      Principles for using math, code and data to seduce Mother Nature into revealing her secrets.
    
    </summary>
    
    
      <category term="Notes" scheme="https://neo1989.net/categories/Notes/"/>
    
    
      <category term="DAE" scheme="https://neo1989.net/tags/DAE/"/>
    
      <category term="ML" scheme="https://neo1989.net/tags/ML/"/>
    
  </entry>
  
</feed>
